Protokoll – 05-Events-und-Echtzeit
==================================

Eintrag 1
- Datum/Uhrzeit: [bitte ausfüllen]
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung: Initiales Protokoll angelegt; Event-Factory/Stream-Konsolidierung geplant.
- Begründung/Ziel: Einheitliche Events, weniger Frontend-Sonderlogik.
- Auswirkungen/Backwards-Compat: Alte Eventformen werden migriert/adaptert.
- Tests/Validierung: Stream-Mock, Event-Schema-Validierung.
- Nächste Schritte: Event-Factory entwerfen; SSE-Endpoint v1 vorbereiten.
- Genehmigung des Users: [bitte ausfüllen]
- Commit/Push (nur User): [bitte ausfüllen]

Eintrag 2
- Datum/Uhrzeit: 2025-10-14 09:15 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `special_fields.handle_player_swap` stellt die Erstellung beider Swap-Events auf `event_service.create_event` um.
- Begründung/Ziel (Warum):
  - Einheitliche Event-Erzeugung auch für Spezialfelder, strikt JSON, weniger Duplikation.
- Test-Anleitung (Wie testen):
  - Würfeln bis Spieler-Tausch ausgelöst wird; danach `curl -s http://localhost:5001/api/v1/status/board | jq`.
  - Erwartung: `data.last_special.type == "special_field_player_swap"`, keine Tracebacks.
- Testergebnisse (vom User): erfolgreich (player_swap wurde angezeigt; keine Fehler im Log)
- Auswirkungen/Backwards-Compat: Keine Änderung am äußeren Verhalten/Schema.
- Nächste Schritte: Weitere Spezialfeld-Events sukzessive migrieren (catapult/barrier), dann eval-Fallbacks entfernen.
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 3
- Datum/Uhrzeit: 2025-10-14 09:20 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `special_fields.handle_catapult_forward` nutzt `event_service.create_event` für Event-Erzeugung.
- Begründung/Ziel (Warum):
  - Fortsetzung der Vereinheitlichung: Spezialfeld-Events werden konsistent und sicher (JSON) erzeugt.
- Test-Anleitung (Wie testen):
  - Spielen/würfeln bis „Katapult vorwärts“ ausgelöst wird (ein Team landet auf einem entsprechenden Feld, z. B. 15/30/45/60 o. ä.).
  - Danach: `curl -s http://localhost:5001/api/v1/status/board | jq`
  - Erwartung: `data.last_special.type == "special_field_catapult_forward"`, keine Tracebacks im Log.
- Testergebnisse (vom User): erfolgreich (special_field_catapult_forward angezeigt; keine Fehler im Log)
- Auswirkungen/Backwards-Compat: Keine Änderung am äußeren Verhalten/Schema.
- Nächste Schritte: `catapult_backward` und `barrier_*` Events auf Service umstellen (jeweils in kleinen Schritten).
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 4
- Datum/Uhrzeit: 2025-10-14 09:30 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `special_fields.handle_catapult_backward` nutzt `event_service.create_event` für Event-Erzeugung.
- Begründung/Ziel (Warum):
  - Vereinheitlichung der Spezialfeld-Events (Service, JSON), weniger Duplikation.
- Test-Anleitung (Wie testen):
  - Spielen/würfeln bis „Katapult rückwärts“ ausgelöst wird (z. B. 13/26/39/52/65 je nach Konfig).
  - Direkt danach: `curl -s http://localhost:5001/api/v1/status/board | jq`
  - Erwartung: `data.last_special.type == "special_field_catapult_backward"`, keine Tracebacks im Log.
- Testergebnisse (vom User): erfolgreich (special_field_catapult_backward angezeigt; keine Fehler im Log)
- Auswirkungen/Backwards-Compat: Keine Änderung am äußeren Verhalten/Schema.
- Nächste Schritte: barrier_* (set/released/blocked) Events migrieren.
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 5
- Datum/Uhrzeit: 2025-10-14 10:35 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `special_fields.handle_barrier_field` (barrier_set) nutzt `event_service.create_event` für Event-Erzeugung.
- Begründung/Ziel (Warum):
  - Vereinheitlichung der Event-Erzeugung (Service, JSON), Vorbereitung zum Entfernen aller eval-Fallbacks.
- Test-Anleitung (Wie testen):
  - Spielen/würfeln bis „Sperren-Feld“ ausgelöst wird (Team landet auf Barrier-Position; siehe `/api/v1/fields/positions` → `barrier`).
  - Direkt danach: `curl -s http://localhost:5001/api/v1/status/board | jq`
  - Erwartung: `data.last_special.type == "special_field_barrier_set"`, keine Tracebacks im Log.
- Testergebnisse (vom User): erfolgreich (special_field_barrier_set angezeigt; keine Fehler im Log)
- Auswirkungen/Backwards-Compat: Keine Änderung am äußeren Verhalten/Schema.
- Nächste Schritte: barrier_released / barrier_blocked migrieren (jeweils separat, klein), dann eval-Fallbacks abbauen.
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 6
- Datum/Uhrzeit: 2025-10-14 10:38 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `special_fields.check_barrier_release`: Event-Erzeugung (`special_field_barrier_released`/`special_field_barrier_blocked`) über `event_service.create_event` migriert.
- Begründung/Ziel (Warum):
  - Vollständige Vereinheitlichung der Barrier-Events, strikt JSON, Vorbereitung zum Entfernen eval-Fallbacks.
- Test-Anleitung (Wie testen):
  - Ein Team ist blockiert (barrier_set aktiv). Würfeln für dieses Team.
  - Danach: `curl -s http://localhost:5001/api/v1/status/board | jq` innerhalb 10s.
  - Erwartung: `data.last_special.type == "special_field_barrier_released"` (bei Befreiung) oder `..._blocked` sonst; keine Tracebacks.
- Testergebnisse (vom User): erfolgreich
- Auswirkungen/Backwards-Compat: Keine Änderung am äußeren Verhalten/Schema.
- Nächste Schritte: eval-Fallbacks aus Lesepfaden entfernen (da neue Events JSON sind) – in kleinen Schritten.
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 7
- Datum/Uhrzeit: 2025-10-14 10:55 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `/api/board-status` (app/main/routes.py): eval-Fallback beim Parsen von Eventdaten entfernt; strikt JSON, unparsbare Legacy-Daten werden geloggt und ignoriert.
- Begründung/Ziel (Warum):
  - Sicherheits- und Stabilitätsverbesserung; keine `eval`-Ausführung von Strings mehr.
- Test-Anleitung (Wie testen):
  - Wurf und ggf. Spezialfeld auslösen; dann `curl -s http://localhost:5001/api/board-status | jq`.
  - Erwartung: `last_dice_result`/`last_special_field_event` gefüllt (wenn innerhalb 10s), keine Tracebacks; Log zeigt ggf. WARN statt ERROR bei alten, nicht-JSON Events.
- Testergebnisse (vom User): erfolgreich (Legacy /api/board-status liefert Daten ohne eval; keine Tracebacks)
- Auswirkungen/Backwards-Compat: Neue Events JSON-basiert; sehr alte, nicht-JSON Events werden nur im 10s-Fenster ignoriert.
- Nächste Schritte: eval-Fallback in weiteren Lesepfaden (z. B. teams/_get_last_dice_result) entfernen – eigener kleiner Schritt.
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 9
- Datum/Uhrzeit: 2025-10-14 11:38 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - Victory-Event in `app/main/routes.py`: `data_json=str({...})` → `json.dumps({...})` (echtes JSON).
- Begründung/Ziel (Warum):
  - Verhindert neue Nicht-JSON-Events; vollständige JSON-Konsistenz.
- Test-Anleitung (Wie testen):
  - Team auf Position 72 setzen (Admin-UI), sicherstellen, dass dieses Team am Zug ist.
  - Würfeln bis Total ≥ 6; dann `curl -s http://localhost:5001/api/v1/status/board | jq`.
  - Erwartung: Victory-Event (`game_victory`) wird erzeugt (ggf. im DB-Event-Log), keine Tracebacks.
- Testergebnisse (vom User): erfolgreich (`docker compose exec web python` Test-Client: `/admin/admin_roll_dice` mit gesetztem Team auf Feld 72 liefert Victory (`victory_triggered: True`), Event als JSON gespeichert)
- Auswirkungen/Backwards-Compat: Keine – nur Speichern als JSON.
- Nächste Schritte: Optional – session_service; ansonsten DB-Neuinitialisierung wie besprochen.
- Genehmigung des Users: [bitte ausfüllen]
- Commit/Push (nur User): [bitte ausfüllen]
- Status: Abgeschlossen
Eintrag 8
- Datum/Uhrzeit: 2025-10-14 10:58 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `app/teams/routes.py` → `_get_last_dice_result`: eval-Fallback entfernt; striktes JSON-Parsing, unparsable Legacy-Daten werden geloggt und ignoriert.
- Begründung/Ziel (Warum):
  - Sicherheit/Härtung, Konsistenz mit `/api/board-status`.
- Test-Anleitung (Wie testen):
  - Als Team im Dashboard: eine Würfelaktion durchführen.
  - Danach Dashboard neu laden oder `GET /teams/api/dashboard-status` aufrufen.
  - Erwartung: Letztes Würfelergebnis korrekt, keine Tracebacks; Log zeigt ggf. WARN statt ERROR bei sehr alten Events.
- Testergebnisse (vom User): erfolgreich (Team-Dashboard zeigt letztes Würfelergebnis korrekt; keine Tracebacks)
- Auswirkungen/Backwards-Compat: Neue Events JSON; sehr alte, nicht-JSON Events werden ignoriert.
- Nächste Schritte: Board-Blau-Problem (SyntaxError an „board:473“) isolieren und fixen – separater, kleiner Schritt.
- Genehmigung des Users: ja
- Commit/Push (nur User): [vom User auszuführen]
- Status: Abgeschlossen

Eintrag 10
- Datum/Uhrzeit: 2025-10-15 09:25 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `docker-compose.yml`: Wechsel auf `network_mode: "host"` und expliziter Startbefehl `flask run --port=5001`, da das aktuelle System keine veth-Paare für Bridge-Netzwerke unterstützt.
- Begründung/Ziel (Warum):
  - Docker-Container startete nicht wegen `operation not supported` beim Einrichten des Bridge-Netzwerks; Host-Netzwerk ermöglicht die Live-Umgebung ohne Infrastrukturbruch.
- Test-Anleitung (Wie testen):
  - `docker compose up -d`
  - `curl -s http://localhost:5001/api/v1/status/board`
  - Erwartung: Container startet fehlerfrei, API liefert JSON (success true).
- Testergebnisse (vom User): erfolgreich (`docker compose up -d` startet Container, `status/board` gibt Daten zurück).
- Auswirkungen/Backwards-Compat: Service läuft weiterhin auf Port 5001; nur Deployment auf Nicht-Linux oder Mehrcontainer-Setups müsste Host-Netzwerk prüfen.
- Nächste Schritte: Optionalen Victory-Test (Eintrag 9) durchführen; danach DB-Reset wie in `AKTUELL.md` beschrieben.
- Genehmigung des Users: [bitte ausfüllen]
- Commit/Push (nur User): [bitte ausfüllen]
- Status: Abgeschlossen

Eintrag 11
- Datum/Uhrzeit: 2025-10-15 09:40 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `docker compose exec web python init_db.py`: Datenbank komplett neu initialisiert (inkl. Backup/Restore der Runden).
  - Nach dem Reset alle Teams via Skript auf Position 0 gesetzt, Blockaden/Boni zurückgesetzt.
- Begründung/Ziel (Warum):
  - Schritt aus `AKTUELL.md` abschließen, um mit frischer Datenbasis weiterarbeiten zu können; sicherstellen, dass Teams am Startfeld beginnen.
- Test-Anleitung (Wie testen):
  - `docker compose exec web python - <<'PY' ...` → alle Teams ausgeben.
  - Erwartung: Jeder Eintrag zeigt `position=0`, `bonus=0`, `blocked=False`.
- Testergebnisse (vom User): erfolgreich (Team 1 & Team 2 beide auf Position 0, keine Blockaden/Boni aktiv).
- Auswirkungen/Backwards-Compat: Alle bestehenden Spielsituationen verworfen; frischer Spielstand.
- Nächste Schritte: Session-Service/Stream-Logik vorbereiten (siehe Roadmap), Board-Blau-Bug gemäß Eintrag 8 prüfen.
- Genehmigung des Users: [bitte ausfüllen]
- Commit/Push (nur User): [bitte ausfüllen]
- Status: Abgeschlossen

Eintrag 12
- Datum/Uhrzeit: 2025-10-15 09:45 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - Neuer Service `app/services/session_service.py` eingeführt (`get_active_session`, `require_active_session`).
  - Admin-Routen (`moderation_mode_api`, `/admin/admin_roll_dice`) nutzen `get_active_session()` statt direkter Query.
- Begründung/Ziel (Warum):
  - Schrittweiser Aufbau des Session-Service; zentrale Abfrage vermeidet Streuung und erleichtert Tests.
- Test-Anleitung (Wie testen):
  - `docker compose exec web python - <<'PY' ...` → Aufruf von `get_active_session()` / `require_active_session()`.
  - Erwartung: aktive Session wird gefunden, `require_active_session` liefert ID.
- Testergebnisse (vom User): erfolgreich (Script gibt aktive Session-ID 2 zurück, kein LookupError).
- Auswirkungen/Backwards-Compat: Keine Laufzeitänderung; reine interne Umstellung.
- Nächste Schritte: Weitere Routen auf Session-Service umstellen; Board-Blau-Bug angehen.
- Genehmigung des Users: [bitte ausfüllen]
- Commit/Push (nur User): [bitte ausfüllen]
- Status: Abgeschlossen

Eintrag 13
- Datum/Uhrzeit: 2025-10-15 09:50 (ungefähr)
- Ort/Ordner: Überarbeitung/05-Events-und-Echtzeit
- Änderung (Was):
  - `app/admin/routes.py`: `calculate_automatic_placements` nutzt `session_service.get_active_session()` statt eigener Query.
- Begründung/Ziel (Warum):
  - Konsistente Nutzung des Session-Services auch für Auswertungslogik; reduziert Duplikation.
- Test-Anleitung (Wie testen):
  - `docker compose exec web python - <<'PY' ... calculate_automatic_placements()` ausführen.
  - Erwartung: Funktion läuft durch (gibt Log/Print aus), keine Exceptions.
- Testergebnisse (vom User): erfolgreich (`calculate_automatic_placements executed without error` im Testskript).
- Auswirkungen/Backwards-Compat: Keine; Funktionsverhalten unverändert.
- Nächste Schritte: Weitere Session-bezogene Funktionen migrieren; Board-Blau-Bug priorisieren.
- Genehmigung des Users: [bitte ausfüllen]
- Commit/Push (nur User): [bitte ausfüllen]
- Status: Abgeschlossen
