{% extends "base.html" %}

{% block title %}Insel der Abenteuer{% endblock %}

{% block head_extra %}
<meta name="csrf-token" content="{{ csrf_token() }}">
<style>
/* CSS Reset und body setup */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #ffffff;
}

.game-container {
    display: block !important;
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    right: auto !important;
    bottom: auto !important;
    transform: translate(-50%, -50%) !important;
    width: 800px !important;
    height: 600px !important;
    flex-direction: unset !important;
    flex: none !important;
    gap: 0 !important;
    margin: 0 !important;
    background: radial-gradient(ellipse at center, #B3E5FC 0%, #4FC3F7 50%, #0288D1 100%) !important;
    border-radius: 25px !important;
    overflow: hidden !important;
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25) !important;
    z-index: 999999 !important;
}

#game-canvas-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 25px;
    background: linear-gradient(to bottom, #B3E5FC 0%, #4FC3F7 40%, #0288D1 100%);
}


#game-canvas {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
    border-radius: 25px;
}

#game-canvas:active {
    cursor: grabbing;
}

.dice-result-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.98), rgba(255, 193, 7, 0.95));
    border-radius: 20px;
    width: 180px;
    min-height: 140px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 50px rgba(255, 215, 0, 0.9), 0 15px 40px rgba(0, 0, 0, 0.4);
    z-index: 999999;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 3px solid rgba(255, 255, 255, 0.8);
}

.dice-result-display.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.dice-result-part {
    font-size: 1rem;
    color: #5d4037;
    margin-bottom: 4px;
    font-weight: 600;
}

.dice-result-total {
    font-size: 1.1rem;
    font-weight: bold;
    color: #bf360c;
    margin-top: 6px;
}

.dice-result-number {
    font-size: 3rem;
    font-weight: 900;
    color: #1a237e;
    text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.3);
    line-height: 1;
    margin-left: 5px;
}

.dice-result-text {
    font-size: 1rem;
    color: #3f51b5;
    font-weight: 700;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
    margin-top: 4px;
}

.status-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(26, 35, 47, 0.96);
    color: white;
    padding: 22px 40px;
    border-radius: 15px;
    font-size: 1.3rem;
    font-weight: 700;
    z-index: 1000;
    backdrop-filter: blur(12px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
    animation: statusMessageAnim 3s ease-in-out forwards;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
    text-align: center;
    max-width: 80%;
}

.status-message.status-error {
    background: linear-gradient(135deg, rgba(200, 50, 50, 0.96) 0%, rgba(180, 30, 30, 0.94) 100%);
}

.status-message.status-success {
    background: linear-gradient(135deg, rgba(50, 180, 50, 0.96) 0%, rgba(30, 160, 30, 0.94) 100%);
}

.status-message.status-info {
    background: linear-gradient(135deg, rgba(50, 150, 200, 0.96) 0%, rgba(30, 120, 180, 0.94) 100%);
}

.status-message.status-special {
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.96) 0%, rgba(75, 0, 130, 0.94) 100%);
}

@keyframes statusMessageAnim {
    0% { opacity: 0; transform: translate(-50%, -65%) scale(0.9); }
    12% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
    18% { transform: translate(-50%, -50%) scale(1); }
    82% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -35%) scale(0.9); }
}

/* PROFILBILD FACE-OVERLAY SYSTEM */
.face-overlay-container {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 2147483646 !important;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
}

.face-overlay-container.show {
    opacity: 1 !important;
    pointer-events: auto !important;
}

.face-overlay-background {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0, 0, 0, 0.7) !important;
    backdrop-filter: blur(5px) !important;
    z-index: 2147483645 !important;
}

.face-overlay-title {
    position: absolute !important;
    top: 10% !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    color: white !important;
    font-size: 2.5rem !important;
    font-weight: 900 !important;
    text-shadow: 0 4px 15px rgba(0, 0, 0, 0.7) !important;
    text-align: center !important;
    z-index: 2147483647 !important;
    animation: fadeInDown 0.8s ease-out;
}

@keyframes fadeInDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-30px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

.face-grid {
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    display: grid !important;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)) !important;
    gap: 2rem !important;
    max-width: 90% !important;
    max-height: 60% !important;
    z-index: 2147483647 !important;
}

.face-card {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 20px;
    padding: 1.5rem;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    border: 3px solid rgba(255, 255, 255, 0.8);
    animation: faceCardAppear 0.8s ease-out;
    animation-fill-mode: both;
    transform: scale(0);
}

.face-card:nth-child(1) { animation-delay: 0.1s; }
.face-card:nth-child(2) { animation-delay: 0.2s; }
.face-card:nth-child(3) { animation-delay: 0.3s; }
.face-card:nth-child(4) { animation-delay: 0.4s; }
.face-card:nth-child(5) { animation-delay: 0.5s; }
.face-card:nth-child(6) { animation-delay: 0.6s; }

@keyframes faceCardAppear {
    0% {
        opacity: 0;
        transform: scale(0) rotate(-10deg);
    }
    70% {
        transform: scale(1.1) rotate(2deg);
    }
    100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
    }
}

.face-image {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border: 4px solid #ffffff;
    margin: 0 auto 1rem auto;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
    transition: transform 0.3s ease;
    background-color: #f0f0f0;
}

.face-image:hover {
    transform: scale(1.1);
}

.face-player-name {
    font-size: 1.2rem;
    font-weight: 700;
    color: #333;
    margin-bottom: 0.5rem;
}

.face-team-info {
    font-size: 0.9rem;
    color: #666;
    font-weight: 600;
    padding: 0.3rem 0.8rem;
    border-radius: 15px;
    display: inline-block;
}

.face-overlay-timer {
    position: absolute !important;
    bottom: 15% !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    background: rgba(255, 255, 255, 0.9) !important;
    color: #333 !important;
    padding: 1rem 2rem !important;
    border-radius: 30px !important;
    font-size: 1.5rem !important;
    font-weight: 700 !important;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3) !important;
    z-index: 2147483647 !important;
    animation: pulseTimer 1s ease-in-out infinite alternate;
}

@keyframes pulseTimer {
    from {
        transform: translateX(-50%) scale(1);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    to {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
    }
}

/* Spezial-Feld-Effekte */
.special-field-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.98), rgba(75, 0, 130, 0.95));
    border-radius: 25px;
    width: 320px;
    min-height: 180px;
    padding: 25px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 60px rgba(138, 43, 226, 0.9), 0 20px 50px rgba(0, 0, 0, 0.4);
    z-index: 250;
    opacity: 0;
    transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 4px solid rgba(255, 255, 255, 0.9);
    color: white;
    text-align: center;
}

.special-field-display.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.special-field-icon {
    font-size: 4rem;
    margin-bottom: 15px;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
}

.special-field-title {
    font-size: 1.5rem;
    font-weight: 900;
    margin-bottom: 10px;
    text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);
}

.special-field-description {
    font-size: 1.1rem;
    font-weight: 600;
    line-height: 1.4;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
}

/* Vollbild-Styles */
#game-canvas-container:fullscreen,
#game-canvas-container:-webkit-full-screen,
#game-canvas-container:-moz-full-screen {
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
    background: linear-gradient(to bottom, #B3E5FC 0%, #4FC3F7 40%, #0288D1 100%) !important;
}

#game-canvas-container:fullscreen #game-canvas,
#game-canvas-container:-webkit-full-screen #game-canvas,
#game-canvas-container:-moz-full-screen #game-canvas {
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
}

/* Face-Overlay im Vollbild-Modus */
#game-canvas-container:fullscreen .face-overlay-container,
#game-canvas-container:-webkit-full-screen .face-overlay-container,
#game-canvas-container:-moz-full-screen .face-overlay-container {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 2147483647 !important;
}

@media (max-width: 768px) {
    body {
        padding: 10px;
    }
    
    .game-container {
        width: 95vw;
        height: 70vh;
        max-width: 600px;
        max-height: 450px;
        border-radius: 20px;
    }
    
    #game-canvas-container {
        border-radius: 20px;
    }
    
    #game-canvas {
        border-radius: 20px;
    }
    
    .dice-result-display {
        width: 140px;
        min-height: 110px;
        padding: 12px;
    }
    
    .dice-result-number {
        font-size: 2.2rem;
    }
    
    .special-field-display {
        width: 280px;
        min-height: 160px;
        padding: 20px;
    }
}

/* Question Banner Styles - Echter Team Dashboard Style */
.announcement-banner {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(8px);
}

.announcement-banner.show {
    display: flex;
    animation: bannerFadeIn 0.5s ease-out;
}

.announcement-banner.hide {
    animation: bannerFadeOut 0.5s ease-out forwards;
}

@keyframes bannerFadeIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes bannerFadeOut {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0; transform: scale(0.9); }
}

.banner-content {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 20px;
    padding: 6rem;
    text-align: center;
    color: white;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    max-width: 1000px;
    margin: 0 20px;
    position: relative;
    overflow: hidden;
}

.banner-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
    pointer-events: none;
}

.question-banner .banner-content {
    background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
}

.results-banner .banner-content {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
}

/* NEU: Field Minigame Banner Style */
#field-minigame-banner .banner-content {
    background: linear-gradient(135deg, #BA68C8 0%, #8E24AA 100%);
    border: 3px solid rgba(255, 255, 255, 0.3);
}

#field-minigame-banner .banner-icon {
    font-size: 8rem;
    margin-bottom: 2rem;
    opacity: 1;
    animation: fieldMinigamePulse 2s ease-in-out infinite;
}

@keyframes fieldMinigamePulse {
    0%, 100% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.05) rotate(-2deg); }
    50% { transform: scale(1.1) rotate(0deg); }
    75% { transform: scale(1.05) rotate(2deg); }
}

.banner-results {
    margin-top: 2rem;
    font-size: 2.4rem;
    line-height: 1.6;
}

.result-item {
    margin: 1rem 0;
    padding: 1.6rem 2rem;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 15px;
    border-left: 4px solid rgba(255, 255, 255, 0.4);
    font-size: 2.2rem;
    font-weight: 600;
}

.banner-icon {
    font-size: 8rem;
    margin-bottom: 2rem;
    opacity: 0.9;
    animation: bannerIconPulse 2s ease-in-out infinite;
}

@keyframes bannerIconPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.banner-title {
    font-size: 5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    position: relative;
    z-index: 1;
}

.banner-subtitle {
    font-size: 2.4rem;
    opacity: 0.9;
    margin-bottom: 2rem;
    position: relative;
    z-index: 1;
}

.banner-description {
    font-size: 2.2rem;
    opacity: 0.95;
    position: relative;
    z-index: 1;
    line-height: 1.4;
}

/* Responsive */
@media (max-width: 767.98px) {
    .banner-content {
        padding: 3rem;
        margin: 0 10px;
        max-width: calc(100vw - 20px);
    }
    
    .banner-title {
        font-size: 3.6rem;
    }
    
    .banner-subtitle {
        font-size: 2rem;
    }
    
    .banner-icon {
        font-size: 5rem;
    }
    
    .banner-description {
        font-size: 1.9rem;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="game-container">
    <div id="game-canvas-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- Question Banner - Echter Team Dashboard Style -->
        <div id="question-banner" class="announcement-banner question-banner">
            <div class="banner-content">
                <div class="banner-icon">
                    <i class="fas fa-question-circle"></i>
                </div>
                <div class="banner-text">
                    <div class="banner-title" id="banner-question-title">Aktuelle Frage</div>
                    <div class="banner-subtitle" id="banner-question-timer">Läuft...</div>
                    <div class="banner-description" id="banner-question-content">
                        <!-- Wird dynamisch gefüllt -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Minigame Announcement Banner - Team Dashboard Style -->
        <div id="minigame-announcement-banner" class="announcement-banner">
            <div class="banner-content">
                <div class="banner-icon">
                    <i class="fas fa-gamepad"></i>
                </div>
                <div class="banner-text">
                    <div class="banner-title">Neues Minispiel!</div>
                    <div class="banner-subtitle" id="minigame-banner-name"></div>
                    <div class="banner-description" id="minigame-banner-description"></div>
                </div>
            </div>
        </div>

        <!-- Minigame Results Banner - Team Dashboard Style -->
        <div id="minigame-results-banner" class="announcement-banner results-banner">
            <div class="banner-content">
                <div class="banner-icon">
                    <i class="fas fa-trophy"></i>
                </div>
                <div class="banner-text">
                    <div class="banner-title">Ergebnisse!</div>
                    <div class="banner-subtitle">Platzierungen wurden eingetragen</div>
                    <div class="banner-results" id="minigame-results-list"></div>
                </div>
            </div>
        </div>

        <!-- NEU: Field Minigame Announcement Banner -->
        <div id="field-minigame-banner" class="announcement-banner">
            <div class="banner-content">
                <div class="banner-icon">
                    <i class="fas fa-chess-board"></i>
                </div>
                <div class="banner-text">
                    <div class="banner-title">🎮 Minigame-Feld!</div>
                    <div class="banner-subtitle" id="field-minigame-banner-teams">Team vs Team</div>
                    <div class="banner-description" id="field-minigame-banner-description">
                        Ein Minispiel wurde gestartet! Der Gewinner bekommt 5 Felder Vorsprung.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Face-Overlay System INNERHALB game-canvas-container für Vollbild-Sichtbarkeit -->
        <div id="face-overlay-container" class="face-overlay-container">
            <div class="face-overlay-background"></div>
            <div class="face-grid" id="face-grid">
                <!-- Gesichter werden hier dynamisch eingefügt -->
            </div>
        </div>
        
        <!-- Würfelergebnis-Anzeige nur temporär beim Würfeln -->
        <div id="dice-result-display" class="dice-result-display" style="display: none;">
            <div id="dice-result-standard" class="dice-result-part">Standard: <span>-</span></div>
            <div id="dice-result-bonus" class="dice-result-part" style="display: none;">Bonus: <span>-</span></div>
            <div class="dice-result-total">Gesamt: <span class="dice-result-number">0</span></div>
            <div class="dice-result-text">Felder</div>
        </div>
        
        <!-- Sonderfeld-Anzeige -->
        <div id="special-field-display" class="special-field-display" style="display: none;">
            <div id="special-field-icon" class="special-field-icon">🎯</div>
            <div id="special-field-title" class="special-field-title">Sonderfeld!</div>
            <div id="special-field-description" class="special-field-description">Etwas Besonderes ist passiert!</div>
        </div>
        
    </div>
</div>


{% endblock %}

{% block scripts %}
{{ super() }}
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

<!-- Italian brainrot character scripts moved to backup folder -->
<!-- tungTungTungSahur.js, ballerinaCappuccina.js, bombardinoCrocodilo.js, liriliLarila.js, tralaleroTralala.js, trippiTroppi.js -->
<script src="{{ url_for('static', filename='js/characters/defaultCharacter.js') }}"></script>
<script src="{{ url_for('static', filename='js/notifications.js') }}"></script>

<script>
// DYNAMISCHE SPIELBRETT-KONFIGURATION
let BOARD_CONFIG = {
    fieldTypes: {
        // Standard-Fallback-Farben - werden dynamisch überschrieben
        start: { color: 0x00BFFF, emission: 0x0066CC, name: 'Start' },
        normal: { color: 0x00FF00, emission: 0x00CC00, name: 'Normales Feld' },
        minigame: { color: 0x8A2BE2, emission: 0x6A1B9A, name: 'Minispiel' },
        goal: { color: 0xFF6600, emission: 0xCC4400, name: 'Ziel' },
        catapult_forward: { color: 0x32CD32, emission: 0x228B22, name: 'Katapult Vorwärts' },
        catapult_backward: { color: 0xFF0000, emission: 0xCC0000, name: 'Katapult Rückwärts' },
        player_swap: { color: 0x0080FF, emission: 0x0066CC, name: 'Spieler-Tausch' },
        barrier: { color: 0x666666, emission: 0x333333, name: 'Sperre' },
        safe_zone: { color: 0x90EE90, emission: 0x7FDD7F, name: 'Sichere Zone' }
    },
    fieldSize: 1.0,
    fieldHeight: 0.25,
    fieldRadius: 0.55,
    pathWidth: 2.8,
    pathSegmentBaseDepth: 0.25,
    pathColor: 0xD7CCC8,
    pathBorderColor: 0xBCAAA4,
    characterElevation: 0.4,
    characterSize: 1.0,
    mountainHeight: 24,
    mountainBaseRadius: 20,
    mountainTopRadius: 0.01,
    spiralHeight: 22,
    spiralStartRadius: 28, // Vergrößert für besseren Start
    spiralLoops: 3.8, // Mehr Loops für bessere Verteilung
    pathDepth: 5.0,
    // GTA5-style camera settings
    gtaCameraDistance: 8.0,                   // Abstand hinter dem Spieler
    gtaCameraHeight: 4.0,                     // Höhe über dem Spieler
    gtaCameraSmoothing: 0.15,                 // Smooth aber responsive
    gtaCameraLookSmoothing: 0.2,              // Blickrichtung smoothing
    // Legacy compatibility
    cameraFrontOffset: new THREE.Vector3(0, 15, -8),
    cameraOrbitSpeed: 0.006,
    cameraOrbitHeight: 55,
    cameraOrbitRadius: 55,
    cameraObstacleAvoidanceDistance: 4.0,     // Größerer Abstand zu Hindernissen
    cameraHeightAdjustment: 3.5,              // Höhere Anpassung
    // Auto camera management
    cameraAutoOrbitDelay: 3000,               // 3s warten bevor Auto-Orbit startet
    cameraPlayerFocusDistance: 18,            // Größere Distanz für bessere Sicht
    cameraPlayerFocusHeight: 20,              // Hohe Vogelperspektive
    cameraTransitionDuration: 1500,           // Smooth Transition Dauer
    // Ultra smooth settings
    cameraMaxSmoothingFactor: 0.25,           // Maximum smoothing bei schneller Bewegung
    cameraMinSmoothingFactor: 0.08,           // Minimum smoothing bei langsamer Bewegung
    cameraPredictiveDistance: 5.0,            // Vorhersage-Distanz für Bewegung
    cameraMinHeight: 8.0,                     // Minimum Höhe über Terrain
    cameraMaxObstacleCheckDistance: 50.0      // Maximum Raycast-Distanz
};

const islandSurfaceY = 1.6;

// DYNAMISCHE FELD-VERTEILUNG
let DYNAMIC_FIELD_DISTRIBUTION = null; // Wird vom Server geladen
let FIELD_DISTRIBUTION_LOADING = false;

let hasShowMinigameResults = false;
let hasShownTurnDiceSequence = false;
let lastDiceResult = null; // Track last dice result to prevent loops
let turnSequenceState = { isMoving: false }; // Track turn sequence state to prevent conflicts

// FELDTYP-HILFSFUNKTIONEN
function getFieldTypeAtPosition(position) {
    // Verwende die dynamische Feld-Verteilung wenn verfügbar
    if (DYNAMIC_FIELD_DISTRIBUTION && DYNAMIC_FIELD_DISTRIBUTION[position]) {
        return DYNAMIC_FIELD_DISTRIBUTION[position];
    }
    
    // Fallback auf die alte statische Logik falls noch nicht geladen
    if (position === 0) return 'start';
    else if (position === 72) return 'goal';
    else if (position === 71) return 'safe_zone'; // Letztes reguläres Feld vor Ziel
    else if (position % 15 === 0) return 'catapult_forward';
    else if (position % 13 === 0) return 'catapult_backward';
    else if (position % 17 === 0) return 'player_swap';
    else if (position % 19 === 0) return 'barrier';
    else if (position % 8 === 0) return 'bonus';
    else if (position % 12 === 0) return 'minigame';
    else if (position % 20 === 0) return 'chance';
    else if (position % 25 === 0) return 'trap';
    else return 'normal';
}

// DYNAMISCHES LADEN DER FELD-KONFIGURATIONEN
async function loadFieldConfigurations() {
    if (FIELD_DISTRIBUTION_LOADING) return;
    FIELD_DISTRIBUTION_LOADING = true;
    
    try {
        console.log('Lade Feld-Konfigurationen vom Server...');
        
        // Lade Feld-Farben und Konfigurationen
        const colorsResponse = await fetch("{{ url_for('admin.api_field_colors') }}", {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!colorsResponse.ok) {
            throw new Error(`Fehler beim Laden der Feld-Farben: ${colorsResponse.status}`);
        }
        
        const colorsData = await colorsResponse.json();
        
        if (colorsData.success && colorsData.color_mapping) {
            // Aktualisiere BOARD_CONFIG mit den Farben vom Server
            Object.keys(colorsData.color_mapping).forEach(fieldType => {
                const config = colorsData.color_mapping[fieldType];
                if (config.enabled) { // Nur aktivierte Feldtypen verwenden
                    BOARD_CONFIG.fieldTypes[fieldType] = {
                        color: parseInt(config.color.replace('#', '0x')),
                        emission: parseInt(config.emission.replace('#', '0x')),
                        name: config.display_name,
                        icon: config.icon
                    };
                }
            });
            
            console.log('✅ Feld-Farben erfolgreich geladen:', Object.keys(colorsData.color_mapping).length, 'Feldtypen');
        }
        
        // Lade dynamische Feld-Verteilung
        const previewResponse = await fetch("{{ url_for('admin.api_field_data') }}?max_fields=73", {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (previewResponse.ok) {
            const previewData = await previewResponse.json();
            
            if (previewData.success && previewData.preview_data && previewData.preview_data.fields) {
                // Erstelle Feld-Verteilungs-Map
                DYNAMIC_FIELD_DISTRIBUTION = {};
                previewData.preview_data.fields.forEach(field => {
                    if (field.enabled) { // Nur aktivierte Felder verwenden
                        DYNAMIC_FIELD_DISTRIBUTION[field.position] = field.field_type;
                    } else {
                        // Deaktivierte Sonderfelder werden zu normalen Feldern
                        DYNAMIC_FIELD_DISTRIBUTION[field.position] = 'normal';
                    }
                });
                
                console.log('✅ Dynamische Feld-Verteilung geladen:', Object.keys(DYNAMIC_FIELD_DISTRIBUTION).length, 'Positionen');
                console.log('📊 Feld-Statistiken:', previewData.field_stats);
                
                // WICHTIG: Aktualisiere das Spielbrett falls es bereits existiert
                if (window.gameBoard && window.gameBoard.updateBoardFields) {
                    window.gameBoard.updateBoardFields();
                }
            }
        }
        
    } catch (error) {
        console.error('❌ Fehler beim Laden der Feld-Konfigurationen:', error);
        console.log('🔄 Verwende Fallback-Konfiguration');
        // DYNAMIC_FIELD_DISTRIBUTION bleibt null, fallback auf statische Logik
    } finally {
        FIELD_DISTRIBUTION_LOADING = false;
    }
}

// NEU: Funktion zum Neuladen der Konfigurationen
async function reloadFieldConfigurations() {
    DYNAMIC_FIELD_DISTRIBUTION = null;
    FIELD_DISTRIBUTION_LOADING = false;
    await loadFieldConfigurations();
    console.log('🔄 Feld-Konfigurationen neu geladen');
}

function showSpecialFieldEffect(actionType, title, description, duration = 8000) {
    const display = document.getElementById('special-field-display');
    const icon = document.getElementById('special-field-icon');
    const titleEl = document.getElementById('special-field-title');
    const descEl = document.getElementById('special-field-description');
    
    if (!display || !icon || !titleEl || !descEl) return;
    
    // Setze Icon basierend auf Aktion (verwende das Icon aus der Konfiguration wenn verfügbar)
    const iconMap = {
        'catapult_forward': BOARD_CONFIG.fieldTypes.catapult_forward?.icon || '🚀',
        'catapult_backward': BOARD_CONFIG.fieldTypes.catapult_backward?.icon || '💥',
        'player_swap': BOARD_CONFIG.fieldTypes.player_swap?.icon || '🔄',
        'barrier_set': BOARD_CONFIG.fieldTypes.barrier?.icon || '🚧',
        'barrier_released': '🎉'
    };
    
    icon.textContent = iconMap[actionType] || '⭐';
    titleEl.textContent = title;
    descEl.textContent = description;
    
    display.style.display = 'flex';
    display.classList.add('show');
    
    setTimeout(() => {
        display.classList.remove('show');
        setTimeout(() => {
            display.style.display = 'none';
        }, 500);
    }, duration);
}

// Spielzustand
const GAME_STATE = {
    currentTeamIndex: 0,
    isAnimating: false,
    isDiceRolling: false,
    isCharacterMoving: false,
    diceResult: 0,
    freeCameraMode: false,
    isFullscreen: false,
    cameraHeight: 18,
    cameraDistance: 25,
    isAnimatingCamera: false,
    characterTurnSpeed: 0.08,
    playerTurnInProgress: false,
    cameraMode: 'front',
    currentServerTeamTurnId: null,
    diceRollOrderFromServer: [],
    
    // Kamera-Management um Konflikte zu vermeiden
    cameraTransitionActive: false,
    lastCameraAction: null,
    cameraActionTimestamp: 0,
    cinematicMode: false,
    cinematicTimer: null,
    // Auto Camera Management
    autoCameraEnabled: true,           // Auto-Kamera aktiviert
    cameraFocusMode: 'auto',          // 'auto', 'focus', 'orbit'
    isPlayerActive: false,            // Ist gerade ein Spieler aktiv?
    autoOrbitActive: false,           // Läuft gerade Auto-Orbit?
    lastPlayerActivity: Date.now(),   // Letzter Zeitpunkt mit Spieler-Aktivität
    playerFocusTarget: null,          // Aktueller Spieler im Fokus
    cameraTransitioning: false       // Kamera wechselt gerade Modi
};

// Team-Daten
let localTeams = [
    {% for team in teams %}
    {
        id: {{ team.id|tojson }},
        name: "{{ team.name | e }}",
        position: {{ team.current_position|tojson if team.current_position is not none else 0 }},
        color: "{{ team_colors[loop.index0 % team_colors|length] }}",
        character_info: {% if team.character and team.character.name and team.character.js_file %}
        {
            name: "{{ team.character.name | e }}",
            js_file: "{{ team.character.js_file | e }}",
            image_file: "{{ team.character.image_file | default('') | e }}",
            customization: {{ team.get_character_customization() | tojson }}
        }
        {% else %}
        {
            name: "Default",
            js_file: "js/characters/defaultCharacter.js",
            image_file: "default.png",
            customization: {{ team.get_character_customization() | tojson }}
        }
        {% endif %},
        bonus_dice_sides: {{ team.bonus_dice_sides|tojson if team.bonus_dice_sides is not none else 0 }},
        minigame_placement: {{ team.minigame_placement|tojson if team.minigame_placement is not none else 'null' }},
        is_blocked: {{ team.is_blocked|tojson if team.is_blocked is defined else 'false' }},
        blocked_target_number: {{ team.blocked_target_number|tojson if team.blocked_target_number is not none else 'null' }}
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];

// Minispiel-Daten
let currentMinigameName = "{{ active_session.current_minigame_name | e if active_session else '' }}";
let currentMinigameDescription = "{{ active_session.current_minigame_description | e if active_session else '' }}";
let currentGamePhase = "{{ active_session.current_phase | e if active_session else 'UNKNOWN' }}";

let lastTeamTurnId = {% if active_session and active_session.current_team_turn_id is not none %}{{ active_session.current_team_turn_id|tojson }}{% else %}null{% endif %};
let lastPhase = "";
let gameStarted = false;


// Minigame folder name for category display
const minigameFolderName = "{{ minigame_folder_name | e }}";

const isAdmin = {{ is_admin|tojson }};

class WiiPartyIsland {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true
        });
        
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        
        this.updateCanvasSize();
        
        // Start camera behind first player's starting position for smooth follow
        const startingFieldPos = new THREE.Vector3(18, 2, 18); // Starting field position
        const behindOffset = new THREE.Vector3(-3, 10, -3); // Behind and high elevated
        this.camera.position.copy(startingFieldPos.clone().add(behindOffset));
        this.camera.lookAt(startingFieldPos.x, startingFieldPos.y, startingFieldPos.z);
        
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.1;
        this.controls.screenSpacePanning = false;
        this.controls.minDistance = 5;
        this.controls.maxDistance = 60;
        // Polar angle restriction removed for free camera
        this.controls.target.set(0, 6, 0);
        this.controls.enabled = false;
        this.controls.enablePan = true;
        this.controls.enableZoom = true;
        this.controls.enableRotate = true;
        
        // Trackpad-Zoom-Gesten für Notebooks hinzufügen
        this.setupTrackpadZoom();
        
        this.pathPoints = [];
        this.boardFields = [];
        this.miiCharacters = {};
        this.activeCharacterPath = null;
        this.raycaster = new THREE.Raycaster();
        
        this.interactiveDice = null;
        this.diceResultNumber = null;
        this.island = null;
        this.mountainMesh = null;
        this.water = null;
        this.clouds = [];
        
        this.characterCreationFunctions = {};
        this.activeMovementAnimation = null;

        this.init();
    }

    async init() {
        // Lade zuerst die Feld-Konfigurationen
        await loadFieldConfigurations();
        
        this.setupLighting();
        this.createOcean();
        this.createIslandAndMountain();
        this.createSpiralPath();
        this.createSimpleVegetation();
        this.createAnimatedAnimals();
        
        if (localTeams && localTeams.length > 0) {
            await this.createMiiCharacters();
        }
        
        this.createSimpleEnvironmentalDetails();
        this.createInteractiveDice();
        
        this.setupEventListeners();
        this.initAutomaticCameraManagement();
        this.animate();
        
        this.updateMinigameDisplay();
        this.updateTeamDisplay();
        this.fetchBoardStatusAndUpdate();
        // Weniger häufiges Polling um Ruckeln zu reduzieren
        setInterval(() => this.fetchBoardStatusAndUpdate(), 3000);
        
        this.prepareNextPlayerTurn(true);
    }

    setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
        this.scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.4);
        sunLight.position.set(40, 50, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 150;
        sunLight.shadow.camera.left = -40;
        sunLight.shadow.camera.right = 40;
        sunLight.shadow.camera.top = 40;
        sunLight.shadow.camera.bottom = -40;
        this.scene.add(sunLight);
        
        this.scene.background = new THREE.Color(0x87CEEB);
        this.scene.fog = new THREE.Fog(0xb3d9ff, 60, 150);
        
        // Schönere Himmel-Atmosphäre
        this.createSkyAtmosphere();
    }
    
    createSkyAtmosphere() {
        // Sanft verlaufender Himmel
        const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vWorldPosition;
                void main() {
                    vec3 direction = normalize(vWorldPosition);
                    float elevation = direction.y;
                    
                    // Himmelfarben basierend auf Höhe
                    vec3 topColor = vec3(0.53, 0.8, 0.98);     // Hellblau
                    vec3 horizonColor = vec3(0.85, 0.95, 1.0); // Weißlich
                    vec3 bottomColor = vec3(0.7, 0.9, 1.0);    // Pastellblau
                    
                    // Sanfte Übergänge
                    vec3 skyColor;
                    if (elevation > 0.0) {
                        skyColor = mix(horizonColor, topColor, elevation);
                    } else {
                        skyColor = mix(horizonColor, bottomColor, -elevation * 2.0);
                    }
                    
                    // Subtile Wolken-Textur
                    float clouds = sin(direction.x * 3.0 + time * 0.1) * sin(direction.z * 3.0 + time * 0.07) * 0.1;
                    skyColor += clouds * vec3(0.1, 0.1, 0.1);
                    
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `,
            side: THREE.BackSide
        });
        
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        sky.userData.animation = (time) => {
            skyMaterial.uniforms.time.value = time;
        };
        this.scene.add(sky);
        this.skyMesh = sky;
    }

    createOcean() {
        const oceanRadius = 100; // Vergrößert für breitere Insel
        const waterGeometry = new THREE.PlaneGeometry(oceanRadius * 2, oceanRadius * 2, 64, 64);
        const positions = waterGeometry.attributes.position.array;
        
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const z = positions[i + 2];
            const distance = Math.sqrt(x * x + z * z);
            
            if (distance > 35) { // Angepasst für größere Insel
                positions[i + 1] = Math.sin(x * 0.08) * 0.2 + Math.sin(z * 0.1) * 0.2;
            } else {
                positions[i + 1] = Math.sin(x * 0.15) * 0.08 + Math.sin(z * 0.15) * 0.08;
            }
        }
        waterGeometry.attributes.position.needsUpdate = true;
        waterGeometry.computeVertexNormals();

        const waterMaterial = new THREE.MeshPhongMaterial({
            color: 0x4DD0E1,
            specular: 0xB0BEC5,
            shininess: 60,
            transparent: true,
            opacity: 0.85
        });
        
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -0.3;
        water.receiveShadow = true;
        this.scene.add(water);
        
        water.userData = {
            animation: time => {
                const positions = water.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i+2];
                    const distance = Math.sqrt(x * x + z * z);
                    
                    if (distance > 35) { // Angepasst für größere Insel
                        positions[i + 1] = Math.sin(x * 0.08 + time * 0.6) * 0.2 + 
                                         Math.sin(z * 0.1 + time * 0.4) * 0.2;
                    } else {
                        positions[i + 1] = Math.sin(x * 0.15 + time * 0.3) * 0.08 + 
                                         Math.sin(z * 0.15 + time * 0.5) * 0.08;
                    }
                }
                water.geometry.attributes.position.needsUpdate = true;
                water.geometry.computeVertexNormals();
            }
        };
        this.water = water;
    }

    createIslandAndMountain() {
        // VERBESSERTE INSEL-GEOMETRIE: Rundere, breitere Form
        const islandGeometry = new THREE.CylinderGeometry(
            30, // Top radius - größer für breitere Insel
            35, // Bottom radius - noch größer für natürliche Form
            3.2, // Height
            48, // Radial segments - mehr für rundere Form
            3,  // Height segments - mehr für bessere Geometrie
            false
        );
        
        const islandPositions = islandGeometry.attributes.position.array;
        
        // Natürlichere Strand-Erosion
        for (let i = 0; i < islandPositions.length; i += 3) {
            const x = islandPositions[i];
            const z = islandPositions[i + 2];
            const distance = Math.sqrt(x * x + z * z);
            
            // Sanftere Übergänge
            if (distance > 25) {
                const erosion = Math.min(1, (distance - 25) / 10);
                const waveHeight = Math.sin(distance * 0.3) * 0.3 + Math.cos(distance * 0.2) * 0.2;
                islandPositions[i + 1] += waveHeight * (1 - erosion * 0.5);
            }
        }
        
        islandGeometry.attributes.position.needsUpdate = true;
        islandGeometry.computeVertexNormals();
        
        const islandMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x8FBC8F, 
            shininess: 4 
        });
        
        this.island = new THREE.Mesh(islandGeometry, islandMaterial);
        this.island.position.y = 0;
        this.island.receiveShadow = true;
        this.island.castShadow = true;
        this.scene.add(this.island);
        
        this.createIslandVegetation();
        this.createMountainWithPath();
    }

    createIslandVegetation() {
        const baseIslandTopY = islandSurfaceY;
        
        // Mehrschichtige Vegetation für natürlicheres Aussehen
        const vegLayers = [
            { radius: 28, color: 0x228B22, height: 0.15 }, // Dark Green base
            { radius: 26, color: 0x32CD32, height: 0.12 }, // Lime Green middle
            { radius: 24, color: 0x90EE90, height: 0.08 }  // Light Green top
        ];
        
        vegLayers.forEach((layer, index) => {
            const vegGeometry = new THREE.CylinderGeometry(layer.radius, layer.radius + 2, layer.height, 32);
            const vegMaterial = new THREE.MeshLambertMaterial({ color: layer.color });
            const vegetation = new THREE.Mesh(vegGeometry, vegMaterial);
            vegetation.position.y = baseIslandTopY + 0.03 + (index * 0.04);
            vegetation.receiveShadow = true;
            vegetation.castShadow = true;
            this.scene.add(vegetation);
        });
    }

    createMountainWithPath() {
        this.calculatePathPoints();

        const detail = 140; // Mehr Detail für bessere Qualität
        const mountainGeometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const uvs = [];
        const flatTopRadius = BOARD_CONFIG.mountainTopRadius * 0.9;
        const mountainFootY = islandSurfaceY;

        for (let i = 0; i <= detail; i++) {
            for (let j = 0; j <= detail; j++) {
                const x = (i / detail - 0.5) * BOARD_CONFIG.mountainBaseRadius * 2;
                const z = (j / detail - 0.5) * BOARD_CONFIG.mountainBaseRadius * 2;
                const distance = Math.sqrt(x * x + z * z);
                let y_shape = 0;

                if (distance <= BOARD_CONFIG.mountainBaseRadius) {
                    if (distance <= flatTopRadius) {
                        y_shape = BOARD_CONFIG.mountainHeight;
                    } else {
                        const progress = (distance - flatTopRadius) / (BOARD_CONFIG.mountainBaseRadius - flatTopRadius);
                        const smoothProgress = 1 - (progress * progress * (3 - 2 * progress));
                        y_shape = BOARD_CONFIG.mountainHeight * smoothProgress;
                        y_shape += (Math.sin(x * 0.8) * Math.cos(z * 0.8)) * 0.15 * (1 - smoothProgress);
                    }
                    
                    // VERBESSERTE PFAD-INTEGRATION
                    const pathInfluence = this.getPathInfluence(x, z);
                    if (pathInfluence > 0) {
                        const pathHeightAbsolute = this.getInterpolatedPathHeight(x, z);
                        const pathHeightRelativeToMountainFoot = pathHeightAbsolute - mountainFootY;
                        const pathDepth = BOARD_CONFIG.pathDepth * pathInfluence * 0.3; // Sanftere Integration
                        y_shape = Math.max(y_shape - pathDepth, pathHeightRelativeToMountainFoot - pathDepth * 0.1);
                    }
                } else if (distance <= BOARD_CONFIG.mountainBaseRadius * 1.15) { // Sanfterer Übergang
                    const fadeOut = 1 - ((distance - BOARD_CONFIG.mountainBaseRadius) / (BOARD_CONFIG.mountainBaseRadius * 0.15));
                    y_shape = fadeOut * 0.05 - 0.03;
                } else {
                    y_shape = -0.03;
                }
                
                vertices.push(x, mountainFootY + y_shape, z);
                uvs.push(i / detail, j / detail);
            }
        }
        
        for (let i = 0; i < detail; i++) {
            for (let j = 0; j < detail; j++) {
                const a = i * (detail + 1) + j;
                const b = a + 1;
                const c = a + detail + 1;
                const d = c + 1;
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
        }
        
        mountainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        mountainGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        mountainGeometry.setIndex(indices);
        mountainGeometry.computeVertexNormals();

        const mountainMaterial = new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 6
        });
        
        const mountainColorAttr = new Float32Array(vertices.length);
        for (let k_color = 0; k_color < vertices.length; k_color += 3) {
            const yPos = vertices[k_color + 1];
            const height = Math.max(0, Math.min(1, (yPos - mountainFootY) / BOARD_CONFIG.mountainHeight));
            
            let r, g, b;
            
            if (height < 0.1) {
                r = 0.3; g = 0.45; b = 0.2;
            } else if (height < 0.6) {
                r = 0.25; g = 0.6; b = 0.15;
            } else if (height < 0.85) {
                r = 0.5; g = 0.5; b = 0.4;
            } else {
                r = 0.85; g = 0.85; b = 0.9;
            }
            
            mountainColorAttr[k_color] = r;
            mountainColorAttr[k_color+1] = g;
            mountainColorAttr[k_color+2] = b;
        }
        
        mountainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(mountainColorAttr, 3));
        const mountainMesh = new THREE.Mesh(mountainGeometry, mountainMaterial);
        mountainMesh.castShadow = true;
        mountainMesh.receiveShadow = true;
        this.scene.add(mountainMesh);
        this.mountainMesh = mountainMesh;
    }

    calculatePathPoints() {
        this.pathPoints = [];
        const fieldCount = 73;
        const mountainFootY = islandSurfaceY;

        // VERBESSERTE PFAD-BERECHNUNG
        const highResPoints = [];
        const samples = 1200; // Mehr Samples für präzisere Berechnung
        
        for (let i = 0; i < samples; i++) {
            const progress = i / (samples - 1);
            let radius;
            
            // KEINE RAMPE AM START - direkter Übergang
            if (progress < 0.05) {
                // Sanfter Start ohne Rampe
                radius = BOARD_CONFIG.spiralStartRadius * (1.0 - progress * 2);
            } else if (progress < 0.88) {
                // Hauptspiral-Bereich
                const localProgress = (progress - 0.05) / 0.83;
                const easedProgress = Math.pow(localProgress, 0.82); // Sanftere Kurve
                radius = THREE.MathUtils.lerp(
                    BOARD_CONFIG.mountainBaseRadius - 0.8, 
                    BOARD_CONFIG.mountainTopRadius * 2.0, // Größerer Endradius
                    easedProgress
                );
            } else {
                // Gipfel-Bereich - ausgewogene Platzierung
                const gipfelProgress = (progress - 0.88) / 0.12;
                radius = Math.max(2.5, BOARD_CONFIG.mountainTopRadius * 10.0 * (1.0 - gipfelProgress * 0.5));
            }
            
            // Sanftere Spirale
            const spiralProgress = Math.pow(progress, 1.15);
            const angle = spiralProgress * Math.PI * 2 * BOARD_CONFIG.spiralLoops;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const distanceToCenter = Math.sqrt(x * x + z * z);
            
            let y;
            let onFlatLand = false;
            
            // VERBESSERTE HÖHEN-BERECHNUNG
            if (distanceToCenter > BOARD_CONFIG.mountainBaseRadius - 1.0) {
                // Flaches Land - KEIN Y-Sprung am Start
                y = islandSurfaceY + 0.3; // Konstante Höhe
                onFlatLand = true;
            } else {
                // Berg-Bereich
                const mountainProgress = Math.max(0, Math.min(1, 
                    1 - (distanceToCenter / (BOARD_CONFIG.mountainBaseRadius - 1.0))
                ));
                const smoothProgress = Math.pow(mountainProgress, 0.75); // Sanftere Steigung
                y = mountainFootY + smoothProgress * BOARD_CONFIG.mountainHeight;
                
                // Weniger aggressive Höhen-Variation
                y += Math.sin(angle * 1.5) * 0.02 * (1 - smoothProgress);
                onFlatLand = false;
            }
            
            highResPoints.push({ x, y, z, progress, onFlatLand });
        }
        
        // Verbesserte Distanz-Berechnung mit Höhen-Berücksichtigung
        // Use same weighting as path dots for consistency
        const distances = [0];
        for (let i = 1; i < highResPoints.length; i++) {
            const prev = highResPoints[i - 1];
            const curr = highResPoints[i];
            const dist = Math.sqrt(
                Math.pow(curr.x - prev.x, 2) + 
                Math.pow(curr.y - prev.y, 2) * 0.3 + // Match path dots weighting
                Math.pow(curr.z - prev.z, 2)
            );
            distances.push(distances[distances.length - 1] + dist);
        }
        
        const totalLength = distances[distances.length - 1];
        const segmentLength = totalLength / (fieldCount - 1);
        
        // Präzise Feld-Platzierung mit verbesserter Interpolation
        for (let i = 0; i < fieldCount; i++) {
            if (i === 0) {
                // START: Direkt auf der Insel, KEINE Rampe
                this.pathPoints.push({
                    x: BOARD_CONFIG.spiralStartRadius,
                    y: islandSurfaceY + 0.3,
                    z: 0,
                    index: i,
                    onFlatLand: true
                });
            } else if (i === fieldCount - 1) {
                // ZIEL: Klar sichtbar auf dem Gipfel
                this.pathPoints.push({
                    x: 0,
                    y: mountainFootY + BOARD_CONFIG.mountainHeight + 0.5, // Höher positioniert
                    z: 0,
                    index: i,
                    onFlatLand: false
                });
            } else if (i >= fieldCount - 10) {
                // Letzte 10 Felder: Ordentlich um den Gipfel arrangieren
                const peakFieldIndex = i - (fieldCount - 10);
                const peakRadius = 3.5;
                const peakAngle = (peakFieldIndex / 9) * Math.PI * 2;
                
                this.pathPoints.push({
                    x: Math.cos(peakAngle) * peakRadius,
                    y: mountainFootY + BOARD_CONFIG.mountainHeight * 0.9,
                    z: Math.sin(peakAngle) * peakRadius,
                    index: i,
                    onFlatLand: false
                });
            } else {
                // Normale Felder: Gleichmäßig verteilt mit Interpolation
                const targetDistance = i * segmentLength;
                let segmentIndex = 0;
                
                // Find the right segment
                for (let j = 0; j < distances.length - 1; j++) {
                    if (targetDistance >= distances[j] && targetDistance <= distances[j + 1]) {
                        segmentIndex = j;
                        break;
                    }
                }
                
                // Interpolate within the segment
                const segmentStart = distances[segmentIndex];
                const segmentEnd = distances[segmentIndex + 1];
                const currentSegmentLength = segmentEnd - segmentStart;
                
                if (currentSegmentLength > 0) {
                    const t = (targetDistance - segmentStart) / currentSegmentLength;
                    const point1 = highResPoints[segmentIndex];
                    const point2 = highResPoints[segmentIndex + 1];
                    
                    const interpolatedPoint = {
                        x: point1.x + t * (point2.x - point1.x),
                        y: point1.y + t * (point2.y - point1.y),
                        z: point1.z + t * (point2.z - point1.z),
                        onFlatLand: point1.onFlatLand || point2.onFlatLand
                    };
                    
                    // Check minimum distance to previous fields
                    let validPosition = true;
                    const minDistance = 0.8; // Minimum distance between fields
                    
                    for (let k = 0; k < this.pathPoints.length; k++) {
                        const existingField = this.pathPoints[k];
                        const distance = Math.sqrt(
                            Math.pow(interpolatedPoint.x - existingField.x, 2) +
                            Math.pow(interpolatedPoint.z - existingField.z, 2)
                        );
                        if (distance < minDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    if (validPosition) {
                        this.pathPoints.push({
                            x: interpolatedPoint.x,
                            y: interpolatedPoint.y + 0.1, // Leicht erhöht für bessere Sichtbarkeit
                            z: interpolatedPoint.z,
                            index: i,
                            onFlatLand: interpolatedPoint.onFlatLand
                        });
                    } else {
                        // If too close, try to find a better position further along the path
                        let adjustedTarget = targetDistance + (minDistance * 0.5);
                        
                        // Find new segment
                        let newSegmentIndex = segmentIndex;
                        for (let j = segmentIndex; j < distances.length - 1; j++) {
                            if (adjustedTarget >= distances[j] && adjustedTarget <= distances[j + 1]) {
                                newSegmentIndex = j;
                                break;
                            }
                        }
                        
                        if (newSegmentIndex < distances.length - 1) {
                            const newSegmentStart = distances[newSegmentIndex];
                            const newSegmentEnd = distances[newSegmentIndex + 1];
                            const newSegmentLength = newSegmentEnd - newSegmentStart;
                            
                            if (newSegmentLength > 0) {
                                const newT = (adjustedTarget - newSegmentStart) / newSegmentLength;
                                const newPoint1 = highResPoints[newSegmentIndex];
                                const newPoint2 = highResPoints[newSegmentIndex + 1];
                                
                                const adjustedPoint = {
                                    x: newPoint1.x + newT * (newPoint2.x - newPoint1.x),
                                    y: newPoint1.y + newT * (newPoint2.y - newPoint1.y),
                                    z: newPoint1.z + newT * (newPoint2.z - newPoint1.z),
                                    onFlatLand: newPoint1.onFlatLand || newPoint2.onFlatLand
                                };
                                
                                this.pathPoints.push({
                                    x: adjustedPoint.x,
                                    y: adjustedPoint.y + 0.1,
                                    z: adjustedPoint.z,
                                    index: i,
                                    onFlatLand: adjustedPoint.onFlatLand
                                });
                            }
                        } else {
                            // Fallback: use original position
                            this.pathPoints.push({
                                x: interpolatedPoint.x,
                                y: interpolatedPoint.y + 0.1,
                                z: interpolatedPoint.z,
                                index: i,
                                onFlatLand: interpolatedPoint.onFlatLand
                            });
                        }
                    }
                } else {
                    // Fallback to nearest point
                    const point = highResPoints[segmentIndex];
                    this.pathPoints.push({
                        x: point.x,
                        y: point.y + 0.1,
                        z: point.z,
                        index: i,
                        onFlatLand: point.onFlatLand
                    });
                }
            }
        }
        
        this.projectPathPointsOntoMountain();
    }

    projectPathPointsOntoMountain() {
        if (!this.mountainMesh || !this.pathPoints) return;
        
        // Verbesserte Projektion - nur für Berg-Felder
        for (let i = 1; i < this.pathPoints.length - 1; i++) { // Skip Start und Ziel
            const point = this.pathPoints[i];
            if (!point.onFlatLand) {
                const raycaster = new THREE.Raycaster();
                const origin = new THREE.Vector3(point.x, 50, point.z); // Höher starten
                const direction = new THREE.Vector3(0, -1, 0);
                raycaster.set(origin, direction);

                const intersects = raycaster.intersectObject(this.mountainMesh, false);
                if (intersects.length > 0) {
                    // Sicherheitsabstand für bessere Sichtbarkeit
                    point.y = Math.max(point.y, intersects[0].point.y + 0.15);
                }
            }
        }
    }

    getTerrainHeightAt(x, z) {
        const raycaster = new THREE.Raycaster(new THREE.Vector3(x, 40, z), new THREE.Vector3(0, -1, 0));
        const objectsToIntersect = [];
        if (this.mountainMesh) objectsToIntersect.push(this.mountainMesh);
        if (this.island) objectsToIntersect.push(this.island);

        const intersects = raycaster.intersectObjects(objectsToIntersect, false);
        if (intersects.length > 0) {
            return intersects[0].point.y;
        }
        return islandSurfaceY;
    }

    getPathInfluence(x, z) {
        let minDistance = Infinity;
        if (!this.pathPoints || this.pathPoints.length === 0) return 0;
        
        for (let i = 0; i < this.pathPoints.length; i++) {
            const point = this.pathPoints[i];
            const dx = x - point.x;
            const dz = z - point.z;
            minDistance = Math.min(minDistance, Math.sqrt(dx * dx + dz * dz));
        }
        
        const pathWidth = BOARD_CONFIG.pathWidth * 0.8; // Etwas breiter
        if (minDistance < pathWidth) {
            return Math.pow(1 - (minDistance / pathWidth), 0.4); // Sanfterer Übergang
        }
        return 0;
    }

    getInterpolatedPathHeight(x, z) {
        let closestDistance = Infinity;
        let closestIndex = -1;
        let secondClosestDistance = Infinity;
        let secondClosestIndex = -1;

        if (!this.pathPoints || this.pathPoints.length === 0) return islandSurfaceY;

        for (let i = 0; i < this.pathPoints.length; i++) {
            const point = this.pathPoints[i];
            const dx = x - point.x;
            const dz = z - point.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < closestDistance) {
                secondClosestDistance = closestDistance;
                secondClosestIndex = closestIndex;
                closestDistance = distance;
                closestIndex = i;
            } else if (distance < secondClosestDistance) {
                secondClosestDistance = distance;
                secondClosestIndex = i;
            }
        }

        if (closestIndex === -1) return islandSurfaceY;
        if (closestDistance < 0.3) return this.pathPoints[closestIndex].y;

        if (secondClosestIndex === -1) {
            return this.pathPoints[closestIndex].y;
        }
            
        const point1 = this.pathPoints[closestIndex];
        const point2 = this.pathPoints[secondClosestIndex];
            
        const dx1 = x - point1.x; 
        const dz1 = z - point1.z; 
        const dist1 = Math.sqrt(dx1*dx1 + dz1*dz1);
        const dx2 = x - point2.x; 
        const dz2 = z - point2.z; 
        const dist2 = Math.sqrt(dx2*dx2 + dz2*dz2);
            
        if (dist1 + dist2 === 0) return point1.y;
        const weight1 = 1 - (dist1 / (dist1 + dist2));
            
        return point1.y * weight1 + point2.y * (1 - weight1);
    }

    createSpiralPath() {
        this.createGameFields();
        this.createPathConnections();
    }

    createGameFields() {
        if (!this.pathPoints || this.pathPoints.length === 0) {
            console.error("Path points not calculated before creating game fields.");
            return;
        }
        
        this.pathPoints.forEach((point, index) => {
            // Verwende die dynamische Feld-Typ-Erkennung
            const type = getFieldTypeAtPosition(index);
            
            const field = this.createGameField(point, type, index);
            this.boardFields.push({ 
                mesh: field, 
                originalPathPoint: new THREE.Vector3(point.x, point.y, point.z), 
                index: index, 
                type: type 
            });
            this.scene.add(field);
        });
    }

    createPathConnections() {
        if (!this.pathPoints || this.pathPoints.length < 2) {
            console.error("Need at least 2 path points to create path connections.");
            return;
        }

        const pathGroup = new THREE.Group();
        
        // Regenerate the continuous path from the original algorithm
        const fieldCount = 73;
        const mountainFootY = islandSurfaceY;
        
        // Use the same high-res points generation as in calculatePathPoints
        const highResPoints = [];
        const samples = 1200;
        
        for (let i = 0; i < samples; i++) {
            const progress = i / (samples - 1);
            let radius;
            
            if (progress < 0.05) {
                radius = BOARD_CONFIG.spiralStartRadius * (1.0 - progress * 2);
            } else if (progress < 0.88) {
                const localProgress = (progress - 0.05) / 0.83;
                const easedProgress = Math.pow(localProgress, 0.82);
                radius = THREE.MathUtils.lerp(
                    BOARD_CONFIG.mountainBaseRadius - 0.8, 
                    BOARD_CONFIG.mountainTopRadius * 2.0,
                    easedProgress
                );
            } else {
                const gipfelProgress = (progress - 0.88) / 0.12;
                radius = Math.max(1.5, BOARD_CONFIG.mountainTopRadius * 10.0 * (1.0 - gipfelProgress * 0.6));
            }
            
            const spiralProgress = Math.pow(progress, 1.15);
            const angle = spiralProgress * Math.PI * 2 * BOARD_CONFIG.spiralLoops;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const distanceToCenter = Math.sqrt(x * x + z * z);
            
            let y;
            if (distanceToCenter > BOARD_CONFIG.mountainBaseRadius - 1.0) {
                y = islandSurfaceY + 0.3;
            } else {
                const mountainProgress = Math.max(0, Math.min(1, 
                    1 - (distanceToCenter / (BOARD_CONFIG.mountainBaseRadius - 1.0))
                ));
                const smoothProgress = Math.pow(mountainProgress, 0.75);
                y = mountainFootY + smoothProgress * BOARD_CONFIG.mountainHeight;
                y += Math.sin(angle * 1.5) * 0.02 * (1 - smoothProgress);
            }
            
            highResPoints.push({ x, y, z, progress });
        }
        
        // Calculate cumulative distances for equal spacing
        // Weight height changes less to avoid spacing issues at ground-to-mountain transition
        const distances = [0];
        for (let i = 1; i < highResPoints.length; i++) {
            const prev = highResPoints[i - 1];
            const curr = highResPoints[i];
            const dist = Math.sqrt(
                Math.pow(curr.x - prev.x, 2) + 
                Math.pow(curr.y - prev.y, 2) * 0.3 + // Reduce height weight for smoother transition
                Math.pow(curr.z - prev.z, 2)
            );
            distances.push(distances[distances.length - 1] + dist);
        }
        
        const totalPathLength = distances[distances.length - 1];
        const targetDotSpacing = 0.3; // Target distance between dots
        const numDots = Math.floor(totalPathLength / targetDotSpacing);
        
        // Create dots at equal arc-length intervals
        for (let dotIndex = 1; dotIndex < numDots; dotIndex++) {
            const targetDistance = (dotIndex / numDots) * totalPathLength;
            
            // Find the segment where this distance falls
            let segmentIndex = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance <= distances[i + 1]) {
                    segmentIndex = i;
                    break;
                }
            }
            
            // Interpolate within the segment
            const segmentStart = distances[segmentIndex];
            const segmentEnd = distances[segmentIndex + 1];
            const segmentLength = segmentEnd - segmentStart;
            
            if (segmentLength > 0) {
                const t = (targetDistance - segmentStart) / segmentLength;
                const point1 = highResPoints[segmentIndex];
                const point2 = highResPoints[segmentIndex + 1];
                
                const interpolatedPoint = {
                    x: point1.x + t * (point2.x - point1.x),
                    y: point1.y + t * (point2.y - point1.y),
                    z: point1.z + t * (point2.z - point1.z)
                };
                
                // Skip points that are too close to actual field positions
                let tooCloseToField = false;
                for (let j = 0; j < this.pathPoints.length; j++) {
                    const fieldPos = this.pathPoints[j];
                    const distance = Math.sqrt(
                        Math.pow(interpolatedPoint.x - fieldPos.x, 2) + 
                        Math.pow(interpolatedPoint.z - fieldPos.z, 2)
                    );
                    if (distance < 0.4) {
                        tooCloseToField = true;
                        break;
                    }
                }
                
                if (!tooCloseToField) {
                    const dotGeometry = new THREE.SphereGeometry(0.015, 8, 8);
                    const dotMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xBCAAA4,
                        transparent: true,
                        opacity: 0.7
                    });
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                    
                    // Ensure dots are properly positioned above the mountain surface
                    const distanceToCenter = Math.sqrt(interpolatedPoint.x * interpolatedPoint.x + interpolatedPoint.z * interpolatedPoint.z);
                    let dotHeight = interpolatedPoint.y + 0.05; // Base height increase
                    
                    // If we're on the mountain (not flat land), add extra height
                    if (distanceToCenter < BOARD_CONFIG.mountainBaseRadius) {
                        dotHeight += 0.15; // Significantly more height to stay above mountain surface
                    }
                    
                    dot.position.set(interpolatedPoint.x, dotHeight, interpolatedPoint.z);
                    
                    pathGroup.add(dot);
                }
            }
        }
        
        this.scene.add(pathGroup);
    }

    createGameField(point, type, index) {
        const group = new THREE.Group();
        const config = BOARD_CONFIG.fieldTypes[type];
        
        // Fallback falls Feldtyp nicht in Konfiguration gefunden wird
        if (!config) {
            console.warn(`Feldtyp '${type}' nicht in BOARD_CONFIG gefunden, verwende normal`);
            config = BOARD_CONFIG.fieldTypes.normal;
        }
        
        const fieldGeometry = new THREE.CylinderGeometry(
            BOARD_CONFIG.fieldRadius * 0.9, 
            BOARD_CONFIG.fieldRadius * 1.0, 
            BOARD_CONFIG.fieldHeight, 
            16 // Mehr Segmente für rundere Felder
        );
        
        const fieldMaterial = new THREE.MeshLambertMaterial({ 
            color: config.color
        });
        
        const fieldMesh = new THREE.Mesh(fieldGeometry, fieldMaterial);
        fieldMesh.position.y = BOARD_CONFIG.fieldHeight / 2;
        fieldMesh.castShadow = true;
        fieldMesh.receiveShadow = true;
        group.add(fieldMesh);
        
        const ringGeometry = new THREE.TorusGeometry(BOARD_CONFIG.fieldRadius * 0.9, 0.025, 8, 20);
        const ringMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(config.color).multiplyScalar(1.2)
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = BOARD_CONFIG.fieldHeight + 0.01;
        group.add(ring);
        
        // Spezielle Dekorationen für Sonderfelder
        this.addSpecialFieldDecoration(group, type, index);
        
        const baseGeometry = new THREE.CylinderGeometry(
            BOARD_CONFIG.fieldRadius * 1.05, 
            BOARD_CONFIG.fieldRadius * 1.15, 
            0.08, 
            16 // Mehr Segmente für rundere Basis
        );
        
        const baseMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(config.color).multiplyScalar(0.7)
        });
        
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.04;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);
        
        group.position.set(point.x, point.y, point.z);
        group.userData = { fieldIndex: index, fieldType: type };
        
        return group;
    }

    addSpecialFieldDecoration(group, type, index) {
        let decoration = null;
        
        switch(type) {
            case 'catapult_forward':
                decoration = this.createArrowDecoration(0x4CAF50, 'up');
                break;
            case 'catapult_backward':
                decoration = this.createArrowDecoration(0xF44336, 'down');
                break;
            case 'player_swap':
                decoration = this.createSwirlDecoration(0x2196F3);
                break;
            case 'barrier':
                decoration = this.createBarrierDecoration(0x9E9E9E);
                break;
        }
        
        if (decoration) {
            decoration.position.y = BOARD_CONFIG.fieldHeight + 0.05;
            group.add(decoration);
        }
    }

    createArrowDecoration(color, direction) {
        const group = new THREE.Group();
        
        const arrowGeometry = new THREE.ConeGeometry(0.15, 0.3, 8);
        const arrowMaterial = new THREE.MeshLambertMaterial({ color: color });
        const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
        
        if (direction === 'up') {
            arrow.position.y = 0.15;
        } else {
            arrow.position.y = 0.15;
            arrow.rotation.z = Math.PI;
        }
        
        group.add(arrow);
        
        const baseGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8);
        const base = new THREE.Mesh(baseGeometry, arrowMaterial);
        base.position.y = 0.1;
        group.add(base);
        
        return group;
    }

    createSwirlDecoration(color) {
        const group = new THREE.Group();
        
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = 0.1 + (i / 8) * 0.2;
            
            const dotGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const dotMaterial = new THREE.MeshLambertMaterial({ color: color });
            const dot = new THREE.Mesh(dotGeometry, dotMaterial);
            
            dot.position.x = Math.cos(angle) * radius;
            dot.position.z = Math.sin(angle) * radius;
            dot.position.y = 0.1 + Math.sin(angle * 2) * 0.05;
            
            group.add(dot);
        }
        
        return group;
    }

    createBarrierDecoration(color) {
        const group = new THREE.Group();
        
        const barGeometry = new THREE.BoxGeometry(0.4, 0.05, 0.05);
        const barMaterial = new THREE.MeshLambertMaterial({ color: color });
        
        const bar1 = new THREE.Mesh(barGeometry, barMaterial);
        bar1.rotation.y = Math.PI / 4;
        bar1.position.y = 0.1;
        group.add(bar1);
        
        const bar2 = new THREE.Mesh(barGeometry, barMaterial);
        bar2.rotation.y = -Math.PI / 4;
        bar2.position.y = 0.1;
        group.add(bar2);
        
        return group;
    }

    createSimpleVegetation() {
        // Palmen
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = 24 + Math.random() * 4;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            if (this.isPositionSafe(x, z, 1.5)) {
                const palm = this.createSimplePalmTree();
                palm.position.set(x, islandSurfaceY, z);
                palm.scale.setScalar(0.8 + Math.random() * 0.3);
                palm.rotation.y = Math.random() * Math.PI * 2;
                this.scene.add(palm);
            }
        }
        
        // Büsche und kleine Bäume
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 15 + Math.random() * 12;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            if (this.isPositionSafe(x, z, 0.8)) {
                const bush = this.createBush();
                bush.position.set(x, islandSurfaceY + 0.2, z);
                bush.scale.setScalar(0.5 + Math.random() * 0.4);
                this.scene.add(bush);
            }
        }
        
        // Blumen
        for (let i = 0; i < 25; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 8 + Math.random() * 20;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            if (this.isPositionSafe(x, z, 0.3)) {
                const flower = this.createFlower();
                flower.position.set(x, islandSurfaceY + 0.15, z);
                this.scene.add(flower);
            }
        }
        
        for (let i = 0; i < 8; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 15 + Math.random() * 8; // Angepasst für größere Insel
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            if (this.isPositionSafe(x, z, 1)) {
                const bush = this.createSimpleBush();
                const terrainY = this.getTerrainHeightAt(x, z);
                bush.position.set(x, terrainY, z);
                bush.scale.setScalar(0.4 + Math.random() * 0.3);
                this.scene.add(bush);
            }
        }
    }

    createSimplePalmTree() {
        const palmGroup = new THREE.Group();
        
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.28, 4.5, 8);
        const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2.25;
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        palmGroup.add(trunk);
        
        const leavesGroup = new THREE.Group();
        leavesGroup.position.y = 4.5;
        
        for (let i = 0; i < 6; i++) {
            const leafGeometry = new THREE.PlaneGeometry(1, 2.2);
            leafGeometry.translate(0, 1.1, 0);
            
            const leafMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22, 
                side: THREE.DoubleSide
            });
            
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.rotation.z = Math.PI / 10 + (Math.random() - 0.5) * 0.2;
            leaf.rotation.y = (i / 6) * Math.PI * 2;
            leaf.castShadow = true;
            leaf.receiveShadow = true;
            leavesGroup.add(leaf);
        }
        
        palmGroup.add(leavesGroup);
        return palmGroup;
    }
    
    createBush() {
        const bushGroup = new THREE.Group();
        
        // Busch-Stamm
        const bushGeometry = new THREE.SphereGeometry(0.6, 8, 6);
        const bushMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const bush = new THREE.Mesh(bushGeometry, bushMaterial);
        bush.position.y = 0.3;
        bush.scale.set(1, 0.8, 1);
        bush.castShadow = true;
        bush.receiveShadow = true;
        bushGroup.add(bush);
        
        // Kleinere Büschel
        for (let i = 0; i < 3; i++) {
            const smallBush = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 6, 4),
                new THREE.MeshLambertMaterial({ color: 0x32CD32 })
            );
            smallBush.position.set(
                (Math.random() - 0.5) * 1.2,
                0.2 + Math.random() * 0.3,
                (Math.random() - 0.5) * 1.2
            );
            smallBush.castShadow = true;
            bushGroup.add(smallBush);
        }
        
        return bushGroup;
    }
    
    createFlower() {
        const flowerGroup = new THREE.Group();
        
        // Blütenstiel
        const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
        const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.y = 0.15;
        flowerGroup.add(stem);
        
        // Blütenblätter
        const colors = [0xFF69B4, 0xFF1493, 0xFFB6C1, 0xFFA500, 0xFFFF00, 0xFF4500];
        const petalGeometry = new THREE.SphereGeometry(0.05, 6, 4);
        const flowerColor = colors[Math.floor(Math.random() * colors.length)];
        
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const petal = new THREE.Mesh(petalGeometry, new THREE.MeshLambertMaterial({ color: flowerColor }));
            petal.position.set(
                Math.cos(angle) * 0.08,
                0.3,
                Math.sin(angle) * 0.08
            );
            petal.scale.set(1, 0.5, 1);
            flowerGroup.add(petal);
        }
        
        // Blütenmitte
        const center = new THREE.Mesh(
            new THREE.SphereGeometry(0.03, 6, 4),
            new THREE.MeshLambertMaterial({ color: 0xFFFF00 })
        );
        center.position.y = 0.3;
        flowerGroup.add(center);
        
        return flowerGroup;
    }
    
    createAnimatedAnimals() {
        this.rabbits = [];
        this.activeBirds = [];
        this.lastBirdFlockTime = 0;
        
        // Hasen erstellen
        for (let i = 0; i < 3; i++) {
            const rabbit = this.createRabbit();
            const angle = Math.random() * Math.PI * 2;
            const radius = 10 + Math.random() * 15;
            rabbit.position.set(
                Math.cos(angle) * radius,
                islandSurfaceY + 0.3,
                Math.sin(angle) * radius
            );
            rabbit.userData = {
                speed: 0.3 + Math.random() * 0.2,
                direction: Math.random() * Math.PI * 2,
                changeDirectionTimer: 0
            };
            this.rabbits.push(rabbit);
            this.scene.add(rabbit);
        }
    }
    
    createBirdFlock() {
        const flockSize = 3 + Math.floor(Math.random() * 4); // 3-6 Vögel
        const birds = [];
        
        // Startposition für den Schwarm (außerhalb der Sicht)
        const startAngle = Math.random() * Math.PI * 2;
        const startRadius = 60;
        const startX = Math.cos(startAngle) * startRadius;
        const startZ = Math.sin(startAngle) * startRadius;
        const flightHeight = islandSurfaceY + 8 + Math.random() * 10;
        
        // Zielposition (gegenüber)
        const targetX = -startX + (Math.random() - 0.5) * 20;
        const targetZ = -startZ + (Math.random() - 0.5) * 20;
        
        for (let i = 0; i < flockSize; i++) {
            const bird = this.createBird();
            
            // V-Formation
            const offsetX = (i - flockSize/2) * 2;
            const offsetZ = Math.abs(i - flockSize/2) * 1.5;
            
            bird.position.set(
                startX + offsetX,
                flightHeight + (Math.random() - 0.5) * 2,
                startZ + offsetZ
            );
            
            bird.userData = {
                targetX: targetX + offsetX,
                targetZ: targetZ + offsetZ,
                targetY: flightHeight + (Math.random() - 0.5) * 2,
                speed: 1.5 + Math.random() * 0.5,
                startTime: Date.now(),
                flightDuration: 8000 + Math.random() * 4000, // 8-12 Sekunden
                bobSpeed: 2 + Math.random() * 1,
                wingSpeed: 8 + Math.random() * 4
            };
            
            // Richtung zum Ziel
            const dx = bird.userData.targetX - bird.position.x;
            const dz = bird.userData.targetZ - bird.position.z;
            bird.rotation.y = Math.atan2(dx, dz);
            
            birds.push(bird);
            this.scene.add(bird);
        }
        
        this.activeBirds = this.activeBirds.concat(birds);
        return birds;
    }
    
    createRabbit() {
        const rabbitGroup = new THREE.Group();
        
        // Körper
        const bodyGeometry = new THREE.SphereGeometry(0.15, 8, 6);
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.scale.set(1, 0.8, 1.2);
        body.position.y = 0.1;
        body.castShadow = true;
        rabbitGroup.add(body);
        
        // Kopf
        const headGeometry = new THREE.SphereGeometry(0.08, 8, 6);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.position.set(0, 0.2, 0.12);
        head.castShadow = true;
        rabbitGroup.add(head);
        
        // Ohren
        const earGeometry = new THREE.SphereGeometry(0.03, 6, 4);
        const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
        leftEar.position.set(-0.03, 0.28, 0.12);
        leftEar.scale.set(1, 2, 0.5);
        rabbitGroup.add(leftEar);
        
        const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
        rightEar.position.set(0.03, 0.28, 0.12);
        rightEar.scale.set(1, 2, 0.5);
        rabbitGroup.add(rightEar);
        
        // Schwanz
        const tailGeometry = new THREE.SphereGeometry(0.04, 6, 4);
        const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
        tail.position.set(0, 0.12, -0.12);
        rabbitGroup.add(tail);
        
        return rabbitGroup;
    }
    
    createBird() {
        const birdGroup = new THREE.Group();
        
        // Einfacheres, vogelähnlicheres Design
        const bodyGeometry = new THREE.SphereGeometry(0.12, 8, 6);
        const colors = [0x8B4513, 0x654321, 0x2F4F4F, 0x696969, 0x000000];
        const birdColor = colors[Math.floor(Math.random() * colors.length)];
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: birdColor });
        
        // Körper - länglicher für Vogel-Form
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.scale.set(0.8, 0.6, 1.4);
        body.castShadow = true;
        birdGroup.add(body);
        
        // Vereinfachte Flügel - flacher und vogelähnlicher
        const wingGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.3);
        const leftWing = new THREE.Mesh(wingGeometry, bodyMaterial);
        leftWing.position.set(-0.12, 0.02, 0);
        leftWing.name = 'leftWing';
        birdGroup.add(leftWing);
        
        const rightWing = new THREE.Mesh(wingGeometry, bodyMaterial);
        rightWing.position.set(0.12, 0.02, 0);
        rightWing.name = 'rightWing';
        birdGroup.add(rightWing);
        
        // Schwanz
        const tailGeometry = new THREE.BoxGeometry(0.04, 0.01, 0.2);
        const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
        tail.position.set(0, 0, -0.2);
        birdGroup.add(tail);
        
        return birdGroup;
    }

    createSimpleBush() {
        const bushGroup = new THREE.Group();
        const colors = [0x2E7D32, 0x388E3C, 0x4CAF50];
        
        for (let i = 0; i < 2; i++) {
            const bushElement = new THREE.Mesh(
                new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 8, 8),
                new THREE.MeshLambertMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)]
                })
            );
            
            bushElement.position.set(
                (Math.random() - 0.5) * 0.4, 
                0.1 + Math.random() * 0.1, 
                (Math.random() - 0.5) * 0.4
            );
            bushElement.scale.setScalar(0.6 + Math.random() * 0.4);
            bushElement.castShadow = true;
            bushElement.receiveShadow = true;
            bushGroup.add(bushElement);
        }
        
        return bushGroup;
    }

    createSimpleEnvironmentalDetails() {
        this.createSimpleClouds();
    }

    createSimpleClouds() {
        this.clouds = [];
        for (let i = 0; i < 2; i++) {
            const cloudGroup = new THREE.Group();
            
            for (let j = 0; j < 2; j++) {
                const size = 1.2 + Math.random() * 1.5;
                const cloudMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                
                const cloudMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 8),
                    cloudMaterial
                );
                
                cloudMesh.position.set(
                    (Math.random() - 0.5) * size * 1.2, 
                    (Math.random() - 0.5) * size * 0.2, 
                    (Math.random() - 0.5) * size * 1.2
                );
                cloudGroup.add(cloudMesh);
            }
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 50 + Math.random() * 40; // Angepasst für größere Szene
            cloudGroup.position.set(
                Math.cos(angle) * distance, 
                25 + Math.random() * 10, 
                Math.sin(angle) * distance
            );
            
            this.scene.add(cloudGroup);
            this.clouds.push({ 
                mesh: cloudGroup, 
                baseY: cloudGroup.position.y, 
                speed: 0.006 + Math.random() * 0.008, 
                direction: Math.random() > 0.5 ? 1 : -1 
            });
        }
    }

    isPositionSafe(x, z, minDistance) {
        const distanceToMountainCenter = Math.sqrt(x * x + z * z);
        if (distanceToMountainCenter < BOARD_CONFIG.mountainBaseRadius + minDistance) return false;
        
        if (!this.pathPoints || this.pathPoints.length === 0) return true;
        
        for (const point of this.pathPoints) {
            const dx = x - point.x;
            const dz = z - point.z;
            if (Math.sqrt(dx * dx + dz * dz) < minDistance) return false;
        }
        return true;
    }

    setupEventListeners() {
        window.addEventListener('resize', () => this.updateCanvasSize());
        
        document.addEventListener('fullscreenchange', () => this.updateCanvasSize());
        document.addEventListener('webkitfullscreenchange', () => this.updateCanvasSize());
        document.addEventListener('mozfullscreenchange', () => this.updateCanvasSize());
        document.addEventListener('MSFullscreenChange', () => this.updateCanvasSize());
        
        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'm') {
                GAME_STATE.freeCameraMode = !GAME_STATE.freeCameraMode;
                this.controls.enabled = GAME_STATE.freeCameraMode;
                this.showStatusMessage(GAME_STATE.freeCameraMode ? 'Freie Kamera aktiviert' : 'Freie Kamera deaktiviert', 2000, 'info');
                
                if (!GAME_STATE.freeCameraMode) {
                    GAME_STATE.isAnimating = false;
                    GAME_STATE.isAnimatingCamera = false;
                    GAME_STATE.playerTurnInProgress = false;
                    this.stopCameraFollow();
                    this.requestCameraMode('team_focus', {team: this.teams[this.currentTurn]}, 'normal');
                }
            } else if (event.key.toLowerCase() === 'f') {
                this.toggleFullscreen();
            } else if (event.key.toLowerCase() === 'p') {
                // Test minigame placements (P key - accessible for everyone)
                console.log("🧪 Testing Minigame Placements (P key)");
                if (localTeams && localTeams.length > 0) {
                    console.log("📋 Adding test placements to local teams");
                    localTeams.forEach((team, index) => {
                        team.minigame_placement = index + 1;
                    });
                    console.log("✅ Local teams now have placements:", localTeams.map(t => ({name: t.name, placement: t.minigame_placement})));
                    
                    // Test simplified logic directly
                    setTimeout(() => {
                        console.log("🎯 Testing simplified logic with placements");
                        // Removed banner function call
                    }, 500);
                }
            } else if (event.key.toLowerCase() === 'l') {
                // Test team logging (L key - accessible for everyone)
                console.log("🔍 LOCAL TEAMS DEBUG:", localTeams.map(t => ({
                    name: t.name, 
                    placement: t.minigame_placement,
                    placementType: typeof t.minigame_placement,
                    placementIsNull: t.minigame_placement === null,
                    placementIsUndefined: t.minigame_placement === undefined
                })));
            } else if (event.key.toLowerCase() === 'r' && isAdmin) {
                if (!GAME_STATE.isAnimating && !GAME_STATE.isDiceRolling && !GAME_STATE.isCharacterMoving && !GAME_STATE.playerTurnInProgress) {
                    this.rollDice();
                } else {
                    console.log("⚠️ [DICE] Cannot roll dice - game state:", {
                        isAnimating: GAME_STATE.isAnimating,
                        isDiceRolling: GAME_STATE.isDiceRolling,
                        isCharacterMoving: GAME_STATE.isCharacterMoving,
                        playerTurnInProgress: GAME_STATE.playerTurnInProgress
                    });
                }
            } else if (event.key.toLowerCase() === 'x' && isAdmin) {
                // Emergency dice reset (X key for admins)
                this.resetDiceState();
                this.showStatusMessage('Würfelzustand zurückgesetzt', 2000, 'warning');
            } else if (event.key.toLowerCase() === 'o') {
                // Elegante Kamera-Orbit (O key)
                if (window.orbitAnimationRunning) {
                    stopCameraOrbitAnimation();
                    this.showStatusMessage('Elegante Kamera-Orbit gestoppt', 2000, 'info');
                } else {
                    startCameraOrbitAnimation(false); // Standard orbit mode
                    this.showStatusMessage('Elegante Kamera-Orbit gestartet - O zum Stoppen', 3000, 'success');
                }
            } else if (event.key.toLowerCase() === 'p') {
                // Minispiel-Kamera-Orbit (P key)
                if (window.orbitAnimationRunning) {
                    stopCameraOrbitAnimation();
                    this.showStatusMessage('Minispiel-Kamera gestoppt', 2000, 'info');
                } else {
                    startMinigameCameraOrbit(30000);
                    this.showStatusMessage('Minispiel-Kamera gestartet (30s) - P zum Stoppen', 3000, 'success');
                }
            } else if (event.key.toLowerCase() === 'c') {
                // Auto-Kamera System ein/aus (C key)
                GAME_STATE.autoCameraEnabled = !GAME_STATE.autoCameraEnabled;
                
                if (GAME_STATE.autoCameraEnabled) {
                    this.showStatusMessage('Auto-Kamera aktiviert - Vollautomatische Steuerung', 3000, 'success');
                    // Starte Auto-Kamera sofort
                    this.updateAutomaticCamera();
                } else {
                    this.showStatusMessage('Auto-Kamera deaktiviert - Manuelle Steuerung', 3000, 'info');
                    // Stoppe alle automatischen Kamera-Aktivitäten
                    if (GAME_STATE.autoOrbitActive) {
                        stopCameraOrbitAnimation();
                    }
                    this.stopAutomaticPlayerFollowing();
                    GAME_STATE.cameraFocusMode = 'manual';
                }
            } else if (event.key.toLowerCase() === 't' && isAdmin) {
                // Test minigame results (T key for admin)
                this.testMinigameResults();
            } else if (event.key.toLowerCase() === 'g' && isAdmin) {
                // Test game sequence (G key for admin)
                this.executeGameSequence();
            }
        });
    }

    testMinigameResults() {
        console.log("🧪 Testing minigame results display...");
        
        // Create test results based on current teams
        const testResults = [];
        if (localTeams && localTeams.length > 0) {
            localTeams.forEach((team, index) => {
                testResults.push({
                    team_id: team.id,
                    team_name: team.name,
                    placement: index + 1
                });
            });
        } else {
            // Create dummy test data if no teams available
            testResults.push(
                { team_id: 1, team_name: "Team Alpha", placement: 1 },
                { team_id: 2, team_name: "Team Beta", placement: 2 },
                { team_id: 3, team_name: "Team Gamma", placement: 3 }
            );
        }
        
        console.log("🎯 Test results created:", testResults);
        this.showMinigameResults(testResults);
        this.showStatusMessage("Minigame Results Test ausgeführt (T-Taste)", 2000, 'info');
    }



    showStatusMessage(message, duration = 3000, type = 'info') {
        
        const existingMessage = document.querySelector('.status-message');
        if (existingMessage) existingMessage.remove();
        
        const statusDiv = document.createElement('div');
        statusDiv.className = `status-message status-${type}`;
        statusDiv.textContent = message;
        document.body.appendChild(statusDiv);
        
        setTimeout(() => {
            if (statusDiv.parentNode) statusDiv.remove();
        }, duration);
    }

    isSpecialField(position) {
        // Simple check - could be enhanced with actual field data
        return [5, 10, 15, 20, 25].includes(position);
    }



    setCameraOverview(duration = 3000, callback = null) {
        if (GAME_STATE.freeCameraMode) {
            console.log("Kamera-Übersicht übersprungen (freie Kamera aktiv)");
            if (callback) callback();
            return;
        }

        console.log("Setze Kamera auf Übersichts-Position");
        GAME_STATE.isAnimating = true;

        // Calculate overview position - higher and further back to see whole island
        const overviewPosition = {
            x: 0,
            y: 35, // Higher than normal camera
            z: 45  // Further back than normal camera
        };

        const overviewTarget = {
            x: 0,
            y: 0,
            z: 0  // Look at center of island
        };

        // Animate camera to overview position
        const startPos = this.camera.position.clone();
        const startTarget = this.controls.target.clone();
        const startTime = Date.now();

        const animateToOverview = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / 1500, 1); // 1.5 second animation
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic

            // Interpolate camera position
            this.camera.position.lerpVectors(startPos, new THREE.Vector3(overviewPosition.x, overviewPosition.y, overviewPosition.z), eased);
            
            // Interpolate look-at target
            this.controls.target.lerpVectors(startTarget, new THREE.Vector3(overviewTarget.x, overviewTarget.y, overviewTarget.z), eased);
            this.controls.update();

            if (progress < 1) {
                requestAnimationFrame(animateToOverview);
            } else {
                // Overview complete, wait for duration then callback
                setTimeout(() => {
                    GAME_STATE.isAnimating = false;
                    if (callback) callback();
                    console.log("Kamera-Übersicht beendet");
                }, duration);
            }
        };

        animateToOverview();
    }

    checkAllPlayersFinished() {
        // Check if all teams have completed their turns for the current round
        if (!localTeams || localTeams.length === 0) {
            return false;
        }

        // Simple check: if game phase is ROUND_OVER, all players finished
        if (currentGamePhase === 'ROUND_OVER') {
            return true;
        }

        // Alternative check: if no team is currently active, might indicate round end
        if (!GAME_STATE.currentServerTeamTurnId) {
            return currentGamePhase === 'ROUND_OVER';
        }

        return false;
    }

    executeGameSequence() {
        console.log("🎯 Starte Spielsequenz-Ausführung - Phase:", currentGamePhase, "Minigame:", currentMinigameName);
        
        // Check if minigame was just announced
        if (currentMinigameName && currentGamePhase === 'MINIGAME_ANNOUNCED') {
            console.log("📢 Minispiel-Ankündigung:", currentMinigameName, currentMinigameDescription);
            return;
        }

        // ====== SIMPLIFIED GAME LOGIC (team_dashboard style) ======
        // Debug info for game logic
        // Debug info removed for cleaner console output

        // Check for minigame/question results using same logic as team_dashboard  
        if (currentGamePhase === 'DICE_ROLLING' && lastPhase !== 'DICE_ROLLING' && !hasShowMinigameResults && localTeams) {
            // Don't show normal minigame results if coming from field minigame phases
            const fieldMinigamePhases = ['FIELD_MINIGAME_SELECTION_PENDING', 'FIELD_MINIGAME_TRIGGERED', 'FIELD_MINIGAME_COMPLETED'];
            const isComingFromFieldMinigame = fieldMinigamePhases.includes(lastPhase);
            
            if (isComingFromFieldMinigame) {
                console.log("🎯 SIMPLE: Coming from field minigame - skipping normal minigame results banner");
            } else {
                console.log("🏆 SIMPLE: Phase changed to DICE_ROLLING - showing minigame results");
                
                // Filter teams with placements (same as team_dashboard)
                const teamsWithPlacements = localTeams.filter(team => team.minigame_placement);
                
                console.log("🔍 Teams with placements:", teamsWithPlacements.map(t => ({
                    name: t.name, 
                    placement: t.minigame_placement,
                    placementType: typeof t.minigame_placement
                })));
                
                if (teamsWithPlacements.length > 0) {
                    console.log("🎯 SIMPLE: Showing minigame results for teams:", teamsWithPlacements.map(t => ({name: t.name, placement: t.minigame_placement})));
                    this.showMinigameResultsSimple(teamsWithPlacements);
                    hasShowMinigameResults = true;
                } else {
                    console.log("❌ SIMPLE: No teams with placements found");
                }
            }
        } else if (currentGamePhase !== 'DICE_ROLLING') {
            hasShowMinigameResults = false;
        }
        
        // ====== ORIGINAL COMPLEX LOGIC (for comparison) ======
        // Check if minigame results should be displayed
        if (currentGamePhase === 'MINIGAME_RESULTS' && localTeams) {
            console.log("🏆 Prüfe Minispiel-Ergebnisse Phase - Teams:", localTeams.map(t => ({id: t.id, name: t.name, placement: t.minigame_placement})));
            
            const results = localTeams.filter(team => team.minigame_placement !== null && team.minigame_placement !== undefined)
                                   .map(team => ({
                                       team_id: team.id,
                                       team_name: team.name,
                                       placement: team.minigame_placement
                                   }));
            
            console.log("🎯 Gefilterte Minispiel-Ergebnisse:", results);
            
            if (results.length > 0) {
                console.log("✅ Zeige Minispiel-Ergebnisse an");
                this.showMinigameResults(results);
                return;
            } else {
                console.log("⚠️ Keine Minispiel-Ergebnisse zu zeigen (keine Platzierungen gesetzt)");
                console.log("🔍 Debug: Team placements details:", localTeams.map(t => ({
                    id: t.id, 
                    name: t.name, 
                    placement: t.minigame_placement, 
                    placementType: typeof t.minigame_placement
                })));
            }
        } else {
            // Debug output removed for cleaner console
        }

        // Check if all players finished their turns - show overview
        if (this.checkAllPlayersFinished()) {
            this.setCameraOverview(3000, () => {
                // Don't focus back on player when round is over - stay in overview
                console.log("Round overview complete - staying in overview mode");
            });
            return;
        }

        console.log("Keine besonderen Sequenz-Aktionen erforderlich");
    }

    getCurrentTeam() {
        if (localTeams && localTeams.length > 0 && GAME_STATE.currentServerTeamTurnId != null) {
            return localTeams.find(t => t.id === GAME_STATE.currentServerTeamTurnId);
        }
        
        if (localTeams && localTeams.length > 0 && GAME_STATE.diceRollOrderFromServer && GAME_STATE.diceRollOrderFromServer.length > 0) {
            const firstTeamIdInOrder = parseInt(GAME_STATE.diceRollOrderFromServer[0]);
            if (!isNaN(firstTeamIdInOrder)) {
                return localTeams.find(t => t.id === firstTeamIdInOrder);
            }
        }
        return null;
    }

    checkBarrierRelease(diceRoll, bonusRoll, totalRoll, barrierConfig) {
        // Mirror the server-side logic for barrier release
        if (!barrierConfig || !barrierConfig.numbers) {
            return { released: false, method: null };
        }
        
        // Check standard die
        if (barrierConfig.numbers.includes(diceRoll)) {
            return { released: true, method: 'standard' };
        }
        
        // Check bonus die if available
        if (bonusRoll > 0 && barrierConfig.numbers.includes(bonusRoll)) {
            return { released: true, method: 'bonus' };
        }
        
        // Check total roll
        if (barrierConfig.numbers.includes(totalRoll)) {
            return { released: true, method: 'total' };
        }
        
        return { released: false, method: null };
    }

    updateTeamDisplay() {}
    
    handlePostMinigameCameraUpdates(gameSession) {
        // Handle camera transitions after field minigames
        if (!gameSession) return;
        
        const currentPhase = gameSession.current_phase;
        const previousPhase = window.lastGamePhase || '';
        
        // Detect transition from field minigame phases to next phase
        const fieldMinigamePhases = ['FIELD_MINIGAME_SELECTION_PENDING', 'FIELD_MINIGAME_TRIGGERED', 'FIELD_MINIGAME_COMPLETED'];
        const wasInFieldMinigame = fieldMinigamePhases.includes(previousPhase);
        const isNowInNextPhase = currentPhase === 'DICE_ROLLING' || currentPhase === 'ROUND_OVER';
        
        if (wasInFieldMinigame && isNowInNextPhase) {
            console.log("🎥 [CAMERA] Field minigame completed, handling camera transition", {
                from: previousPhase,
                to: currentPhase,
                currentTeamTurnId: gameSession.current_team_turn_id
            });
            
            // Add small delay to allow any team position updates to complete
            setTimeout(() => {
                this.handleFieldMinigameCameraTransition(gameSession);
            }, 500);
        }
        
        // Update last phase for next comparison
        window.lastGamePhase = currentPhase;
    }
    
    handleFieldMinigameCameraTransition(gameSession) {
        const currentPhase = gameSession.current_phase;
        
        if (currentPhase === 'ROUND_OVER') {
            // Round is over - switch to orbit mode
            console.log("🌌 [CAMERA] Round over after field minigame - switching to orbit");
            this.switchToAutoOrbit();
            
            // Show status message
            setTimeout(() => {
                this.showStatusMessage("Alle Teams haben gewürfelt. Admin kann nächstes Minispiel setzen.", 3000, 'success', true, 'Runde beendet');
            }, 1000);
            
        } else if (currentPhase === 'DICE_ROLLING' && gameSession.current_team_turn_id) {
            // There's a next team to focus on
            const nextTeamId = gameSession.current_team_turn_id;
            const nextTeam = localTeams?.find(t => t.id === nextTeamId);
            
            if (nextTeam) {
                // Prüfe ob Bewegung aktiv ist
                if (GAME_STATE.isCharacterMoving || GAME_STATE.isAnimating || this.activeMovementAnimation) {
                    console.log("🎯 [CAMERA] Next team focus delayed - movement in progress:", nextTeam.name);
                    // Warte bis Bewegung beendet ist, dann fokussiere das Team
                    const waitAndFocus = () => {
                        if (GAME_STATE.isCharacterMoving || GAME_STATE.isAnimating || this.activeMovementAnimation) {
                            setTimeout(waitAndFocus, 300);
                            return;
                        }
                        console.log("🎯 [CAMERA] Movement finished, now focusing next team:", nextTeam.name);
                        
                        // ✅ FIX: Stop any running orbit animation before focusing on next team
                        if (window.orbitAnimationRunning && typeof stopCameraOrbitAnimation === 'function') {
                            console.log("🎥 Stopping camera orbit to focus on next team");
                            stopCameraOrbitAnimation();
                        }
                        
                        // Update game state to the next team
                        GAME_STATE.currentServerTeamTurnId = nextTeamId;
                        const nextTeamIndex = localTeams.findIndex(t => t.id === nextTeamId);
                        if (nextTeamIndex !== -1) {
                            GAME_STATE.currentTeamIndex = nextTeamIndex;
                        }
                        
                        // Focus camera on next team with smooth transition
                        this.requestCameraMode('team_focus', {team: nextTeam}, 'normal');
                        
                        // Update team display
                        this.updateTeamDisplay();
                    };
                    setTimeout(waitAndFocus, 500);
                } else {
                    console.log("🎯 [CAMERA] Next team after field minigame:", nextTeam.name);
                    
                    // ✅ FIX: Stop any running orbit animation before focusing on next team
                    if (window.orbitAnimationRunning && typeof stopCameraOrbitAnimation === 'function') {
                        console.log("🎥 Stopping camera orbit to focus on next team (no movement delay)");
                        stopCameraOrbitAnimation();
                    }
                    
                    // Update game state to the next team
                    GAME_STATE.currentServerTeamTurnId = nextTeamId;
                    const nextTeamIndex = localTeams.findIndex(t => t.id === nextTeamId);
                    if (nextTeamIndex !== -1) {
                        GAME_STATE.currentTeamIndex = nextTeamIndex;
                    }
                    
                    // Focus camera on next team with smooth transition
                    this.requestCameraMode('team_focus', {team: nextTeam}, 'normal');
                    
                    // Update team display
                    this.updateTeamDisplay();
                }
                
            } else {
                console.warn("🎯 [CAMERA] Next team not found, switching to orbit");
                this.switchToAutoOrbit();
            }
            
        } else {
            // Fallback - switch to orbit if no clear next action
            console.log("🌌 [CAMERA] No clear next action after field minigame - switching to orbit");
            this.switchToAutoOrbit();
        }
    }
    
    updateMinigameDisplay() {
        // Update any minigame-related UI elements
    }

    async loadCharacterScript(jsPath) {
        let rawFunctionName = jsPath.split('/').pop().replace(/\.js$/, '');
        let functionName = rawFunctionName;

        if (rawFunctionName === 'defaultCharacter') {
            functionName = 'createDefaultCharacter';
        } else if (!rawFunctionName.toLowerCase().startsWith('create')) {
            functionName = 'create' + rawFunctionName.charAt(0).toUpperCase() + rawFunctionName.slice(1);
        }

        if (this.characterCreationFunctions[functionName]) {
            return this.characterCreationFunctions[functionName];
        }

        const fallbackCreateFunction = window.createDefaultCharacter;
        if (typeof fallbackCreateFunction !== 'function') {
            console.error("FATAL: window.createDefaultCharacter ist nicht verfügbar!");
            return () => new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 1, 0.5), 
                new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true})
            );
        }

        return new Promise((resolve) => {
            if (!jsPath || jsPath.trim() === "") {
                resolve(fallbackCreateFunction);
                return;
            }
            
            const script = document.createElement('script');
            script.src = `{{ url_for('static', filename='') }}${jsPath}?v=${new Date().getTime()}`;

            script.onload = () => {
                if (typeof window[functionName] === 'function') {
                    this.characterCreationFunctions[functionName] = window[functionName];
                    resolve(window[functionName]);
                } else {
                    console.error(`Charakter-Funktion ${functionName} nicht gefunden. Verwende Default.`);
                    resolve(fallbackCreateFunction);
                }
            };
            
            script.onerror = (e) => {
                console.error(`Fehler beim Laden des Charakter-Skripts ${jsPath}:`, e);
                resolve(fallbackCreateFunction);
            };
            
            document.head.appendChild(script);
        });
    }

    async createMiiCharacters() {
        if (typeof window.createDefaultCharacter !== 'function') {
            try {
                await this.loadCharacterScript('js/characters/defaultCharacter.js');
                if (typeof window.createDefaultCharacter !== 'function') {
                    console.error('Konnte window.createDefaultCharacter nicht laden.');
                    return;
                }
            } catch (e) {
                console.error('Fehler beim Laden von defaultCharacter.js:', e);
                return;
            }
        }

        for (const team of localTeams) {
            let createFunction;
            let characterJsFile = "js/characters/defaultCharacter.js";

            if (team.character_info && team.character_info.js_file && team.character_info.js_file.trim() !== "") {
                characterJsFile = team.character_info.js_file;
            }

            try {
                createFunction = await this.loadCharacterScript(characterJsFile);
            } catch (error) {
                console.error(`Fehler beim Laden des Skripts ${characterJsFile}:`, error);
                createFunction = window.createDefaultCharacter;
            }

            if (typeof createFunction !== 'function') {
                createFunction = window.createDefaultCharacter;
            }

            let characterMesh;
            try {
                const customization = team.character_info ? team.character_info.customization : null;
                characterMesh = createFunction(team.color || '#CCCCCC', customization);
            } catch (error) {
                console.error(`❌ Fehler beim Erstellen des Charakters für Team ${team.name}:`, error);
                characterMesh = null;
            }
            
            if (!characterMesh || typeof characterMesh.scale === 'undefined') {
                console.warn(`⚠️ Fallback zu Default-Charakter für Team ${team.name}`);
                try {
                    const customization = team.character_info ? team.character_info.customization : null;
                    this.miiCharacters[team.id] = window.createDefaultCharacter(team.color || '#CCCCCC', customization);
                    if(this.miiCharacters[team.id]) {
                        this.miiCharacters[team.id].scale.setScalar(BOARD_CONFIG.characterSize);
                    } else {
                        console.error(`❌ Konnte keinen Charakter für Team ${team.name} erstellen`);
                        continue;
                    }
                } catch (fallbackError) {
                    console.error(`❌ Fallback-Charakter-Erstellung fehlgeschlagen für Team ${team.name}:`, fallbackError);
                    continue;
                }
            } else {
                this.miiCharacters[team.id] = characterMesh;
                this.miiCharacters[team.id].scale.setScalar(BOARD_CONFIG.characterSize);
            }

            // DEAKTIVIERT: Keine automatische Charakterausrichtung bei Initialisierung
            // this.orientCharacterToNextField(this.miiCharacters[team.id], team.position);
            console.log("👤 [INIT] Character orientation skipped for team", team.name);
            
            this.miiCharacters[team.id].castShadow = true;
            this.miiCharacters[team.id].receiveShadow = true;
            this.miiCharacters[team.id].traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });

            const startField = this.boardFields[team.position];
            if (startField && startField.mesh) {
                this.miiCharacters[team.id].position.copy(startField.mesh.position);
                this.miiCharacters[team.id].position.y += BOARD_CONFIG.characterElevation;
            } else {
                this.miiCharacters[team.id].position.set(
                    BOARD_CONFIG.spiralStartRadius + (Math.random()-0.5)*2, 
                    islandSurfaceY + BOARD_CONFIG.characterElevation, 
                    (Math.random()-0.5)*2
                );
            }
            
            if (team.is_blocked) {
                this.addBlockedTeamEffect(this.miiCharacters[team.id]);
            }
            
            this.scene.add(this.miiCharacters[team.id]);
        }
        
        this.updateTeamDisplay();
    }

    orientCharacterToNextField(character, currentPosition) {
        // DEAKTIVIERT: Charaktere sollen immer geradeaus schauen ohne Drehung
        // Keine automatische Orientierung mehr
        console.log("👤 [CHARACTER] Automatic character orientation disabled - keeping straight forward");
    }

    addBlockedTeamEffect(characterMesh) {
        const glowGeometry = new THREE.SphereGeometry(BOARD_CONFIG.characterSize * 1.5, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFF4444,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.userData.isBlockedEffect = true;
        characterMesh.add(glow);
        
        glow.userData.animation = (time) => {
            glow.material.opacity = 0.2 + Math.sin(time * 3) * 0.15;
            glow.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
        };
    }

    removeBlockedTeamEffect(characterMesh) {
        const blockedEffects = characterMesh.children.filter(child => 
            child.userData && child.userData.isBlockedEffect
        );
        
        blockedEffects.forEach(effect => {
            characterMesh.remove(effect);
            if (effect.geometry) effect.geometry.dispose();
            if (effect.material) effect.material.dispose();
        });
    }

    fetchBoardStatusAndUpdate() {
        if (GAME_STATE.isCharacterMoving) {
            return;
        }

        fetch("{{ url_for('main.board_status') }}?t=" + new Date().getTime())
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => {
                        throw new Error(errData.error || `Serverfehler: ${response.status}`);
                    }).catch(() => {
                        throw new Error(`Serverfehler: ${response.status} - ${response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                // Debug: Log question data availability
                console.log("🔔 [QUESTION BANNER DEBUG] Board status response question data:", {
                    hasQuestionData: !!data.question_data,
                    questionData: data.question_data
                });
                
                if (data.error) {
                    console.error("Server-Fehler:", data.error);
                    this.showStatusMessage(`Serverproblem: ${data.error}`, 8000, 'error', true, 'Server-Fehler');
                    return;
                }

                if (data.game_session) {
                    // Game trigger logic (same as team_dashboard)
                    
                    // === SEQUENTIAL TURN SYSTEM ===
                    
                    // === MINIGAME RESULTS DISPLAY ===
                    if (data.game_session.current_phase === 'DICE_ROLLING' && lastPhase !== 'DICE_ROLLING' && !hasShowMinigameResults) {
                        console.log("🏆 Phase changed to DICE_ROLLING - adding minigame results to queue with HIGH priority");
                        
                        // Use server teams data (like team dashboard does) instead of localTeams
                        const serverTeams = data.teams || [];
                        
                        // Debug: Check team placements from server
                        console.log("🔍 DEBUG: Server teams check for minigame results:", serverTeams.map(t => ({
                            name: t.name, 
                            placement: t.minigame_placement,
                            placementType: typeof t.minigame_placement,
                            placementIsNull: t.minigame_placement === null,
                            placementIsUndefined: t.minigame_placement === undefined
                        })));
                        
                        // Filter teams with placements
                        const teamsWithPlacements = serverTeams.filter(team => team.minigame_placement);
                        
                        // Don't show normal minigame results during field minigame phases
                        const fieldMinigamePhases = ['FIELD_MINIGAME_SELECTION_PENDING', 'FIELD_MINIGAME_TRIGGERED', 'FIELD_MINIGAME_COMPLETED'];
                        const isFieldMinigameActive = fieldMinigamePhases.includes(currentGamePhase);
                        
                        if (teamsWithPlacements.length > 0 && !hasShownTurnDiceSequence && !isFieldMinigameActive) {
                            console.log("✅ Showing minigame results IMMEDIATELY before turn system");
                            hasShownTurnDiceSequence = true; // Prevent showing again
                            
                            // Show minigame results banner
                            this.showMinigameResults(serverTeams);
                        } else if (isFieldMinigameActive) {
                            console.log("🎯 Field minigame active - skipping normal minigame results banner");
                        }
                        
                        // Process game logic without banners
                        setTimeout(() => {
                            console.log("🔄 Processing game logic after minigame results");
                            const diceResult = data.last_dice_result || window.pendingDiceResult;
                            
                            // Determine current team - prioritize dice result team_id, fallback to current_team_turn_id
                            let currentTeamId = data.game_session.current_team_turn_id;
                            if (diceResult && diceResult.team_id) {
                                currentTeamId = diceResult.team_id;
                                console.log("🎯 Using team ID from dice result:", currentTeamId);
                            }
                            
                            const currentTeam = localTeams.find(t => t.id === currentTeamId);
                            
                            if (currentTeam) {
                                // Update GAME_STATE with correct team
                                GAME_STATE.currentServerTeamTurnId = currentTeamId;
                                
                                // Check for dice result and process movement
                                setTimeout(() => {
                                    console.log("🔍 DEBUG: Checking for dice result:", {
                                        hasDataDiceResult: !!data.last_dice_result,
                                        hasPendingDiceResult: !!window.pendingDiceResult,
                                        diceResult: diceResult,
                                        currentTeamId: currentTeamId,
                                        currentTeamName: currentTeam.name,
                                        dataTimestamp: data.last_dice_result?.timestamp,
                                        pendingTimestamp: window.pendingDiceResult?.timestamp,
                                        currentTime: new Date().toLocaleTimeString(),
                                        diceResultStandardRoll: diceResult?.standard_roll
                                    });
                                    
                                    if (diceResult && diceResult.standard_roll !== undefined) {
                                        console.log("🎲 Processing dice result for team:", currentTeam.name);
                                        
                                        const standardRoll = diceResult.standard_roll || 0;
                                        const bonusRoll = diceResult.bonus_roll || 0;
                                        const totalRoll = diceResult.total_roll || (standardRoll + bonusRoll);
                                        
                                        // 🔍 DEBUG: Server-Response komplett loggen (IMMER ausführen!)
                                        console.log("🔍 DICE RESPONSE DEBUG:", diceResult);
                                        console.log("🔍 Victory triggered:", diceResult.victory_triggered);
                                        console.log("🔍 Needs final roll:", diceResult.needs_final_roll);
                                        console.log("🔍 Current team position:", currentTeam.position);
                                        console.log("🔍 Current team object:", currentTeam);
                                        
                                        // Zeige Würfelergebnis-Notification hier - nur einmal
                                        const notificationKey = `${currentTeam.id}_${diceResult.timestamp || Date.now()}`;
                                        if (window.NotificationSystem && !window.shownDiceNotifications) {
                                            window.shownDiceNotifications = new Set();
                                        }
                                        
                                        if (window.NotificationSystem && !window.shownDiceNotifications.has(notificationKey)) {
                                            console.log("Showing dice notification for " + currentTeam.name + ": " + standardRoll + " + " + bonusRoll + " = " + totalRoll);
                                            window.NotificationSystem.showDiceRoll(currentTeam.name, standardRoll, bonusRoll, totalRoll, 8000);
                                            window.shownDiceNotifications.add(notificationKey);
                                            
                                            // Bereinige alte Einträge nach 30 Sekunden
                                            setTimeout(() => {
                                                window.shownDiceNotifications.delete(notificationKey);
                                            }, 15000);
                                        }
                                        
                                        // ZIELFELD: Victory oder Final Roll Benachrichtigung (IMMER prüfen!)
                                        const victoryNotificationKey = `victory_${currentTeam.id}_${diceResult.timestamp || Date.now()}`;
                                        if (!window.shownVictoryNotifications) {
                                            window.shownVictoryNotifications = new Set();
                                        }
                                        
                                        if (!window.shownVictoryNotifications.has(victoryNotificationKey)) {
                                            if (diceResult.victory_triggered) {
                                                // Team hat gewonnen!
                                                console.log("VICTORY: Team " + currentTeam.name + " hat das Spiel gewonnen!");
                                                window.shownVictoryNotifications.add(victoryNotificationKey);
                                                setTimeout(() => {
                                                    window.NotificationSystem.showFinalRollSuccess(currentTeam.name, totalRoll, 6000);
                                                }, 1000);
                                                setTimeout(() => {
                                                    this.handleVictory(currentTeam, this.miiCharacters[currentTeam.id]);
                                                }, 2000);
                                            } else if (diceResult.needs_final_roll) {
                                                // Team steht auf Zielfeld, braucht aber mindestens 6
                                                console.log("FINAL FIELD: Team " + currentTeam.name + " auf Zielfeld - braucht mindestens 6");
                                                window.shownVictoryNotifications.add(victoryNotificationKey);
                                                setTimeout(() => {
                                                    window.NotificationSystem.showFinalRollNeeded(currentTeam.name, totalRoll, 8000);
                                                }, 1000);
                                                // ✅ CAMERA ORBIT FIX: Starte Kamera-Orbit nach fehlgeschlagenem Victory-Versuch
                                                console.log("🎥 Starting camera orbit after failed victory attempt");
                                                setTimeout(() => {
                                                    if (typeof startCameraOrbitAnimation === 'function') {
                                                        startCameraOrbitAnimation(false);
                                                    } else {
                                                        console.warn("startCameraOrbitAnimation function not available");
                                                    }
                                                }, 2000); // Start orbit after notification
                                            } else if (currentTeam.position === 72) {
                                                // DEBUG: Team ist auf 72 aber keine Victory-Flags gesetzt
                                                console.log("DEBUG: Team " + currentTeam.name + " auf Position 72, aber keine Victory-Flags in Response!");
                                            }
                                        }
                                        
                                        // Clear pending dice result to prevent showing again
                                        window.pendingDiceResult = null;
                                        
                                        // Focus camera and allow movement
                                        setTimeout(() => {
                                            console.log("🎯 Focusing camera and allowing movement for:", currentTeam.name);
                                            this.requestCameraMode('team_focus', {team: currentTeam}, 'normal');
                                        }, 200);
                                    } else {
                                        // No dice result yet, just focus camera
                                        console.log("🎯 Focusing camera (no dice yet) for:", currentTeam.name);
                                        this.requestCameraMode('team_focus', {team: currentTeam}, 'normal');
                                        
                                        // ✅ FINAL FIELD: Check if team is on final field and show reminder
                                        if (currentTeam.position === 72) {
                                            console.log("🎯 Team on final field - showing reminder");
                                            setTimeout(() => {
                                                this.showStatusMessage(`${currentTeam.name} steht auf dem ZIELFELD - braucht mindestens 6 zum Gewinnen!`, 4000, 'warning', true, 'Zielfeld erreicht');
                                                
                                                // Also show notification
                                                if (window.NotificationSystem) {
                                                    setTimeout(() => {
                                                        const notification = window.NotificationSystem.createNotification({
                                                            type: 'final-field-reminder',
                                                            icon: '🎯',
                                                            title: `${currentTeam.name} - Zielfeld erreicht!`,
                                                            message: `Muss mindestens 6 würfeln um zu gewinnen!`,
                                                            duration: 6000
                                                        });
                                                        window.NotificationSystem.showNotification(notification);
                                                    }, 500);
                                                }
                                            }, 1000);
                                        }
                                    }
                                }, 1000); // Reduced timing
                            } else {
                                console.warn("❌ No team found for ID:", currentTeamId);
                            }
                        }, 2000); // Process game logic timing
                        
                        hasShowMinigameResults = true;
                    } else if (data.game_session.current_phase !== 'DICE_ROLLING') {
                        hasShowMinigameResults = false;
                        hasShownTurnDiceSequence = false; // Reset for next minigame
                        window.pendingDiceResult = null; // Clear old dice results
                    }
                    
                    // 2. Round End System - simplified logic
                    
                    // 3. QUEUE-BASIERTES TURN SYSTEM - DEAKTIVIERT nach Minigame Results
                    // WICHTIG: Wird jetzt direkt nach Minigame Results gehandhabt!
                    // if (!GAME_STATE.isCharacterMoving && !GAME_STATE.isAnimating) {
                    //     this.processQueueBasedTurnSystem(data);
                    // }

                    // Update tracking variables
                    const newPhase = data.game_session.current_phase || "UNKNOWN";
                    
                    // Reset field minigame banner flag when leaving field minigame phases
                    const fieldMinigamePhases = ['FIELD_MINIGAME_SELECTION_PENDING', 'FIELD_MINIGAME_TRIGGERED', 'FIELD_MINIGAME_COMPLETED'];
                    if (fieldMinigamePhases.includes(lastPhase) && !fieldMinigamePhases.includes(newPhase)) {
                        console.log('🎯 Field Minigame Phase verlassen - Banner verstecken und Flags zurücksetzen');
                        hideFieldMinigameBanner();
                        fieldMinigameBannerShown = false;
                        lastShownMinigameData = null;
                    }
                    
                    lastPhase = newPhase;
                    lastTeamTurnId = data.game_session.current_team_turn_id;
                    
                    // Update global state variables
                    currentMinigameName = data.game_session.current_minigame_name;
                    currentMinigameDescription = data.game_session.current_minigame_description;
                    currentGamePhase = data.game_session.current_phase;
                    
                    // Question Banner Management
                    this.updateQuestionBanner(data.game_session);
                    
                    // Minigame Announcement Banner Management
                    this.updateMinigameBanner(data.game_session);

                    this.updateMinigameDisplay();

                    GAME_STATE.currentServerTeamTurnId = data.game_session.current_team_turn_id;
                    
                    if (typeof data.game_session.dice_roll_order === 'string' && data.game_session.dice_roll_order.length > 0) {
                        GAME_STATE.diceRollOrderFromServer = data.game_session.dice_roll_order.split(',');
                    } else if (Array.isArray(data.game_session.dice_roll_order)) {
                        GAME_STATE.diceRollOrderFromServer = data.game_session.dice_roll_order;
                    } else {
                        GAME_STATE.diceRollOrderFromServer = [];
                    }

                    if (data.teams && Array.isArray(data.teams)) {
                        let teamWhosePositionChanged = null;
                        let newPositionForAnimation = 0;
                        let oldPositionForAnimation = 0;

                        // NEUE SWAP-ERKENNUNG: Prüfe ob zwei Teams gleichzeitig ihre Positionen tauschen
                        const positionChanges = [];
                        data.teams.forEach(serverTeam => {
                            const localTeam = localTeams.find(t => t.id === serverTeam.id);
                            if (localTeam && localTeam.position !== serverTeam.position) {
                                positionChanges.push({
                                    team: localTeam,
                                    oldPos: localTeam.position,
                                    newPos: serverTeam.position
                                });
                            }
                        });
                        
                        // Erkenne Player Swap: Wenn genau 2 Teams ihre Positionen tauschen
                        let swapDetected = false;
                        if (positionChanges.length === 2) {
                            const [change1, change2] = positionChanges;
                            if (change1.oldPos === change2.newPos && change1.newPos === change2.oldPos) {
                                swapDetected = true;
                                console.log("SWAP DETECTION - Player swap detected!", {
                                    team1: change1.team.name,
                                    team1_move: change1.oldPos + " -> " + change1.newPos,
                                    team2: change2.team.name,
                                    team2_move: change2.oldPos + " -> " + change2.newPos
                                });
                                
                                // Starte sofort die Swap-Animation
                                this.startImmediatePlayerSwap(change1.team.name, change2.team.name, {
                                    current_team_new_position: change1.newPos,
                                    swap_team_new_position: change2.newPos
                                });
                            }
                        }
                        
                        // Normale Position-Updates nur wenn KEIN Swap erkannt wurde
                        if (!swapDetected) {
                            data.teams.forEach(serverTeam => {
                                const localTeam = localTeams.find(t => t.id === serverTeam.id);
                                if (localTeam) {
                                    if (localTeam.position !== serverTeam.position) {
                                        console.log("Position change detected: Team " + serverTeam.id + " (" + localTeam.name + ") from position " + localTeam.position + " to " + serverTeam.position);
                                        console.log(`🏃 Movement conditions: isCharacterMoving=${GAME_STATE.isCharacterMoving}, activeMovementAnimation=${!!this.activeMovementAnimation}, characterExists=${!!this.miiCharacters[serverTeam.id]}`);
                                    }
                                    
                                    // SWAP-SCHUTZ: Blockiere normale Bewegung für Teams die beim Tausch beteiligt sind
                                    const isInvolvedInSwap = this.swapInProgress && this.swapTeams && this.swapTeams.includes(localTeam.name);
                                    
                                    if (localTeam.position !== serverTeam.position) {
                                        console.log("🔴 [MOVEMENT DEBUG] Position change for", localTeam.name, ":", {
                                            from: localTeam.position,
                                            to: serverTeam.position,
                                            isCharacterMoving: GAME_STATE.isCharacterMoving,
                                            activeMovementAnimation: !!this.activeMovementAnimation,
                                            isInvolvedInSwap: isInvolvedInSwap,
                                            swapInProgress: this.swapInProgress,
                                            swapTeams: this.swapTeams
                                        });
                                    }
                                    
                                    if (localTeam.position !== serverTeam.position &&
                                        !GAME_STATE.isCharacterMoving &&
                                        (!this.activeMovementAnimation || this.activeMovementAnimation.teamId !== localTeam.id) &&
                                        !isInvolvedInSwap  // NEUE BEDINGUNG: Keine normale Bewegung während Tausch
                                    ) {
                                        teamWhosePositionChanged = localTeam;
                                        oldPositionForAnimation = localTeam.position;
                                        newPositionForAnimation = serverTeam.position;
                                        console.log(`✅ Movement will be triggered for team ${localTeam.name}`);
                                    } else if (isInvolvedInSwap) {
                                        console.log(`🔴 [SWAP DEBUG] Blocking normal movement for ${localTeam.name} - involved in swap`);
                                    }
                                    
                                    // WICHTIG: Verzögere Position-Update für Teams im Tausch bis Animation fertig ist
                                    if (!isInvolvedInSwap) {
                                        localTeam.position = serverTeam.position;
                                    } else {
                                        // Speichere finale Position für später aber update noch nicht die lokalTeam.position
                                        localTeam.finalSwapPosition = serverTeam.position;
                                        console.log(`🔄 [SWAP DEBUG] Delaying position update for ${localTeam.name}: current=${localTeam.position} -> final=${localTeam.finalSwapPosition}`);
                                    }
                                localTeam.bonus_dice_sides = serverTeam.bonus_dice_sides;
                                localTeam.minigame_placement = serverTeam.minigame_placement;
                                
                                const wasBlocked = localTeam.is_blocked;
                                localTeam.is_blocked = serverTeam.is_blocked || false;
                                localTeam.blocked_target_number = serverTeam.blocked_target_number || null;
                                
                                const character = this.miiCharacters[localTeam.id];
                                if (character) {
                                    if (!wasBlocked && localTeam.is_blocked) {
                                        this.addBlockedTeamEffect(character);
                                    } else if (wasBlocked && !localTeam.is_blocked) {
                                        this.removeBlockedTeamEffect(character);
                                    }
                                }
                            }
                        });

                        this.updateAllTeamBadges();

                        if (teamWhosePositionChanged && this.miiCharacters[teamWhosePositionChanged.id]) {
                            console.log(`🎯 Ready to move team ${teamWhosePositionChanged.name}, checking final conditions...`);
                            if (!GAME_STATE.isCharacterMoving) {
                                console.log(`🚀 Starting movement animation for team ${teamWhosePositionChanged.name}`);
                                this.activeMovementAnimation = { teamId: teamWhosePositionChanged.id };
                                this.animateCharacterToNewPosition(teamWhosePositionChanged, oldPositionForAnimation, newPositionForAnimation);
                            } else {
                                console.log(`🚫 Final check failed: GAME_STATE.isCharacterMoving = ${GAME_STATE.isCharacterMoving}`);
                            }
                        } else {
                            if (teamWhosePositionChanged && !this.miiCharacters[teamWhosePositionChanged.id]) {
                                console.log(`🚫 Character object missing for team ${teamWhosePositionChanged.name} (ID: ${teamWhosePositionChanged.id})`);
                                console.log(`🚫 Available characters:`, Object.keys(this.miiCharacters || {}));
                            }
                        }
                    }
                }

                    // Process special field events with banners
                    if (data.special_field_event) {
                        console.log("🎯 Special field event detected:", data.special_field_event);
                        
                        if (data.special_field_event.type === 'barrier_set') {
                            console.log("🚧 Barrier set for team");
                        } else if (data.special_field_event.type === 'barrier_released') {
                            const message = `Du hast dich befreit! Würfel: ${data.special_field_event.dice_roll}`;
                            console.log("✅ Barrier released:", message);
                        } else if (data.special_field_event.type === 'barrier_failed') {
                            const message = `Noch blockiert! Würfel: ${data.special_field_event.dice_roll}`;
                            console.log("❌ Barrier failed:", message);
                        }
                    }
                    
                    // Handle special field actions with banners
                    if (data.special_field) {
                        console.log("🔴 [DEBUG] Found data.special_field:", data.special_field);
                        handleSpecialFieldResponse(data);
                    }
                    
                    // Handle special field events (alternative format)
                    if (data.special_field_event) {
                        console.log("🔴 [DEBUG] Found data.special_field_event:", data.special_field_event);
                        
                        // Convert special_field_event to special_field format
                        if (data.special_field_event.type === 'player_swap') {
                            // Finde Team-Namen basierend auf IDs
                            const currentTeam = localTeams?.find(t => t.id === data.special_field_event.current_team_id);
                            const swapTeam = localTeams?.find(t => t.id === data.special_field_event.swap_team_id);
                            
                            const convertedData = {
                                ...data,
                                team_name: currentTeam?.name || 'Unknown Team',
                                special_field: {
                                    success: true,
                                    action: 'player_swap',
                                    swap_team_name: swapTeam?.name || data.special_field_event.swap_team_name || 'Unknown Team',
                                    final_positions: data.special_field_event.final_positions
                                }
                            };
                            console.log("🔴 [DEBUG] Converted special_field_event to special_field format:", convertedData);
                            handleSpecialFieldResponse(convertedData);
                        }
                    }
                    
                    // Handle barrier checks with banners
                    if (data.barrier_check) {
                        handleBarrierCheckResponse(data);
                    }

                    // Process dice results with improved notification logic (once only)
                    if (data.last_dice_result && JSON.stringify(data.last_dice_result) !== JSON.stringify(lastDiceResult)) {
                        console.log("🎲 New dice result from server:", data.last_dice_result);
                        
                        // Store dice result with team information for use in minigame sequence
                        window.pendingDiceResult = data.last_dice_result;
                        
                        // Update current team turn ID to match dice result
                        if (data.last_dice_result.team_id) {
                            console.log("🎯 Setting current team from dice result:", data.last_dice_result.team_id);
                            GAME_STATE.currentServerTeamTurnId = data.last_dice_result.team_id;
                        }
                        
                        // Handle barrier checks for blocked teams
                        if (data.last_dice_result.was_blocked) {
                            console.log("🚧 Team was blocked, checking barrier status...");
                            const diceResult = data.last_dice_result;
                            const teamName = localTeams?.find(t => t.id === diceResult.team_id)?.name || 'Unknown Team';
                            
                            if (diceResult.barrier_released) {
                                // Team was freed - show release notification
                                console.log("🎉 Team was released from barrier!");
                                if (window.NotificationSystem) {
                                    window.NotificationSystem.showBarrierReleased(
                                        teamName, 
                                        diceResult.standard_roll, 
                                        diceResult.bonus_roll || 0,
                                        'total'
                                    );
                                }
                            } else {
                                // Team is still blocked - show failed notification
                                console.log("❌ Team is still blocked!");
                                const barrierText = diceResult.barrier_display_text || "Höhere Zahl benötigt";
                                if (window.NotificationSystem) {
                                    console.log("📱 Calling showBarrierFailed with barrier text:", barrierText);
                                    window.NotificationSystem.showBarrierFailed(
                                        teamName,
                                        diceResult.standard_roll,
                                        diceResult.bonus_roll || 0,
                                        barrierText
                                    );
                                }
                            }
                        }
                        
                        // Show dice notification using timestamp-based deduplication (improved logic)
                        const timestamp = data.last_dice_result.timestamp;
                        const notificationKey = `dice_${timestamp}`;
                        
                        if (!window.shownDiceNotifications) {
                            window.shownDiceNotifications = new Set();
                        }
                        
                        // Always try to show notification if not already shown
                        if (window.NotificationSystem && !window.shownDiceNotifications.has(notificationKey)) {
                            // Find current team
                            const currentTeamId = data.last_dice_result.team_id || GAME_STATE.currentServerTeamTurnId || data.game_session?.current_team_turn_id;
                            const currentTeam = localTeams?.find(t => t.id === currentTeamId);
                            
                            if (currentTeam) {
                                const standardRoll = data.last_dice_result.standard_roll || 0;
                                const bonusRoll = data.last_dice_result.bonus_roll || 0;
                                const totalRoll = data.last_dice_result.total_roll || (standardRoll + bonusRoll);
                                
                                console.log(`🎲 Showing dice notification for ${currentTeam.name}: ${standardRoll} + ${bonusRoll} = ${totalRoll}`);
                                window.NotificationSystem.showDiceRoll(currentTeam.name, standardRoll, bonusRoll, totalRoll, 8000);
                                window.shownDiceNotifications.add(notificationKey);
                                
                                // ZIELFELD: Victory oder Final Roll Benachrichtigung
                                if (data.last_dice_result.victory_triggered) {
                                    // Team hat gewonnen!
                                    console.log(`🏆 VICTORY: Team ${currentTeam.name} hat das Spiel gewonnen!`);
                                    setTimeout(() => {
                                        window.NotificationSystem.showFinalRollSuccess(currentTeam.name, totalRoll, 6000);
                                    }, 1000); // Nach der Dice-Notification
                                    setTimeout(() => {
                                        this.handleVictory(currentTeam, this.miiCharacters[currentTeam.id]);
                                    }, 2000); // Kurz nach der Success-Notification
                                } else if (data.last_dice_result.needs_final_roll) {
                                    // Team steht auf Zielfeld, braucht aber mindestens 6
                                    console.log(`🎯 FINAL FIELD: Team ${currentTeam.name} auf Zielfeld - braucht mindestens 6`);
                                    setTimeout(() => {
                                        window.NotificationSystem.showFinalRollNeeded(currentTeam.name, totalRoll, 8000);
                                    }, 1000); // Nach der Dice-Notification
                                    
                                    // ✅ CAMERA ORBIT FIX: Starte Kamera-Orbit nach fehlgeschlagenem Victory-Versuch
                                    console.log("🎥 Starting camera orbit after failed victory attempt (live updates)");
                                    setTimeout(() => {
                                        if (typeof startCameraOrbitAnimation === 'function') {
                                            startCameraOrbitAnimation(false);
                                        } else {
                                            console.warn("startCameraOrbitAnimation function not available");
                                        }
                                    }, 2000); // Start orbit after notification
                                }
                                
                                // Clean up after 15 seconds (TEST MODE - longer than backend timeout)
                                setTimeout(() => {
                                    window.shownDiceNotifications.delete(notificationKey);
                                }, 15000);
                            } else {
                                console.warn("🎲 Could not find team for dice notification:", {
                                    teamId: currentTeamId,
                                    localTeams: localTeams?.map(t => ({id: t.id, name: t.name}))
                                });
                            }
                        } else if (window.shownDiceNotifications.has(notificationKey)) {
                            // Silent skip - no more logging spam
                        } else if (!window.NotificationSystem) {
                            console.error("❌ NotificationSystem not available for dice result!");
                        }
                        
                        // Update lastDiceResult for comparison in next call
                        lastDiceResult = data.last_dice_result;
                    }

                    // Process special field events (catapult, barrier, player swap)
                    if (data.last_special_field_event && JSON.stringify(data.last_special_field_event) !== JSON.stringify(window.lastSpecialFieldEvent)) {
                        console.log("🔥 New special field event from server:", data.last_special_field_event);
                        
                        const specialEvent = data.last_special_field_event;
                        const timestamp = specialEvent.timestamp;
                        const notificationKey = `special_${specialEvent.event_type}_${timestamp}`;
                        
                        if (!window.shownSpecialNotifications) {
                            window.shownSpecialNotifications = new Set();
                        }
                        
                        // Show notification if not already shown
                        if (window.NotificationSystem && !window.shownSpecialNotifications.has(notificationKey)) {
                            // Find team for the event
                            const eventTeamId = specialEvent.team_id;
                            const eventTeam = localTeams?.find(t => t.id === eventTeamId);
                            
                            if (eventTeam) {
                                // Process different types of special field events
                                if (specialEvent.event_type === 'special_field_catapult_forward') {
                                    const distance = specialEvent.data.catapult_distance || 5;
                                    console.log(`🚀 Showing catapult forward notification for ${eventTeam.name}: ${distance} fields`);
                                    window.NotificationSystem.showCatapultForward(eventTeam.name, distance, 8000);
                                    
                                } else if (specialEvent.event_type === 'special_field_catapult_backward') {
                                    const distance = specialEvent.data.catapult_distance || 5;
                                    console.log(`💥 Showing catapult backward notification for ${eventTeam.name}: ${distance} fields`);
                                    window.NotificationSystem.showCatapultBackward(eventTeam.name, distance, 8000);
                                    
                                } else if (specialEvent.event_type === 'special_field_player_swap') {
                                    // Get team names from event data
                                    const currentTeamId = specialEvent.data.current_team_id;
                                    const currentTeamName = specialEvent.data.current_team_name;
                                    const swapTeamId = specialEvent.data.swap_team_id;
                                    
                                    // Find the swap team name from local teams
                                    const swapTeam = localTeams?.find(t => t.id === swapTeamId);
                                    const swapTeamName = swapTeam?.name || `Team ${swapTeamId}`;
                                    
                                    // Create unique notification key to prevent duplicates
                                    const swapKey = `${currentTeamId}_${swapTeamId}_${timestamp}`;
                                    
                                    if (!window.shownPlayerSwapNotifications) {
                                        window.shownPlayerSwapNotifications = new Set();
                                    }
                                    
                                    if (!window.shownPlayerSwapNotifications.has(swapKey)) {
                                        console.log(`🔄 Showing player swap notification: ${currentTeamName} <-> ${swapTeamName}`);
                                        window.NotificationSystem.showPlayerSwap(currentTeamName, swapTeamName, 8000);
                                        window.shownPlayerSwapNotifications.add(swapKey);
                                        
                                        // DEAKTIVIERT: Animation wird jetzt über Position-Detection gestartet
                                        console.log(`🔴 [SWAP DEBUG] Swap event detected - animation will be handled by position detection`);
                                        // Animation wird automatisch durch Position-Detection im fetchBoardStatusAndUpdate gestartet
                                        
                                        // Remove from set after some time to allow future swaps
                                        setTimeout(() => {
                                            window.shownPlayerSwapNotifications.delete(swapKey);
                                        }, 10000);
                                    } else {
                                        console.log(`🔄 [DEBUG] Player swap notification already shown for this pair`);
                                    }
                                    
                                } else if (specialEvent.event_type === 'special_field_barrier_set') {
                                    const requiredNumber = specialEvent.data.required_number || 4;
                                    console.log(`🚧 Showing barrier set notification for ${eventTeam.name}: needs ${requiredNumber}+`);
                                    window.NotificationSystem.showBarrierSet(eventTeam.name, requiredNumber, 8000);
                                    
                                } else if (specialEvent.event_type === 'special_field_barrier_released') {
                                    const diceRoll = specialEvent.data.dice_roll || 0;
                                    const bonusRoll = specialEvent.data.bonus_roll || 0;
                                    const method = specialEvent.data.release_method || 'standard';
                                    console.log(`🎉 Showing barrier released notification for ${eventTeam.name}`);
                                    window.NotificationSystem.showBarrierReleased(eventTeam.name, diceRoll, bonusRoll, method, 8000);
                                    
                                } else if (specialEvent.event_type === 'special_field_barrier_blocked') {
                                    const diceRoll = specialEvent.data.dice_roll || 0;
                                    const bonusRoll = specialEvent.data.bonus_roll || 0;
                                    const requiredText = specialEvent.data.barrier_config?.display_text || "Höhere Zahl benötigt";
                                    console.log(`🚧 Showing barrier blocked notification for ${eventTeam.name}`);
                                    window.NotificationSystem.showBarrierFailed(eventTeam.name, diceRoll, bonusRoll, requiredText, 8000);
                                    
                                } else if (specialEvent.event_type === 'field_minigame_completed') {
                                    const result = specialEvent.data.result;
                                    if (result === 'won') {
                                        const forwardFields = specialEvent.data.reward_forward || 5;
                                        console.log(`🏆 Showing field minigame win notification for ${eventTeam.name}`);
                                        window.NotificationSystem.showFieldMinigameWin(eventTeam.name, forwardFields, 8000);
                                    } else if (result === 'lost') {
                                        console.log(`💔 Showing field minigame loss notification for ${eventTeam.name}`);
                                        window.NotificationSystem.showFieldMinigameLoss(eventTeam.name, 8000);
                                    }
                                    
                                    // Nach Minigame-Feld Abschluss: Kamera zum nächsten Spieler schwenken
                                    // Warte bis alle Bewegungen abgeschlossen sind
                                    const waitForMovementCompletion = () => {
                                        if (GAME_STATE.isCharacterMoving || GAME_STATE.isAnimating || this.activeMovementAnimation) {
                                            console.log("🎯 [CAMERA] Waiting for movement to complete before switching to next team...");
                                            setTimeout(waitForMovementCompletion, 500);
                                            return;
                                        }
                                        
                                        const gameSession = data.game_session;
                                        if (gameSession && gameSession.current_team_turn_id) {
                                            const nextTeamId = gameSession.current_team_turn_id;
                                            const nextTeam = localTeams?.find(t => t.id === nextTeamId);
                                            
                                            if (nextTeam) {
                                                console.log("🎯 [CAMERA] Next team after field minigame completion (movement finished):", nextTeam.name);
                                                
                                                // Update game state to the next team
                                                GAME_STATE.currentServerTeamTurnId = nextTeamId;
                                                const nextTeamIndex = localTeams.findIndex(t => t.id === nextTeamId);
                                                if (nextTeamIndex !== -1) {
                                                    GAME_STATE.currentTeamIndex = nextTeamIndex;
                                                }
                                                
                                                // Focus camera on next team with smooth transition
                                                this.requestCameraMode('team_focus', {team: this.teams[this.currentTurn]}, 'normal');
                                            }
                                        }
                                    };
                                    
                                    setTimeout(waitForMovementCompletion, 3000); // 3 Sekunden warten, dann auf Movement-Ende prüfen
                                }
                                
                                window.shownSpecialNotifications.add(notificationKey);
                                
                                // Clean up after 15 seconds (TEST MODE - longer than backend timeout)
                                setTimeout(() => {
                                    window.shownSpecialNotifications.delete(notificationKey);
                                }, 15000);
                                
                            } else {
                                console.warn("🔥 Could not find team for special field notification:", {
                                    teamId: eventTeamId,
                                    localTeams: localTeams?.map(t => ({id: t.id, name: t.name}))
                                });
                            }
                        } else if (window.shownSpecialNotifications.has(notificationKey)) {
                            // Silent skip - no logging spam
                        } else if (!window.NotificationSystem) {
                            console.error("❌ NotificationSystem not available for special field event!");
                        }
                        
                        // Update lastSpecialFieldEvent for comparison in next call
                        window.lastSpecialFieldEvent = data.last_special_field_event;
                    }

                    this.updateTeamDisplay();
                    
                    // === CAMERA UPDATES AFTER FIELD MINIGAME ===
                    this.handlePostMinigameCameraUpdates(data.game_session);
                }
            })
            .catch(error => {
                console.error("Fehler beim Board-Status:", error);
                
                // Reduziere Logging-Frequenz bei NetworkErrors
                if (error.name === 'TypeError' && error.message.includes('NetworkError')) {
                    console.warn("⚠️ Network connection issue - retrying in 5 seconds");
                    // Versuche nach 5 Sekunden erneut
                    setTimeout(() => {
                        this.updateBoardStatus();
                    }, 5000);
                } else {
                    this.showStatusMessage(`Verbindungsproblem: ${error.message}`, 3000, "error", true, 'Verbindungsfehler');
                }
            });
    }

    updateQuestionBanner(gameSession) {
        const banner = document.getElementById('question-banner');
        console.log('🔔 [QUESTION BANNER] updateQuestionBanner called:', {
            bannerExists: !!banner,
            currentPhase: gameSession.current_phase,
            questionId: gameSession.current_question_id
        });
        
        if (!banner) {
            console.error('❌ [QUESTION BANNER] Banner element not found!');
            return;
        }
        
        // Show banner when question phase is active
        if (gameSession.current_phase === 'QUESTION_ACTIVE' && gameSession.current_question_id) {
            console.log('✅ [QUESTION BANNER] Question active - fetching data and showing banner');
            this.fetchQuestionDataForBanner();
            banner.classList.add('show');
            
            // Debug: Check banner visibility
            const computedStyle = window.getComputedStyle(banner);
            console.log('🔔 [QUESTION BANNER DEBUG] Banner visibility:', {
                display: banner.style.display,
                computedDisplay: computedStyle.display,
                visibility: computedStyle.visibility,
                opacity: computedStyle.opacity,
                zIndex: computedStyle.zIndex,
                position: computedStyle.position,
                top: computedStyle.top,
                left: computedStyle.left,
                right: computedStyle.right,
                width: computedStyle.width,
                height: computedStyle.height,
                offsetWidth: banner.offsetWidth,
                offsetHeight: banner.offsetHeight,
                clientWidth: banner.clientWidth,
                clientHeight: banner.clientHeight
            });
        } else {
            console.log('🔔 [QUESTION BANNER] Hiding banner - phase not active');
            banner.classList.remove('show');
        }
    }

    fetchQuestionDataForBanner() {
        console.log('🔔 [QUESTION BANNER] Fetching question data from dedicated API');
        fetch(`{{ url_for('main.question_status_for_gameboard') }}?t=${new Date().getTime()}`)
            .then(response => {
                console.log('🔔 [QUESTION BANNER] API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('🔔 [QUESTION BANNER] Question data received:', data);
                console.log('🔔 [QUESTION BANNER] Raw debug data:', data.debug_raw_data);
                if (data.question_active && data.question) {
                    console.log('✅ [QUESTION BANNER] Updating banner with question data');
                    this.updateBannerContent(data.question, data.answers);
                } else {
                    console.log('⚠️ [QUESTION BANNER] Question not active:', data.message);
                }
            })
            .catch(error => {
                console.error("❌ [QUESTION BANNER] Error fetching question data:", error);
            });
    }


    updateBannerContent(question, answers) {
        console.log('🔔 [QUESTION BANNER] updateBannerContent called:', { question, answers });
        
        const titleElement = document.getElementById('banner-question-title');
        const timerElement = document.getElementById('banner-question-timer');
        const contentElement = document.getElementById('banner-question-content');
        
        console.log('🔔 [QUESTION BANNER] Banner elements found:', {
            title: !!titleElement,
            timer: !!timerElement,
            content: !!contentElement
        });
        
        if (titleElement) titleElement.textContent = question.title || 'Aktuelle Frage';
        if (timerElement) timerElement.textContent = 'Läuft...';
        
        if (contentElement) {
            let html = `<div style="margin-bottom: 1.5rem; font-size: 1.8rem; font-weight: bold; line-height: 1.3;"><strong>${question.text || 'Keine Frage verfügbar'}</strong></div>`;
            
            console.log('🔔 [QUESTION BANNER] Question text:', question.text);
            console.log('🔔 [QUESTION BANNER] Answers array:', answers);
            console.log('🔔 [QUESTION BANNER] Answers length:', answers ? answers.length : 'null/undefined');
            
            if (answers && answers.length > 0) {
                html += '<div style="margin-bottom: 1rem; font-size: 1.4rem; font-weight: bold;">Antwortmöglichkeiten:</div>';
                html += '<div>';
                answers.forEach((answer, index) => {
                    console.log(`🔔 [QUESTION BANNER] Answer ${index}:`, answer);
                    html += `<div style="margin: 0.5rem 0.3rem; padding: 0.8rem 1.2rem; background: rgba(255,255,255,0.25); border-radius: 20px; display: inline-block; font-size: 1.3rem; font-weight: 600; border: 2px solid rgba(255,255,255,0.3);">${String.fromCharCode(65 + index)}: ${answer}</div>`;
                });
                html += '</div>';
            } else if (question.type === 'text_input') {
                html += '<div style="font-style: italic; opacity: 0.9; font-size: 1.3rem; margin-top: 1rem;">💬 Freitext-Antwort erforderlich</div>';
            }
            
            contentElement.innerHTML = html;
            console.log('✅ [QUESTION BANNER] Banner content updated successfully');
        }
    }

    updateMinigameBanner(gameSession) {
        const banner = document.getElementById('minigame-announcement-banner');
        console.log('🎮 [MINIGAME BANNER] updateMinigameBanner called:', {
            bannerExists: !!banner,
            currentPhase: gameSession.current_phase,
            minigameName: gameSession.current_minigame_name,
            minigameDescription: gameSession.current_minigame_description
        });
        
        if (!banner) {
            console.error('❌ [MINIGAME BANNER] Banner element not found!');
            return;
        }
        
        // Field Minigame Phases - don't interfere with field minigame banner system
        const fieldMinigamePhases = ['FIELD_MINIGAME_SELECTION_PENDING', 'FIELD_MINIGAME_TRIGGERED'];
        if (fieldMinigamePhases.includes(gameSession.current_phase)) {
            console.log('🎯 [MINIGAME BANNER] Skipping - field minigame phase detected:', gameSession.current_phase);
            return;
        }
        
        // Show banner when in MINIGAME_ANNOUNCED phase with minigame data
        if (gameSession.current_phase === 'MINIGAME_ANNOUNCED' && gameSession.current_minigame_name) {
            console.log('✅ [MINIGAME BANNER] Showing minigame announcement banner');
            this.showMinigameAnnouncement(gameSession.current_minigame_name, gameSession.current_minigame_description);
        } else if (gameSession.current_phase !== 'MINIGAME_ANNOUNCED') {
            console.log('🔔 [MINIGAME BANNER] Hiding banner - phase not MINIGAME_ANNOUNCED');
            banner.classList.remove('show');
        }
    }

    showMinigameAnnouncement(name, description) {
        console.log('🎮 [MINIGAME BANNER] Showing announcement:', { name, description });
        const banner = document.getElementById('minigame-announcement-banner');
        const nameEl = document.getElementById('minigame-banner-name');
        const descEl = document.getElementById('minigame-banner-description');
        
        if (banner && nameEl && descEl) {
            // Set content with larger, bold styling
            nameEl.innerHTML = `<div style="font-size: 2.2rem; font-weight: bold; margin-bottom: 0.5rem;">${name || 'Unbekanntes Minispiel'}</div>`;
            descEl.innerHTML = `<div style="font-size: 1.6rem; font-weight: 600; line-height: 1.3; margin-top: 0.8rem;">${description || 'Bereitet euch vor!'}</div>`;
            
            banner.classList.add('show');
            console.log('✅ [MINIGAME BANNER] Banner shown - will stay until phase change');
        } else {
            console.error('❌ [MINIGAME BANNER] Missing banner elements');
        }
    }

    showMinigameResults(teams) {
        const banner = document.getElementById('minigame-results-banner');
        const resultsList = document.getElementById('minigame-results-list');
        
        console.log('🏆 [MINIGAME RESULTS] Showing results banner with teams:', teams);
        
        if (banner && resultsList) {
            const teamsWithPlacements = teams
                .filter(team => team.minigame_placement)
                .sort((a, b) => a.minigame_placement - b.minigame_placement);
            
            console.log('🏆 [MINIGAME RESULTS] Teams with placements:', teamsWithPlacements);
            
            resultsList.innerHTML = '';
            teamsWithPlacements.forEach(team => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                
                let medalIcon = '';
                if (team.minigame_placement === 1) medalIcon = '🥇';
                else if (team.minigame_placement === 2) medalIcon = '🥈';
                else if (team.minigame_placement === 3) medalIcon = '🥉';
                else medalIcon = `${team.minigame_placement}.`;
                
                resultItem.innerHTML = `${medalIcon} ${team.name}`;
                resultsList.appendChild(resultItem);
            });
            
            banner.classList.add('show');
            console.log('🏆 [MINIGAME RESULTS] Banner shown');
            
            setTimeout(() => {
                banner.classList.add('hide');
                setTimeout(() => {
                    banner.classList.remove('show', 'hide');
                    console.log('🏆 [MINIGAME RESULTS] Banner hidden');
                }, 500);
            }, 5000);
        }
    }

    updateAllTeamBadges() {}
    updateTeamBadgeForTeam(teamId, position) {}

    animateCharacterToNewPosition(team, oldPositionIndex, newPositionIndex) {
        console.log(`🎯 ANIMATION START: ${team.name} von Position ${oldPositionIndex} nach ${newPositionIndex}`);
        console.log(`🎯 Board hat ${this.boardFields.length} Felder`);
        
        const mii = this.miiCharacters[team.id];
        if (!mii) {
            console.error(`❌ Kein Charakter für Team ${team.id}`);
            this.handleMovementCompletion(team, null, newPositionIndex);
            return;
        }
        
        if (oldPositionIndex === newPositionIndex) {
            const targetField = this.boardFields[newPositionIndex];
            if (targetField && targetField.mesh) {
                mii.position.copy(targetField.mesh.position);
                mii.position.y += BOARD_CONFIG.characterElevation;
            }
            this.handleMovementCompletion(team, mii, newPositionIndex);
            return;
        }

        GAME_STATE.isCharacterMoving = true;
        GAME_STATE.isAnimating = true;
        
        // Mark in turn sequence that movement started
        turnSequenceState.isMoving = true;
        console.log("🚫 Movement started for", team.name);
        
        // Trigger auto camera following for player movement
        if (GAME_STATE.autoCameraEnabled) {
            console.log("📹 Triggering auto camera following for movement");
            GAME_STATE.isPlayerActive = true;
            GAME_STATE.lastPlayerActivity = Date.now();
            GAME_STATE.playerFocusTarget = mii;
        }
        
        // Start camera following during movement (immer aktiv für alle Bewegungen)
        console.log(`📹 Starting GTA-like camera follow for ${team.name} movement`);
        this.startCameraFollow(mii);
        
        // Aktiviere Auto-Kamera für diese Bewegung
        GAME_STATE.autoCameraEnabled = true;
        GAME_STATE.isPlayerActive = true;
        GAME_STATE.lastPlayerActivity = Date.now();
        GAME_STATE.playerFocusTarget = mii;

        const pointsToMove = [];
        const startIdx = Math.min(this.boardFields.length - 1, Math.max(0, oldPositionIndex));
        const endIdx = Math.min(this.boardFields.length - 1, Math.max(0, newPositionIndex));

        if (startIdx < endIdx) {
            for (let i = startIdx; i <= endIdx; i++) {
                if (this.boardFields[i] && this.boardFields[i].mesh) {
                    const fieldPos = this.boardFields[i].mesh.position.clone();
                    fieldPos.y += BOARD_CONFIG.characterElevation;
                    pointsToMove.push(fieldPos);
                }
            }
        } else if (startIdx > endIdx) {
            for (let i = startIdx; i >= endIdx; i--) {
                if (this.boardFields[i] && this.boardFields[i].mesh) {
                    const fieldPos = this.boardFields[i].mesh.position.clone();
                    fieldPos.y += BOARD_CONFIG.characterElevation;
                    pointsToMove.push(fieldPos);
                }
            }
        } else {
            this.handleMovementCompletion(team, mii, newPositionIndex);
            return;
        }

        if (pointsToMove.length === 0) {
            this.handleMovementCompletion(team, mii, newPositionIndex);
            return;
        }

        let animationPath = [];
        if (mii.position.distanceTo(pointsToMove[0]) > 0.1) {
            animationPath.push(mii.position.clone());
        }
        animationPath = animationPath.concat(pointsToMove);

        if (animationPath.length > 0) {
            const onMovementComplete = () => {
                this.handleMovementCompletion(team, mii, newPositionIndex);
            };
            this.animateCharacterAlongPath(mii, animationPath, onMovementComplete, Math.abs(endIdx - startIdx));
        } else {
            this.handleMovementCompletion(team, mii, newPositionIndex);
        }
    }

    animateCharacterAlongPath(character, pathPoints, onComplete, steps) {
        if (!character || pathPoints.length === 0) {
            if (onComplete) onComplete();
            return;
        }

        let currentPointIndex = 0;
        const durationPerStep = 400; // Schnellere Animation: 0.4 Sekunden pro Feld

        const moveToNextPoint = () => {
            if (currentPointIndex >= pathPoints.length - 1) {
                if (onComplete) onComplete();
                return;
            }

            const startPosition = character.position.clone();
            const endPosition = pathPoints[currentPointIndex + 1];
            
            this.animateCharacterMove(character, endPosition, () => {
                currentPointIndex++;
                this.showFieldEffect(character.position, 0x66ff66, 400);
                // Längere Pause zwischen den Feldern für cinematographische Wirkung
                setTimeout(() => {
                    moveToNextPoint();
                }, 80); // 80ms Pause zwischen Feldern
            }, durationPerStep);
        };

        if (pathPoints.length > 1) {
            moveToNextPoint();
        } else {
            if(onComplete) onComplete();
        }
    }

    animateCharacterMove(character, targetPosition, callback, totalDuration = 150) {
        GAME_STATE.isAnimating = true;
        GAME_STATE.isCharacterMoving = true;
        

        const startPosition = character.position.clone();
        const distance = startPosition.distanceTo(targetPosition);
        const duration = Math.max(800, Math.min(totalDuration, distance * 250)); // Viel langsamer: mindestens 800ms, mehr Zeit pro Distanz
        const startTime = Date.now();

        const direction = new THREE.Vector3().subVectors(targetPosition, startPosition);
        const startRotation = character.quaternion.clone();
        const endRotation = new THREE.Quaternion();
        
        if (direction.lengthSq() > 0.0001) {
            const angle = Math.atan2(direction.x, direction.z);
            endRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
        } else {
            endRotation.copy(startRotation);
        }
        
        if (character.userData && character.userData.isFlyingCharacter) {
            if(character.userData) character.userData.isMoving = true;
        }

        const animateMoveFrame = () => {
            const currentTime = Date.now();
            const progress = Math.min(1, (currentTime - startTime) / duration);
            const easeProgress = this.easeInOutCubic(progress);

            const currentLerpedPos = new THREE.Vector3().lerpVectors(startPosition, targetPosition, easeProgress);
            
            character.position.x = currentLerpedPos.x;
            character.position.z = currentLerpedPos.z;

            if (character.userData && character.userData.isFlyingCharacter) {
                const flightAmplitude = 0.06;
                const flightFrequency = 2;
                const baseFlightY = THREE.MathUtils.lerp(startPosition.y, targetPosition.y, easeProgress);
                character.position.y = baseFlightY + Math.sin(easeProgress * Math.PI * flightFrequency) * flightAmplitude;
            } else {
                const jumpHeight = distance < 0.3 ? 0.12 : 0.25;
                const jumpOffset = Math.sin(easeProgress * Math.PI) * jumpHeight;
                character.position.y = THREE.MathUtils.lerp(startPosition.y, targetPosition.y, easeProgress) + jumpOffset;
            }
            
            character.quaternion.slerpQuaternions(startRotation, endRotation, easeProgress);

            if (progress < 1) {
                requestAnimationFrame(animateMoveFrame);
            } else {
                character.position.copy(targetPosition);
                character.quaternion.copy(endRotation);
                if (character.userData && character.userData.isFlyingCharacter) {
                    if(character.userData) character.userData.isMoving = false;
                }
                if (callback) callback();
            }
        };
        animateMoveFrame();
    }

    handleMovementCompletion(currentTeam, mii, finalPositionIndex) {
        console.log("🎯 [MOVEMENT COMPLETION] Starting completion process for", currentTeam.name);
        console.log("📍 [MOVEMENT COMPLETION] Final position index:", finalPositionIndex);
        console.log("🎮 [MOVEMENT COMPLETION] Character object:", mii ? "present" : "null");
        
        // Log current state before changes
        console.log("📊 [STATE BEFORE] isCharacterMoving:", GAME_STATE.isCharacterMoving);
        console.log("📊 [STATE BEFORE] isAnimating:", GAME_STATE.isAnimating);
        console.log("📊 [STATE BEFORE] turnSequenceState.isMoving:", turnSequenceState.isMoving);
        console.log("📊 [STATE BEFORE] activeMovementAnimation:", this.activeMovementAnimation);

        this.updateTeamBadgeForTeam(currentTeam.id, finalPositionIndex);
        console.log("🏷️ [MOVEMENT COMPLETION] Team badge updated for team", currentTeam.id, "at position", finalPositionIndex);

        // Reset movement states
        GAME_STATE.isCharacterMoving = false;
        GAME_STATE.isAnimating = false;
        this.activeMovementAnimation = null;
        
        // Movement completed - continue sequence
        turnSequenceState.isMoving = false;
        
        // Log state after reset
        console.log("📊 [STATE AFTER] isCharacterMoving:", GAME_STATE.isCharacterMoving);
        console.log("📊 [STATE AFTER] isAnimating:", GAME_STATE.isAnimating);
        console.log("📊 [STATE AFTER] turnSequenceState.isMoving:", turnSequenceState.isMoving);
        console.log("📊 [STATE AFTER] activeMovementAnimation:", this.activeMovementAnimation);
        
        console.log("✅ Movement completed for", currentTeam.name, "at position", finalPositionIndex);
        console.log("🔄 [MOVEMENT COMPLETION] All movement states have been reset successfully");
        
        // Keep GTA camera active if player turn is still in progress
        // Only stop camera following if turn is completely finished
        if (!GAME_STATE.playerTurnInProgress) {
            this.stopCameraFollow();
            console.log("📹 [MOVEMENT COMPLETION] Camera following stopped - turn finished");
        } else {
            console.log("📹 [MOVEMENT COMPLETION] Keeping GTA camera active - turn still in progress");
        }
        
        // DEAKTIVIERT: Keine automatische Charakterausrichtung mehr
        // if (mii) {
        //     this.orientCharacterToNextField(mii, finalPositionIndex);
        // }
        console.log("👤 [MOVEMENT COMPLETION] Character orientation skipped - keeping straight forward");

        // ZIELFELD: Victory wird jetzt nur serverseitig nach Würfelwurf ausgelöst
        // Kein automatischer Victory-Check mehr beim Erreichen von Position 72
        
        // Spezielle Nachricht für Safe Zone
        if (finalPositionIndex === this.boardFields.length - 2) {
            console.log("🎯 [SAFE ZONE] Team reached safe zone, needs 8+ to win");
            setTimeout(() => {
                this.showStatusMessage(`${currentTeam.name} ist in der Safe Zone! Nächster Wurf muss mindestens 8 sein zum Gewinnen.`, 8000, 'info', true, 'Safe Zone erreicht');
            }, 1000);
        }

        // Warte 2 Sekunden nach Bewegungsabschluss wie gewünscht
        console.log("⏰ [MOVEMENT COMPLETION] Waiting 2 seconds before continuing...");
        setTimeout(() => {
            console.log("➡️ [MOVEMENT COMPLETION] 2 seconds wait complete, continuing game sequence");
            this.continueGameSequence(currentTeam);
        }, 2000); // Geändert von 1000ms auf 2000ms

        this.updateTeamDisplay();
        console.log("🖥️ [MOVEMENT COMPLETION] Team display updated");
        console.log("✅ [MOVEMENT COMPLETION] Movement completion process finished for", currentTeam.name);
    }

    continueGameSequence(completedTeam) {
        // Status-Nachrichten für Spielphasen
        if (currentGamePhase === 'ROUND_OVER') {
            // All players finished - show overview then next minigame message
            console.log("🔄 [CAMERA] Round over - switching to orbit mode");
            setTimeout(() => {
                this.executeGameSequence(); // This will trigger camera overview
                
                setTimeout(() => {
                    this.showStatusMessage("Alle Teams haben gewürfelt. Admin kann nächstes Minispiel setzen.", 3000, 'success', true, 'Runde beendet');
                }, 3200); // After overview
            }, 500);
        } else if (GAME_STATE.currentServerTeamTurnId && currentGamePhase === 'DICE_ROLLING') {
            // Check if there's a next team to focus on
            const nextTeam = localTeams.find(t => t.id === GAME_STATE.currentServerTeamTurnId);
            if (nextTeam) {
                console.log("📹 [CAMERA] Focusing on next player:", nextTeam.name, "Phase:", currentGamePhase);
                setTimeout(() => {
                    // Focus camera on next player
                    if (!GAME_STATE.freeCameraMode) {
                        this.requestCameraMode('team_focus', {team: nextTeam}, 'normal', () => {
                            // Show next team message after camera focuses
                            if (nextTeam.is_blocked) {
                                this.showStatusMessage(`${nextTeam.name} ist am Zug (BLOCKIERT - muss ${nextTeam.blocked_target_number}+ würfeln).`, 3000, 'warning', true, 'Blockiertes Team am Zug');
                            } else if (nextTeam.position === 72) {
                                // ✅ FINAL FIELD: Show special message for team on final field
                                this.showStatusMessage(`${nextTeam.name} ist am Zug (ZIELFELD - braucht mindestens 6 zum Gewinnen)!`, 4000, 'warning', true, 'Zielfeld erreicht');
                                // Also show notification
                                if (window.NotificationSystem) {
                                    setTimeout(() => {
                                        const notification = window.NotificationSystem.createNotification({
                                            type: 'final-field-reminder',
                                            icon: '🎯',
                                            title: `${nextTeam.name} - Zielfeld erreicht!`,
                                            message: `Muss mindestens 6 würfeln um zu gewinnen!`,
                                            duration: 6000
                                        });
                                        window.NotificationSystem.showNotification(notification);
                                    }, 1000);
                                }
                            } else {
                                this.showStatusMessage(`${nextTeam.name} ist am Zug.`, 2500, 'info', true, 'Team am Zug');
                            }
                        });
                    } else {
                        // If free camera mode, just show the message
                        if (nextTeam.is_blocked) {
                            this.showStatusMessage(`${nextTeam.name} ist am Zug (BLOCKIERT - muss ${nextTeam.blocked_target_number}+ würfeln).`, 3000, 'warning', true, 'Blockiertes Team am Zug');
                        } else if (nextTeam.position === 72) {
                            // ✅ FINAL FIELD: Show special message for team on final field (free camera mode)
                            this.showStatusMessage(`${nextTeam.name} ist am Zug (ZIELFELD - braucht mindestens 6 zum Gewinnen)!`, 4000, 'warning', true, 'Zielfeld erreicht');
                            // Also show notification
                            if (window.NotificationSystem) {
                                setTimeout(() => {
                                    const notification = window.NotificationSystem.createNotification({
                                        type: 'final-field-reminder',
                                        icon: '🎯',
                                        title: `${nextTeam.name} - Zielfeld erreicht!`,
                                        message: `Muss mindestens 6 würfeln um zu gewinnen!`,
                                        duration: 6000
                                    });
                                    window.NotificationSystem.showNotification(notification);
                                }, 1000);
                            }
                        } else {
                            this.showStatusMessage(`${nextTeam.name} ist am Zug.`, 2500, 'info', true, 'Team am Zug');
                        }
                    }
                }, 1000); // Brief pause before switching to next player
            } else {
                // No next team found - switch to orbit mode
                console.log("🔄 [CAMERA] No next team found - switching to orbit mode");
                this.requestCameraMode('orbit', null, 'low');
            }
        } else {
            // No active team or special phase - but check for ongoing movements first
            if (GAME_STATE.isCharacterMoving || GAME_STATE.isAnimating || this.activeMovementAnimation) {
                console.log("🔄 [CAMERA] No active game phase but movement ongoing - waiting...");
                // Warte bis alle Bewegungen beendet sind
                const waitForAllMovements = () => {
                    if (GAME_STATE.isCharacterMoving || GAME_STATE.isAnimating || this.activeMovementAnimation) {
                        setTimeout(waitForAllMovements, 500);
                        return;
                    }
                    console.log("🔄 [CAMERA] All movements finished - now switching to orbit mode");
                    this.requestCameraMode('orbit', null, 'low');
                };
                setTimeout(waitForAllMovements, 1000);
            } else {
                console.log("🔄 [CAMERA] No active game phase - switching to orbit mode");
                this.requestCameraMode('orbit', null, 'low');
            }
        }
    }
    
    // Zentrale Kamera-Management Funktion
    requestCameraMode(mode, data = null, priority = 'normal', callback = null) {
        const now = Date.now();
        const timeSinceLastAction = now - GAME_STATE.cameraActionTimestamp;
        
        console.log(`🎥 [CAMERA REQUEST] Mode: ${mode}, Priority: ${priority}, Last: ${GAME_STATE.lastCameraAction}, Time since last: ${timeSinceLastAction}ms`);
        
        // Hohe Priorität (movement) überschreibt immer
        if (priority === 'high') {
            GAME_STATE.cameraTransitionActive = true;
            GAME_STATE.lastCameraAction = mode;
            GAME_STATE.cameraActionTimestamp = now;
            this.executeCameraMode(mode, data);
            return true;
        }
        
        // Niedrige Priorität nur wenn keine Transition aktiv und genug Zeit vergangen
        if (GAME_STATE.cameraTransitionActive && timeSinceLastAction < 3000) {
            console.log(`🚫 [CAMERA REQUEST] Skipping ${mode} - transition active or too soon`);
            return false;
        }
        
        // Team focus hat mittlere Priorität
        if (mode === 'team_focus' && GAME_STATE.lastCameraAction === 'team_focus' && timeSinceLastAction < 2000) {
            console.log(`🚫 [CAMERA REQUEST] Skipping duplicate team focus`);
            return false;
        }
        
        GAME_STATE.cameraTransitionActive = true;
        GAME_STATE.lastCameraAction = mode;
        GAME_STATE.cameraActionTimestamp = now;
        
        // Nach 3 Sekunden Transition als beendet markieren
        setTimeout(() => {
            GAME_STATE.cameraTransitionActive = false;
        }, 3000);
        
        this.executeCameraMode(mode, data, callback);
        return true;
    }
    
    executeCameraMode(mode, data, callback = null) {
        console.log(`🎬 [CAMERA EXECUTE] Mode: ${mode}`);
        
        switch(mode) {
            case 'orbit':
                this.switchToOrbitMode();
                break;
            case 'team_focus':
                if (data && data.team) {
                    this.focusCameraOnCurrentTeam(false, callback);
                }
                break;
            case 'gta_follow':
                if (data && data.character) {
                    this.startCameraFollow(data.character);
                }
                break;
            default:
                console.warn(`🚫 [CAMERA] Unknown mode: ${mode}`);
        }
    }
    
    switchToOrbitMode() {
        console.log("🌍 [CAMERA] Switching to orbit mode");
        if (GAME_STATE.freeCameraMode) {
            console.log("🚫 [CAMERA] Free camera mode active - skipping orbit");
            return;
        }
        
        // Check if there's an orbit function available, otherwise use overview
        if (typeof startCameraOrbitAnimation === 'function') {
            console.log("🔄 [CAMERA] Starting orbit animation");
            startCameraOrbitAnimation(false);
        } else {
            console.log("📹 [CAMERA] Orbit function not available - using overview");
            this.setCameraOverview(5000, () => {
                console.log("📹 [CAMERA] Overview complete");
            });
        }
    }

    showFieldEffect(position, color, duration = 800) {
        const particleCount = 20;
        const particlePositions = new Float32Array(particleCount * 3);
        const effectBaseY = position.y + BOARD_CONFIG.fieldHeight / 2;

        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = position.x;
            particlePositions[i * 3 + 1] = effectBaseY;
            particlePositions[i * 3 + 2] = position.z;
        }
        
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        const particleMaterial = new THREE.PointsMaterial({ 
            color: color, 
            size: 0.12, 
            transparent: true, 
            opacity: 1 
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        this.scene.add(particles);
        
        let time = 0;
        const animateEffect = () => {
            time += 0.03;
            if (time > 1) {
                if (particles.parent) this.scene.remove(particles);
                particleGeometry.dispose();
                particleMaterial.dispose();
                return;
            }
            
            const currentPositions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const angle = i / particleCount * Math.PI * 2 + time * 2;
                const radius = time * 1.2;
                currentPositions[i * 3] = position.x + Math.cos(angle) * radius;
                currentPositions[i * 3 + 1] = effectBaseY + time * 0.8 + Math.sin(time * 4 + i) * 0.1;
                currentPositions[i * 3 + 2] = position.z + Math.sin(angle) * radius;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particleMaterial.opacity = Math.max(0, 1 - time);
            requestAnimationFrame(animateEffect);
        };
        animateEffect();
    }

    prepareNextPlayerTurn(immediate = false) {
        if (GAME_STATE.playerTurnInProgress) return;
        GAME_STATE.playerTurnInProgress = true;
        GAME_STATE.cameraMode = 'front';

        this.focusCameraOnCurrentTeam(immediate, () => {
            const currentMii = this.miiCharacters[this.getCurrentTeam()?.id];
            if (currentMii) {
                // Keine Drehung zur Kamera
                GAME_STATE.playerTurnInProgress = false;
                GAME_STATE.isAnimating = false;
            } else {
                GAME_STATE.playerTurnInProgress = false;
                GAME_STATE.isAnimating = false;
            }
        });
    }

    nextTeam() {
        GAME_STATE.currentTeamIndex = (GAME_STATE.currentTeamIndex + 1) % localTeams.length;
        this.updateTeamDisplay();
        
        // Check if all players finished their turns after updating team index
        if (this.checkAllPlayersFinished()) {
            // Trigger game sequence which will handle camera overview
            setTimeout(() => {
                this.executeGameSequence();
            }, 500);
        } else if (!GAME_STATE.freeCameraMode) {
            this.requestCameraMode('team_focus', {team: this.teams[this.currentTurn]}, 'normal');
        }
    }

    focusCameraOnCurrentTeam(immediate = false, callback) {
        if (GAME_STATE.freeCameraMode && !immediate) {
            if(callback) callback();
            return;
        }
        GAME_STATE.isAnimating = true;

        const currentTeam = this.getCurrentTeam();
        if (!currentTeam || !this.miiCharacters[currentTeam.id]) {
            this.animateCameraToPosition(new THREE.Vector3(18, 25, 18), new THREE.Vector3(0, 6, 0), immediate ? 0 : 800, callback);
            return;
        }
        
        const character = this.miiCharacters[currentTeam.id];
        const targetPosition = character.position.clone();
        
        let cameraPosition, lookAtPosition;
        
        // Immer GTA5-style Position verwenden für konsistente Vogelperspektive
        {
        // GTA5-style Position: Direkt hinter dem Spieler in Vogelperspektive
        this.ensureCharacterFacingForward(character);
        
        const characterDirection = new THREE.Vector3();
        character.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();
        
        // GTA5-style: Direkt hinter dem Spieler, konstanter Abstand und Höhe
        cameraPosition = targetPosition.clone();
        cameraPosition.x -= characterDirection.x * BOARD_CONFIG.gtaCameraDistance;
        cameraPosition.z -= characterDirection.z * BOARD_CONFIG.gtaCameraDistance;
        cameraPosition.y = targetPosition.y + BOARD_CONFIG.gtaCameraHeight;
        
        lookAtPosition = targetPosition.clone();
        lookAtPosition.y += 1.0; // GTA5-style: Schaue leicht nach oben zur Figur
        
        // Setze Kamera-Modus für GTA5-Stil
        GAME_STATE.cameraMode = 'gta_follow';
        }

        this.animateCameraToPosition(cameraPosition, lookAtPosition, immediate ? 0 : 800, callback);
    }

    startCameraFollow(character) {
        if (GAME_STATE.freeCameraMode) return;
        GAME_STATE.cameraMode = 'gta_follow';
        this.isFollowingCharacter = true;
        this.followTarget = character;
        
        // Stelle sicher dass Figur nach vorne schaut
        this.ensureCharacterFacingForward(character);
        
        // Prüfe ob Kamera bereits in GTA5-Position ist
        const targetPosition = character.position.clone();
        const characterDirection = new THREE.Vector3();
        character.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();
        
        const expectedCameraPos = targetPosition.clone();
        expectedCameraPos.x -= characterDirection.x * BOARD_CONFIG.gtaCameraDistance;
        expectedCameraPos.z -= characterDirection.z * BOARD_CONFIG.gtaCameraDistance;
        expectedCameraPos.y = targetPosition.y + BOARD_CONFIG.gtaCameraHeight;
        
        const currentDistance = this.camera.position.distanceTo(expectedCameraPos);
        
        // Wenn Kamera bereits nah genug ist (weniger als 2 Einheiten entfernt), keine Transition
        if (currentDistance < 2.0) {
            console.log('🎥 Kamera bereits in GTA5-Position, starte sofort Follow-Modus');
            this.startGTAFollow();
        } else {
            console.log('🎥 Kamera nicht in Position, mache Transition');
            this.transitionToGTAPosition(character, () => {
                this.startGTAFollow();
            });
        }
    }

    stopCameraFollow() {
        // Nicht stoppen wenn Charakter sich noch bewegt oder Spieler noch am Zug ist
        if (GAME_STATE.isCharacterMoving || GAME_STATE.playerTurnInProgress) {
            console.log("📹 [CAMERA] stopCameraFollow ignored - character moving or turn in progress");
            return;
        }
        
        this.isFollowingCharacter = false;
        this.followTarget = null;
        this.gtaFollowActive = false;
        GAME_STATE.cameraMode = 'auto';
        console.log("📹 [CAMERA] Camera follow stopped - switching to auto mode");
    }

    getCharacterPathPosition(character) {
        // Finde die Position des Charakters auf dem Pfad
        for (let i = 0; i < this.boardFields.length; i++) {
            const field = this.boardFields[i];
            if (field && field.children) {
                for (let child of field.children) {
                    if (child === character) {
                        return i;
                    }
                }
            }
        }
        // Fallback: schaue nach Team-Zuordnung
        const teams = this.boardTeams || [];
        for (let team of teams) {
            if (team.character === character) {
                return team.position || 0;
            }
        }
        return 0;
    }

    ensureCharacterFacingForward(character) {
        // DEAKTIVIERT: Charaktere sollen nicht automatisch gedreht werden
        console.log("👤 [CHARACTER] ensureCharacterFacingForward disabled - keeping straight forward");
        // Keine Rotation mehr
    }

    transitionToGTAPosition(character, callback) {
        GAME_STATE.isAnimatingCamera = true;
        
        const targetPosition = character.position.clone();
        
        // GTA5-style Position: Direkt hinter dem Spieler, leicht erhöht
        const characterDirection = new THREE.Vector3();
        character.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();
        
        // Position berechnen
        const cameraPosition = targetPosition.clone();
        cameraPosition.x -= characterDirection.x * BOARD_CONFIG.gtaCameraDistance;
        cameraPosition.z -= characterDirection.z * BOARD_CONFIG.gtaCameraDistance;
        cameraPosition.y = targetPosition.y + BOARD_CONFIG.gtaCameraHeight;
        
        const lookAtPosition = targetPosition.clone();
        lookAtPosition.y += 1.0; // Schaue leicht nach oben zur Figur
        
        this.animateCameraToPositionSmooth(cameraPosition, lookAtPosition, 1000, () => {
            GAME_STATE.isAnimatingCamera = false;
            if (callback) callback();
        });
    }

    startGTAFollow() {
        // Starte kontinuierliche GTA-style Verfolgung
        this.gtaFollowActive = true;
        this.updateGTAFollow();
    }

    updateGTAFollow() {
        if (!this.gtaFollowActive || !this.isFollowingCharacter || !this.followTarget || GAME_STATE.freeCameraMode || GAME_STATE.isAnimatingCamera) {
            return;
        }
        
        const character = this.followTarget;
        const targetPosition = character.position.clone();
        
        // Hole die aktuelle Blickrichtung der Figur
        const characterDirection = new THREE.Vector3();
        character.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();
        
        // GTA5-style: Kamera direkt hinter dem Spieler
        const cameraPosition = targetPosition.clone();
        cameraPosition.x -= characterDirection.x * BOARD_CONFIG.gtaCameraDistance;
        cameraPosition.z -= characterDirection.z * BOARD_CONFIG.gtaCameraDistance;
        cameraPosition.y = targetPosition.y + BOARD_CONFIG.gtaCameraHeight;
        
        const lookAtPosition = targetPosition.clone();
        lookAtPosition.y += 1.0;
        
        // Smooth lerping für flüssige Bewegung
        this.camera.position.lerp(cameraPosition, BOARD_CONFIG.gtaCameraSmoothing);
        this.controls.target.lerp(lookAtPosition, BOARD_CONFIG.gtaCameraLookSmoothing);
        
        this.camera.lookAt(this.controls.target);
    }

    // Verbesserte Kamera-Animation mit anti-judder Techniken
    animateCameraToPositionSmooth(targetCamPos, targetLookAtPos, duration = 1000, callback) {
        if (duration === 0) {
            this.camera.position.copy(targetCamPos);
            this.controls.target.copy(targetLookAtPos);
            this.camera.lookAt(this.controls.target);
            GAME_STATE.isAnimatingCamera = false;
            if (callback) callback();
            return;
        }
        
        const startCamPos = this.camera.position.clone();
        const startLookAt = this.controls.target.clone();
        const startTime = performance.now(); // Verwende performance.now() für präzisere Timing
        GAME_STATE.isAnimatingCamera = true;
        
        // Prä-berechne Distanz für adaptive smoothing
        const totalDistance = startCamPos.distanceTo(targetCamPos);
        const isLongDistance = totalDistance > 20; // Für weite Distanzen andere Easing

        const animateCameraFrame = (currentTime) => {
            const progress = Math.min(1, (currentTime - startTime) / duration);
            
            // Adaptive Easing basierend auf Distanz und Transition-Typ
            let easeProgress;
            if (isLongDistance) {
                // Sanfteres Easing für weite Distanzen (Orbit zu Player)
                easeProgress = this.easeInOutCubic(progress);
            } else {
                // Präziseres Easing für kurze Distanzen
                easeProgress = this.easeInOutQuart(progress);
            }
            
            // Multi-stage smoothing für sehr flüssige Bewegung
            const positionProgress = easeProgress;
            const lookAtProgress = easeProgress * 0.9; // LookAt folgt etwas langsamer

            this.camera.position.lerpVectors(startCamPos, targetCamPos, positionProgress);
            this.controls.target.lerpVectors(startLookAt, targetLookAtPos, lookAtProgress);
            this.camera.lookAt(this.controls.target);

            if (progress < 1) {
                requestAnimationFrame(animateCameraFrame);
            } else {
                // Finale exakte Positionierung
                this.camera.position.copy(targetCamPos);
                this.controls.target.copy(targetLookAtPos);
                this.camera.lookAt(this.controls.target);
                GAME_STATE.isAnimatingCamera = false;
                if (callback) callback();
            }
        };
        requestAnimationFrame(animateCameraFrame);
    }
    
    // Legacy function für Rücwärtskompatibilität
    animateCameraToPosition(targetCamPos, targetLookAtPos, duration = 1000, callback) {
        this.animateCameraToPositionSmooth(targetCamPos, targetLookAtPos, duration, callback);
    }

    easeInOutCubic(t) { 
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; 
    }
    
    easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
    }
    
    // Hinderniserkennung wurde komplett entfernt für flüssige Performance

    // ==============================================
    // AUTOMATIC CAMERA MANAGEMENT SYSTEM
    // ==============================================
    
    // Verbesserte Hauptfunktion für automatisches Kamera-Management
    updateAutomaticCamera() {
        if (!GAME_STATE.autoCameraEnabled || GAME_STATE.freeCameraMode) {
            return;
        }
        
        // Vermeide Updates während Kamera-Animationen für smoothness
        if (GAME_STATE.cameraTransitioning || GAME_STATE.isAnimatingCamera) {
            return;
        }

        const isPlayerActiveNow = this.checkIfPlayerIsActive();
        const hasPlayerActivityChanged = isPlayerActiveNow !== GAME_STATE.isPlayerActive;
        
        // Update player activity state
        if (isPlayerActiveNow) {
            GAME_STATE.lastPlayerActivity = Date.now();
            GAME_STATE.isPlayerActive = true;
            GAME_STATE.playerFocusTarget = this.getCurrentActivePlayer();
        } else {
            GAME_STATE.isPlayerActive = false;
        }

        // Entscheide Kamera-Modus basierend auf Spieler-Aktivität mit debouncing
        if (hasPlayerActivityChanged) {
            // Clear any pending camera switches
            if (this.pendingCameraSwitch) {
                clearTimeout(this.pendingCameraSwitch);
                this.pendingCameraSwitch = null;
            }
            
            if (isPlayerActiveNow) {
                console.log('🎯 Spieler ist aktiv - wechsle zu Player Focus...');
                this.switchToPlayerFocus();
            } else {
                // Nur Auto-Orbit starten wenn nicht in ROUND_OVER Phase
                // VERLÄNGERTE Wartezeit für stabilere GTA-Kamera
                if (GAME_STATE.currentGamePhase !== 'ROUND_OVER') {
                    console.log('🌌 Spieler inaktiv - warte länger vor Auto-Orbit...');
                    // Verdoppelte Wartezeit für weniger störende Kamera-Wechsel
                    const extendedDelay = BOARD_CONFIG.cameraAutoOrbitDelay * 2;
                    this.pendingCameraSwitch = setTimeout(() => {
                        if (!GAME_STATE.isPlayerActive && GAME_STATE.autoCameraEnabled && !GAME_STATE.cameraTransitioning) {
                            console.log('🌌 Starte Auto-Orbit nach verlängerter Wartezeit...');
                            this.switchToAutoOrbit();
                        }
                        this.pendingCameraSwitch = null;
                    }, extendedDelay);
                }
            }
        }
    }

    // Prüft ob gerade ein Spieler aktiv ist
    checkIfPlayerIsActive() {
        // Erweiterte Bedingungen für länger aktive GTA-Kamera
        const isCurrentlyActive = GAME_STATE.playerTurnInProgress || 
                                GAME_STATE.isCharacterMoving || 
                                GAME_STATE.isDiceRolling || 
                                GAME_STATE.isAnimating ||
                                GAME_STATE.cinematicMode;
        
        // Zusätzliche Bedingung: Spieler gilt als "aktiv" wenn er gerade seinen Zug hat
        // auch wenn er nicht aktiv läuft/würfelt (GTA-Kamera bleibt länger aktiv)
        const currentTeam = this.getCurrentTeam();
        const isCurrentPlayerTurn = currentTeam && GAME_STATE.currentServerTeamTurnId === currentTeam.id;
        
        // GTA-Kamera bleibt aktiv während des gesamten Spielerzugs
        return isCurrentlyActive || isCurrentPlayerTurn;
    }

    // Holt den aktuell aktiven Spieler
    getCurrentActivePlayer() {
        const currentTeam = this.getCurrentTeam();
        if (currentTeam && this.miiCharacters[currentTeam.id]) {
            return this.miiCharacters[currentTeam.id];
        }
        
        // Fallback: Wenn keine Team ID da ist, zeige keine Warnings in ROUND_OVER Phase
        if (GAME_STATE.currentGamePhase === 'ROUND_OVER') {
            return null; // Normal in dieser Phase
        }
        
        // Nur Warnings außerhalb von ROUND_OVER
        // console.warn("⚠️ getCurrentActivePlayer: No current team ID or no characters loaded", this.miiCharacters ? Object.keys(this.miiCharacters).length : 0);
        return null;
    }

    // Wechselt zu Spieler-Fokus-Modus - verbesserte smooth transition
    switchToPlayerFocus() {
        if (GAME_STATE.autoOrbitActive) {
            // Stoppe Orbit sanft ohne abrupte Änderungen
            window.orbitAnimationRunning = false;
            GAME_STATE.autoOrbitActive = false;
        }
        
        // Vermeide mehrfache gleichzeitige Transitions
        if (GAME_STATE.cameraTransitioning) {
            console.log('📹 Camera transition bereits aktiv - warte...');
            return;
        }
        
        GAME_STATE.cameraFocusMode = 'focus';
        GAME_STATE.cameraTransitioning = true;
        
        // Sichere current camera state for smooth transition
        const currentCamPos = this.camera.position.clone();
        const currentLookAt = this.controls.target.clone();

        // Verbesserte smooth focus auf aktuellen Spieler
        this.focusOnCurrentPlayerSmoothImproved(currentCamPos, currentLookAt, () => {
            GAME_STATE.cameraTransitioning = false;
            // Re-enable controls smoothly
            this.controls.enabled = !GAME_STATE.freeCameraMode;
            // Starte Player-Following
            this.startAutomaticPlayerFollowing();
        });
    }

    // Wechselt zu Auto-Orbit-Modus - verbesserte Transition
    switchToAutoOrbit() {
        if (GAME_STATE.isPlayerActive) return; // Sicherheitscheck
        
        // Vermeide mehrfache gleichzeitige Transitions
        if (GAME_STATE.cameraTransitioning) {
            console.log('📹 Camera transition bereits aktiv - warte...');
            return;
        }
        
        this.stopAutomaticPlayerFollowing();
        GAME_STATE.cameraFocusMode = 'orbit';
        GAME_STATE.cameraTransitioning = true;

        // Sanfter Übergang zum Orbit - kürzere Transition-Zeit
        const shorterTransitionDuration = Math.min(1000, BOARD_CONFIG.cameraTransitionDuration * 0.7);
        
        console.log('🌌 Starte sanften Übergang zu Auto-Orbit...');
        startCameraOrbitAnimationSmooth(false, null); // Verbesserter Orbit
        GAME_STATE.autoOrbitActive = true;
        
        setTimeout(() => {
            GAME_STATE.cameraTransitioning = false;
        }, shorterTransitionDuration);
    }

    // Verbesserte smooth focus transition von orbit zu spieler - immer in GTA5-Vogelperspektive
    focusOnCurrentPlayerSmoothImproved(currentCamPos, currentLookAt, callback) {
        const currentPlayer = this.getCurrentActivePlayer();
        if (!currentPlayer) {
            // console.warn('⚠️ focusOnCurrentPlayerSmoothImproved: Kein aktiver Spieler gefunden');
            if (callback) callback();
            return;
        }

        const playerPos = currentPlayer.position.clone();
        
        // Stelle sicher, dass Charakter nach vorne schaut
        this.ensureCharacterFacingForward(currentPlayer);
        
        // GTA5-style Kamera-Position: Direkt hinter dem Spieler in Vogelperspektive
        const characterDirection = new THREE.Vector3();
        currentPlayer.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();
        
        // GTA5-style: Direkt hinter dem Spieler, konstanter Abstand und Höhe
        const cameraPos = playerPos.clone();
        cameraPos.x -= characterDirection.x * BOARD_CONFIG.gtaCameraDistance;
        cameraPos.z -= characterDirection.z * BOARD_CONFIG.gtaCameraDistance;
        cameraPos.y = playerPos.y + BOARD_CONFIG.gtaCameraHeight;
        
        const lookAtPos = playerPos.clone();
        lookAtPos.y += 1.0; // GTA5-style: Schaue leicht nach oben zur Figur

        // Setze Kamera-Modus für GTA5-Stil
        GAME_STATE.cameraMode = 'gta_follow';

        // Verkürzte Transition-Zeit für weniger Ruckeln
        const transitionDuration = Math.min(800, BOARD_CONFIG.cameraTransitionDuration * 0.6);
        
        console.log('🎥 Starte GTA-style Player-Focus-Transition (Vogelperspektive)...');
        this.animateCameraToPositionSmooth(cameraPos, lookAtPos, transitionDuration, callback);
    }
    
    // Legacy function für Rücwärtskompatibilität
    focusOnCurrentPlayerSmooth(callback) {
        const currentCamPos = this.camera.position.clone();
        const currentLookAt = this.controls.target.clone();
        this.focusOnCurrentPlayerSmoothImproved(currentCamPos, currentLookAt, callback);
    }

    // Startet automatische Spieler-Verfolgung
    startAutomaticPlayerFollowing() {
        GAME_STATE.cameraMode = 'gta_follow'; // Setze direkt auf GTA-Modus für konsistente Vogelperspektive
        this.isFollowingCharacter = true;
        this.followTarget = this.getCurrentActivePlayer();
        
        // Stelle sicher, dass die Kamera bereits in der GTA-Vogelperspektive positioniert ist
        if (this.followTarget) {
            this.ensureCharacterFacingForward(this.followTarget);
        }
    }

    // Stoppt automatische Spieler-Verfolgung
    stopAutomaticPlayerFollowing() {
        this.isFollowingCharacter = false;
        this.followTarget = null;
    }

    // Ultra-smooth camera following with predictive positioning and adaptive smoothing
    updateAutomaticCameraFollow() {
        if (!this.isFollowingCharacter || !this.followTarget || GAME_STATE.freeCameraMode || GAME_STATE.cameraTransitioning) {
            return;
        }
        
        const character = this.followTarget;
        const targetPosition = character.position.clone();
        
        // Enhanced movement prediction and direction calculation
        const characterDirection = new THREE.Vector3();
        character.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();

        // Advanced velocity calculation with smoothing
        const currentTime = Date.now();
        if (!this.lastPositionData) {
            this.lastPositionData = { position: targetPosition.clone(), time: currentTime };
        }
        
        const deltaTime = (currentTime - this.lastPositionData.time) / 1000; // Convert to seconds
        const deltaPosition = targetPosition.clone().sub(this.lastPositionData.position);
        const currentVelocity = deltaTime > 0 ? deltaPosition.length() / deltaTime : 0;
        
        // Smooth velocity with rolling average
        if (!this.velocityHistory) this.velocityHistory = [];
        this.velocityHistory.push(currentVelocity);
        if (this.velocityHistory.length > 5) this.velocityHistory.shift();
        const smoothVelocity = this.velocityHistory.reduce((a, b) => a + b, 0) / this.velocityHistory.length;
        
        // Update position data for next frame
        this.lastPositionData = { position: targetPosition.clone(), time: currentTime };

        // Predictive positioning based on movement
        const predictivePosition = targetPosition.clone();
        if (smoothVelocity > 0.1 && deltaTime > 0) {
            const predictionTime = 0.3; // Look ahead 300ms
            const velocityVector = deltaPosition.normalize().multiplyScalar(smoothVelocity * predictionTime);
            predictivePosition.add(velocityVector);
        }

        // Adaptive camera distance and height based on speed and terrain
        const baseDistance = BOARD_CONFIG.cameraPlayerFocusDistance;
        const baseHeight = BOARD_CONFIG.cameraPlayerFocusHeight;
        
        // Dynamic adjustments
        const speedMultiplier = Math.min(2.0, 1 + smoothVelocity * 0.5);
        const dynamicDistance = baseDistance * speedMultiplier;
        // Immer hohe Vogelperspektive beibehalten
        const dynamicHeight = baseHeight; // Konstante Höhe für Stabilität
        
        // Calculate ideal camera position with multiple fallback options
        const idealPositions = this.calculateIdealCameraPositions(
            predictivePosition, 
            characterDirection, 
            dynamicDistance, 
            dynamicHeight
        );
        
        let bestCameraPosition = idealPositions[0];
        const lookAtPosition = targetPosition.clone();
        lookAtPosition.y -= 0.5; // Schaue nach unten auf Ziel

        // Keine Hinderniserkennung - nutze erste ideale Position
        bestCameraPosition = idealPositions[0];
        
        // Verbesserte adaptive Smoothing-Logik
        const distanceToTarget = this.camera.position.distanceTo(bestCameraPosition);
        const baseSmoothing = BOARD_CONFIG.cameraSmoothing;
        const maxSmoothing = BOARD_CONFIG.cameraMaxSmoothingFactor || 0.15; // Reduziert für smoothness
        const minSmoothing = BOARD_CONFIG.cameraMinSmoothingFactor || 0.05; // Reduziert für smoothness
        
        // Verbesserte Faktor-Berechnung
        const distanceFactor = Math.min(1.0, distanceToTarget / 8.0); // Angepasst
        const velocityFactor = Math.min(1.0, smoothVelocity / 1.5); // Angepasst
        
        // Smootheres Interpolieren mit kubischer Kurve
        const easedDistanceFactor = distanceFactor * distanceFactor * (3.0 - 2.0 * distanceFactor);
        const easedVelocityFactor = velocityFactor * velocityFactor * (3.0 - 2.0 * velocityFactor);
        
        const adaptiveSmoothing = THREE.MathUtils.lerp(
            maxSmoothing, 
            minSmoothing, 
            easedDistanceFactor * 0.6 + easedVelocityFactor * 0.4
        );
        
        // Noch smootheres LookAt
        const adaptiveLookAtSmoothing = Math.min(
            adaptiveSmoothing * 1.5,
            0.08 // Maximum für sehr smooth camera
        );
        
        // Ultra-smooth interpolation mit verbesserter Logik
        this.camera.position.lerp(bestCameraPosition, adaptiveSmoothing);
        this.controls.target.lerp(lookAtPosition, adaptiveLookAtSmoothing);
        this.camera.lookAt(this.controls.target);
        
        // Debug logging for performance monitoring
        if (Math.random() < 0.01) { // Log 1% of frames to avoid spam
            console.log(`📹 Camera: velocity=${smoothVelocity.toFixed(2)}, smoothing=${adaptiveSmoothing.toFixed(3)}, height=${bestCameraPosition.y.toFixed(1)}`);
        }
    }
    
    // Calculate multiple ideal camera positions for different scenarios
    calculateIdealCameraPositions(playerPos, direction, distance, height) {
        const positions = [];
        
        // Primary position: Behind player based on movement direction
        const primary = playerPos.clone().sub(direction.clone().multiplyScalar(distance));
        primary.y = height;
        positions.push(primary);
        
        // Alternative positions at different angles
        const angles = [Math.PI/6, -Math.PI/6, Math.PI/3, -Math.PI/3, Math.PI/2, -Math.PI/2];
        
        for (let angle of angles) {
            const rotatedDirection = direction.clone();
            rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            
            const altPos = playerPos.clone().sub(rotatedDirection.multiplyScalar(distance * 0.9));
            altPos.y = height + Math.abs(angle) * 2; // Higher for side angles
            positions.push(altPos);
        }
        
        // High overview position as last resort
        const overview = playerPos.clone();
        overview.y = height + 8;
        overview.x += distance * 0.5;
        overview.z += distance * 0.5;
        positions.push(overview);
        
        return positions;
    }

    // Initialisierung des automatischen Kamera-Management-Systems
    initAutomaticCameraManagement() {
        console.log('🎥 Initialisiere Auto-Kamera-System...');
        
        // Setze initiale Kamera-Zustände
        GAME_STATE.autoCameraEnabled = true;
        GAME_STATE.cameraFocusMode = 'auto';
        GAME_STATE.isPlayerActive = false;
        GAME_STATE.autoOrbitActive = false;
        GAME_STATE.cameraTransitioning = false;
        GAME_STATE.lastPlayerActivity = Date.now();
        
        // Starte mit Auto-Orbit da zunächst kein Spieler aktiv ist
        setTimeout(() => {
            if (GAME_STATE.autoCameraEnabled && !GAME_STATE.isPlayerActive) {
                // Sichere Kamera-Position vor Orbit-Start
                this.camera.position.set(25, 20, 25);
                this.camera.lookAt(0, 5, 0);
                this.controls.target.set(0, 5, 0);
                
                this.switchToAutoOrbit();
                console.log('🎥 Auto-Kamera-System gestartet - beginne mit Orbit-Modus');
            }
        }, 2000); // 2s warten bis alles geladen ist
        
        console.log('🎥 Auto-Kamera-System bereit');
        console.log('Steuerung: C-Taste = Auto-Kamera ein/aus, M-Taste = Freie Kamera');
    }

    // Spezielle Kamera-Modi für besondere Ereignisse
    triggerSpecialCameraEvent(eventType, duration = null) {
        if (!GAME_STATE.autoCameraEnabled) return;
        
        console.log(`🎥 Spezial-Kamera-Event: ${eventType}`);
        
        switch(eventType) {
            case 'catapult':
                // Erweiterte Verfolgung für Katapult-Aktionen
                this.startEnhancedPlayerFollowing(duration || 5000);
                break;
                
            case 'minigame':
                // Auto-Minispiel-Kamera
                startMinigameCameraOrbit(duration || 30000);
                break;
                
            case 'dice_roll':
                // Fokus auf Würfel-Bereich
                this.focusOnDiceArea(duration || 3000);
                break;
                
            case 'player_swap':
                // Zeige beide Spieler für Tausch
                this.showPlayerSwapView(duration || 8000);
                break;
                
            default:
                console.log(`Unbekanntes Kamera-Event: ${eventType}`);
        }
    }

    // Hole aktuellen aktiven Spieler sicher
    getCurrentActivePlayer() {
        if (!GAME_STATE.currentServerTeamTurnId || !this.miiCharacters) {
            // console.warn('⚠️ getCurrentActivePlayer: No current team ID or no characters loaded');
            return null;
        }
        
        const character = this.miiCharacters[GAME_STATE.currentServerTeamTurnId];
        if (!character) {
            console.warn('⚠️ getCurrentActivePlayer: Character not found for team ID:', GAME_STATE.currentServerTeamTurnId);
            return null;
        }
        
        return character;
    }
    
    // Erweiterte Spieler-Verfolgung für Spezial-Aktionen
    startEnhancedPlayerFollowing(duration) {
        const currentPlayer = this.getCurrentActivePlayer();
        if (!currentPlayer) {
            console.warn('⚠️ startEnhancedPlayerFollowing: No current player found');
            return;
        }
        
        console.log('🎯 Starte erweiterte Spieler-Verfolgung');
        
        // Setze spezielle Verfolgungsparameter für dramatische Aktionen
        this.enhancedFollowing = {
            active: true,
            target: currentPlayer,
            distance: BOARD_CONFIG.cameraPlayerFocusDistance * 1.5,
            height: BOARD_CONFIG.cameraPlayerFocusHeight * 1.3,
            smoothing: BOARD_CONFIG.cameraSmoothing * 2
        };
        
        // Stoppe nach Zeitlimit
        if (duration) {
            setTimeout(() => {
                this.enhancedFollowing.active = false;
                console.log('🎯 Erweiterte Spieler-Verfolgung beendet');
            }, duration);
        }
    }

    // Fokus auf Würfel-Bereich
    focusOnDiceArea(duration) {
        console.log('🎲 Fokussiere Würfel-Bereich');
        
        // Position über dem Würfel-Bereich
        const dicePosition = new THREE.Vector3(0, 8, 0); // Zentrum der Insel
        const cameraPosition = new THREE.Vector3(10, 12, 10);
        const lookAtPosition = dicePosition;
        
        this.animateCameraToPosition(cameraPosition, lookAtPosition, 1000, () => {
            if (duration) {
                setTimeout(() => {
                    // Zurück zur automatischen Verfolgung
                    if (GAME_STATE.autoCameraEnabled) {
                        this.updateAutomaticCamera();
                    }
                }, duration);
            }
        });
    }

    // Zeige beide Spieler für Tausch
    showPlayerSwapView(duration) {
        console.log('🔄 Zeige Spieler-Tausch-Ansicht');
        
        // Finde beide betroffenen Spieler und zeige beide
        const overviewPosition = new THREE.Vector3(0, 25, 35);
        const lookAtPosition = new THREE.Vector3(0, 5, 0);
        
        this.animateCameraToPosition(overviewPosition, lookAtPosition, 1200, () => {
            if (duration) {
                setTimeout(() => {
                    // Zurück zur automatischen Verfolgung
                    if (GAME_STATE.autoCameraEnabled) {
                        this.updateAutomaticCamera();
                    }
                }, duration);
            }
        });
    }

    createDiceFaceTexture(number) {
        const canvas = document.createElement('canvas');
        const size = 256;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createLinearGradient(0, 0, size, size);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, '#f8f8f8');
        gradient.addColorStop(1, '#eeeeee');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = size / 20;
        ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, size - ctx.lineWidth, size - ctx.lineWidth);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = size / 32;
        ctx.strokeRect(size/16, size/16, size - size/8, size - size/8);

        ctx.fillStyle = '#2c2c2c';
        const dotRadius = size / 12;
        const padding = size / 4.5;

        const positions = {
            1: [[size / 2, size / 2]],
            2: [[padding, padding], [size - padding, size - padding]],
            3: [[padding, padding], [size / 2, size / 2], [size - padding, size - padding]],
            4: [[padding, padding], [size - padding, padding], [padding, size - padding], [size - padding, size - padding]],
            5: [[padding, padding], [size - padding, padding], [size / 2, size / 2], [padding, size - padding], [size - padding, size - padding]],
            6: [[padding, padding], [size - padding, padding], [padding, size / 2], [size - padding, size / 2], [padding, size - padding], [size - padding, size - padding]],
        };

        if (positions[number]) {
            positions[number].forEach(pos => {
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(pos[0] + 2, pos[1] + 2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
                
                const dotGradient = ctx.createRadialGradient(
                    pos[0] - dotRadius/3, pos[1] - dotRadius/3, 0, 
                    pos[0], pos[1], dotRadius
                );
                dotGradient.addColorStop(0, '#444444');
                dotGradient.addColorStop(0.7, '#2c2c2c');
                dotGradient.addColorStop(1, '#1a1a1a');
                
                ctx.fillStyle = dotGradient;
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], dotRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.arc(pos[0] - dotRadius/4, pos[1] - dotRadius/4, dotRadius/4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    createInteractiveDice() {
        const diceSize = 0.45;
        const geometry = new THREE.BoxGeometry(diceSize, diceSize, diceSize);
        
        const materials = [];
        for (let i = 1; i <= 6; i++) {
            materials.push(new THREE.MeshPhongMaterial({ 
                map: this.createDiceFaceTexture(i), 
                shininess: 100,
                specular: 0xffffff
            }));
        }
        
        const orderedMaterials = [
            materials[0], materials[5], materials[1], 
            materials[4], materials[2], materials[3]
        ];
        
        this.interactiveDice = new THREE.Mesh(geometry, orderedMaterials);
        this.interactiveDice.castShadow = true;
        this.interactiveDice.receiveShadow = true;
        this.interactiveDice.visible = false;
        this.interactiveDice.userData.isDice = true;
        this.scene.add(this.interactiveDice);
        
        this.createDiceResultNumber();
    }

    createDiceResultNumber() {
        const numberGroup = new THREE.Group();
        
        const circleGeometry = new THREE.CircleGeometry(0.4, 24);
        const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFD700,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        numberGroup.add(circle);
        
        numberGroup.visible = false;
        this.scene.add(numberGroup);
        this.diceResultNumber = numberGroup;
    }

    animateCharacterTurn(character, targetLookAtPosition, callback, duration = 500) {
        // DEAKTIVIERT: Charaktere sollen nicht automatisch gedreht werden
        console.log("👤 [CHARACTER] Character turn animation disabled - keeping straight forward");
        
        // Callback sofort ausführen ohne Drehung
        if (callback) {
            callback();
        }
    }

    rollDice() {
        if (GAME_STATE.isAnimating || GAME_STATE.isDiceRolling || GAME_STATE.isCharacterMoving || !this.interactiveDice) {
            console.log("⚠️ [DICE] rollDice blocked - states:", {
                isAnimating: GAME_STATE.isAnimating,
                isDiceRolling: GAME_STATE.isDiceRolling,
                isCharacterMoving: GAME_STATE.isCharacterMoving,
                hasInteractiveDice: !!this.interactiveDice
            });
            return;
        }
        
        console.log("🎲 [DICE] Starting dice roll...");
        GAME_STATE.isAnimating = true;
        GAME_STATE.isDiceRolling = true;
        
        // ROBUSTHEIT: Notfall-Reset falls Würfeln hängt
        const diceEmergencyTimeout = setTimeout(() => {
            if (GAME_STATE.isDiceRolling) {
                console.error("⚠️ [DICE] Emergency reset - dice roll took too long!");
                GAME_STATE.isAnimating = false;
                GAME_STATE.isDiceRolling = false;
                this.interactiveDice.visible = false;
                this.showStatusMessage("Würfeln unterbrochen - versuche es erneut", 3000, "warning");
            }
        }, 10000); // 10 Sekunden Notfall-Reset
        
        // Speichere Timeout-ID für spätere Bereinigung
        this.currentDiceTimeout = diceEmergencyTimeout;

        const currentTeam = this.getCurrentTeam();
        if (!currentTeam) { 
            console.warn("❌ rollDice: No current team found. GAME_STATE.currentServerTeamTurnId:", GAME_STATE.currentServerTeamTurnId);
            GAME_STATE.isAnimating = false; 
            GAME_STATE.isDiceRolling = false; 
            return; 
        }
        
        console.log("🎲 Rolling dice for team:", currentTeam.name, "ID:", currentTeam.id);
        
        const mii = this.miiCharacters[currentTeam.id];
        if (!mii) {
            console.error(`❌ rollDice: Charakter nicht gefunden für Team ${currentTeam.name} (ID: ${currentTeam.id})`);
            console.log('🔍 Verfügbare Charaktere:', Object.keys(this.miiCharacters));
            GAME_STATE.isAnimating = false; 
            GAME_STATE.isDiceRolling = false; 
            return; 
        }
        
        if (!mii.position || !mii.rotation) {
            console.error(`❌ rollDice: Charakter ${currentTeam.name} hat keine gültigen Position/Rotation-Eigenschaften`);
            GAME_STATE.isAnimating = false; 
            GAME_STATE.isDiceRolling = false; 
            return; 
        }

        // 1. Positioniere Kamera sehr nah hinter der Figur
        const characterPosition = mii.position.clone();
        const characterDirection = new THREE.Vector3();
        mii.getWorldDirection(characterDirection);
        characterDirection.y = 0;
        characterDirection.normalize();
        
        // Kamera sehr nah hinter der Figur positionieren (0.5 Felder dahinter)
        const cameraPosition = characterPosition.clone().sub(characterDirection.multiplyScalar(1.2)); // Viel näher
        cameraPosition.y = characterPosition.y + 4; // Niedrigere Vogelperspektive
        
        const lookAtPosition = characterPosition.clone();
        lookAtPosition.y -= 1.0; // Schaue nach unten auf die Figur
        
        // Kamera sanft zur Position bewegen
        this.animateCameraToPosition(cameraPosition, lookAtPosition, 800, () => {
            // DEAKTIVIERT: Keine Charakterdrehung beim Würfeln
            // const centerPos = new THREE.Vector3(0, mii.position.y, 0);
            // this.animateCharacterTurn(mii, centerPos, () => {
            // Direkter Aufruf ohne Drehung:
            
            // 3. Würfel-Animation starten
            this.interactiveDice.position.copy(mii.position).add(new THREE.Vector3(0, 1, 0));
            this.interactiveDice.visible = true;
            this.interactiveDice.rotation.set(
                Math.random() * Math.PI, 
                Math.random() * Math.PI, 
                Math.random() * Math.PI
            );

            this.animateInteractiveDiceRoll((diceResult) => {
                // Bereinige Emergency-Timeout
                if (this.currentDiceTimeout) {
                    clearTimeout(this.currentDiceTimeout);
                    this.currentDiceTimeout = null;
                }
                
                GAME_STATE.diceResult = diceResult;
                console.log("🎲 [DICE] Dice result received:", diceResult);
                
                // Zeige Würfelergebnis direkt auf dem Spielfeld
                this.showDiceResultOnField(mii.position, diceResult, currentTeam.bonus_dice_sides, currentTeam.name);
                
                // Calculate dice result
                const bonusRoll = currentTeam.bonus_dice_sides > 0 ? Math.floor(Math.random() * currentTeam.bonus_dice_sides) + 1 : 0;
                const totalRoll = diceResult + bonusRoll;
                console.log("🎲 Dice result:", diceResult, "Bonus:", bonusRoll, "Total:", totalRoll, "Team:", currentTeam.name);
                
                // WICHTIG: Sende Würfelergebnis an Backend und warte auf Bestätigung
                this.sendDiceResultToServer(currentTeam.id, diceResult, bonusRoll, totalRoll)
                    .then((serverResult) => {
                        console.log("✅ [DICE] Server confirmed dice result, proceeding with movement");
                        
                        // Store server result for later use
                        const hasVictory = serverResult && (serverResult.victory_triggered || serverResult.needs_final_roll);
                        
                        // Always complete the dice animation and show result, even with victory
                        setTimeout(() => {
                    this.interactiveDice.visible = false;

                    const currentPositionIndex = currentTeam.position;
                    let nextFieldIndex = Math.min(currentPositionIndex + 1, this.boardFields.length - 1);
                    if (currentPositionIndex === this.boardFields.length - 1) {
                        nextFieldIndex = currentPositionIndex;
                    }
                    
                    const nextField = this.boardFields[nextFieldIndex];
                    let lookAtTargetPos = mii.position.clone().add(new THREE.Vector3(0, 0, 1));
                    if(nextField && nextField.mesh) {
                        lookAtTargetPos = nextField.mesh.position.clone();
                    }

                    // DEAKTIVIERT: Keine Charakterdrehung vor Bewegung
                    // const centerPos = new THREE.Vector3(0, mii.position.y, 0);
                    // this.animateCharacterTurn(mii, centerPos, () => {
                    // Direkter Aufruf ohne Drehung:
                    GAME_STATE.isDiceRolling = false;
                    
                    // ✅ VICTORY FIX: Ensure dice states are properly reset even with victory
                    if (hasVictory) {
                        console.log("🎯 [DICE] Victory condition detected - ensuring proper state cleanup");
                        GAME_STATE.isAnimating = false;
                        // Still allow camera follow and movement to complete
                    }
                    
                    if (!GAME_STATE.freeCameraMode) {
                        this.startCameraFollow(mii);
                    }
                            this.actuallyMoveCharacter(currentTeam, mii, totalRoll, currentPositionIndex);
                            // }); // Ursprüngliche Klammer für animateCharacterTurn callback
                        }, 1000);
                    })
                    .catch(error => {
                        console.error("❌ [DICE] Failed to send dice result, proceeding anyway:", error);
                        // Bei Fehlern trotzdem fortfahren - reset states properly
                        GAME_STATE.isDiceRolling = false;
                        GAME_STATE.isAnimating = false;
                        this.interactiveDice.visible = false;
                        
                        setTimeout(() => {
                            this.actuallyMoveCharacter(currentTeam, mii, totalRoll, currentPositionIndex);
                        }, 1000);
                    });
            });
            // }); // Ursprüngliche Klammer für animateCharacterTurn callback  
        });
    }

    showDiceResultOnField(position, standardRoll, bonusDiceSides, teamName = null) {
        // Entferne vorherige Würfelergebnis-Anzeige
        const existingResult = this.scene.getObjectByName('diceResultDisplay');
        if (existingResult) this.scene.remove(existingResult);

        const group = new THREE.Group();
        group.name = 'diceResultDisplay';
        
        // Erstelle Hintergrund-Kreis
        const circleGeometry = new THREE.CircleGeometry(0.8, 24);
        const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFD700,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        circle.rotation.x = -Math.PI / 2;
        group.add(circle);

        // Erstelle Zahlen-Text (simuliert mit Geometrie)
        const numberGeometry = new THREE.RingGeometry(0.3, 0.5, 8);
        const numberMaterial = new THREE.MeshBasicMaterial({
            color: 0x1a237e,
            transparent: true,
            opacity: 0.8
        });
        const numberDisplay = new THREE.Mesh(numberGeometry, numberMaterial);
        numberDisplay.rotation.x = -Math.PI / 2;
        numberDisplay.position.y = 0.02;
        group.add(numberDisplay);

        // Positioniere über dem Character
        group.position.copy(position);
        group.position.y += 2.5;
        
        this.scene.add(group);

        // Berechne Bonus-Würfel und Gesamtergebnis
        const bonusRoll = bonusDiceSides > 0 ? Math.floor(Math.random() * bonusDiceSides) + 1 : 0;
        const totalRoll = standardRoll + bonusRoll;
        
        // Show dice result display
        const teamPrefix = teamName ? `${teamName} würfelt: ` : 'Würfelergebnis: ';
        let diceMessage = `${teamPrefix}${standardRoll}`;
        if (bonusRoll > 0) {
            diceMessage += ` + ${bonusRoll} (Bonus) = ${totalRoll} Felder`;
        } else {
            diceMessage += ` Felder`;
        }
        
        // Prüfe ob es ein Befreiungsversuch ist
        const currentTeam = this.getCurrentTeam();
        if (currentTeam && currentTeam.is_blocked) {
            // Note: The actual barrier check logic is done server-side which considers
            // both individual dice and the total. This is just a preview.
            const requiredNumber = currentTeam.blocked_target_number || 4;
            let requirementText = `benötigt ${requiredNumber}+`;
            let barrierConfig = null;
            
            // Try to get more detailed requirement from blocked_config if available
            if (currentTeam.blocked_config) {
                try {
                    barrierConfig = JSON.parse(currentTeam.blocked_config);
                    if (barrierConfig.display_text) {
                        requirementText = barrierConfig.display_text;
                    }
                } catch (e) {
                    // Fallback to simple requirement
                }
            }
            
            // Check barrier release with the same logic as server-side
            const canBeFreed = this.checkBarrierRelease(standardRoll, bonusRoll, totalRoll, barrierConfig || {numbers: Array.from({length: 7-requiredNumber}, (_, i) => i + requiredNumber)});
            
            if (canBeFreed.released) {
                let freeMethod = '';
                if (canBeFreed.method === 'standard') {
                    freeMethod = ' (Standard-Würfel befreit!)';
                } else if (canBeFreed.method === 'bonus') {
                    freeMethod = ' (Bonus-Würfel befreit!)';
                } else if (canBeFreed.method === 'total') {
                    freeMethod = ' (Gesamtwurf befreit!)';
                }
                diceMessage += freeMethod;
                console.log("✅ Barrier released:", diceMessage);
            } else {
                diceMessage += ` - ${requirementText}`;
                console.log("❌ Barrier failed:", diceMessage);
            }
        } else {
            // Log dice result for normal dice rolls
            console.log("🎲 Normal dice result:", standardRoll, bonusRoll, totalRoll, teamName);
            
            // HINWEIS: Echte Würfelergebnis-Notifications werden jetzt über last_dice_result vom Server gehandhabt
            // Diese Funktion wird hauptsächlich für 3D-Anzeige verwendet
        }
        
        // Also show the dice result overlay for better visibility
        // Note: bonusRoll and totalRoll are already calculated above
        console.log("🎲 Zeige Dice Result Display:", {standard: standardRoll, bonus: bonusRoll, total: totalRoll});
        this.showDiceResult(standardRoll, bonusRoll, totalRoll, 3000); // Increased to 3 seconds

        // Animation der 3D-Anzeige
        let time = 0;
        const animateDiceResult = () => {
            time += 0.02;
            if (time > 1) {
                this.scene.remove(group);
                return;
            }
            
            // Pulsing Animation
            const scale = 1 + Math.sin(time * Math.PI * 4) * 0.1;
            group.scale.setScalar(scale);
            
            // Fade out
            if (time > 0.7) {
                const fadeProgress = (time - 0.7) / 0.3;
                circle.material.opacity = 0.9 * (1 - fadeProgress);
                numberDisplay.material.opacity = 0.8 * (1 - fadeProgress);
            }
            
            requestAnimationFrame(animateDiceResult);
        };
        animateDiceResult();
    }

    showFieldTypeAnnouncement(fieldType, position, teamName) {
        const fieldConfig = BOARD_CONFIG.fieldTypes[fieldType] || BOARD_CONFIG.fieldTypes.normal;
        
        // Bestimme Nachricht basierend auf Feldtyp
        let title = fieldConfig.name || fieldType;
        let description = "";
        let icon = fieldConfig.icon || "⬜";
        let fieldColor = "#4FC3F7"; // Standard-Blau
        
        // Spezielle Nachrichten für verschiedene Feldtypen mit detaillierten Informationen
        switch(fieldType) {
            case 'start':
                title = "Startfeld";
                description = `${teamName} ist am Startfeld angekommen!`;
                icon = "🏁";
                fieldColor = "#4FC3F7";
                break;
            case 'goal':
                title = "ZIEL ERREICHT!";
                description = `🎉 ${teamName} hat das Spiel gewonnen! 🎉`;
                icon = "🎯";
                fieldColor = "#FFD700";
                break;
            case 'normal':
                title = "Normales Feld";
                description = `${teamName} ist auf einem ruhigen Feld gelandet. Nichts Besonderes passiert.`;
                icon = "⬜";
                fieldColor = "#81C784";
                break;
            case 'minigame':
                title = "Minispiel-Feld";
                description = `${teamName} ist auf einem Minispiel-Feld gelandet! Bereite dich auf eine Herausforderung vor.`;
                icon = "🎮";
                fieldColor = "#BA68C8";
                break;
            case 'catapult_forward':
                title = "Katapult Vorwärts!";
                description = `${teamName} wurde von einem Katapult erfasst! Du wirst 3-5 Felder nach vorne geschleudert.`;
                icon = "🚀";
                fieldColor = "#4CAF50";
                break;
            case 'catapult_backward':
                title = "Katapult Rückwärts!";
                description = `${teamName} wurde von einem Katapult erfasst! Du wirst 2-4 Felder zurück geschleudert.`;
                icon = "💥";
                fieldColor = "#F44336";
                break;
            case 'player_swap':
                title = "Spieler-Tausch!";
                description = `${teamName} aktiviert einen Positionstausch! Du tauschst deine Position mit einem anderen zufällig ausgewählten Team.`;
                icon = "🔄";
                fieldColor = "#2196F3";
                break;
            case 'barrier':
                title = "Sperrfeld!";
                description = `${teamName} ist auf einem Sperrfeld gelandet! Du bist blockiert und musst die konfigurierte Anforderung erfüllen, um dich zu befreien.`;
                icon = "🚧";
                fieldColor = "#9E9E9E";
                break;
            default:
                title = fieldConfig.name || "Unbekanntes Feld";
                description = `${teamName} betritt ${title}.`;
                break;
        }

        // Log field announcement
        if (fieldType === "barrier") {
            console.log("🚧 Barrier field:", targetConfig);
        } else {
            console.log("ℹ️ Field info:", title, description);
        }
    }


    showDiceResult(standard, bonus, total, autoHideDuration = 2500) {
        console.log("🎯 showDiceResult aufgerufen:", {standard, bonus, total, autoHideDuration});
        
        const display = document.getElementById('dice-result-display');
        const standardEl = document.getElementById('dice-result-standard')?.querySelector('span');
        const bonusElGroup = document.getElementById('dice-result-bonus');
        const bonusEl = bonusElGroup?.querySelector('span');
        const totalEl = display?.querySelector('.dice-result-number');

        if (display && standardEl && bonusElGroup && bonusEl && totalEl) {
            console.log("✅ Alle Dice Result Elemente gefunden, zeige Display an");
            
            standardEl.textContent = standard;
            if (bonus > 0) {
                bonusEl.textContent = bonus;
                bonusElGroup.style.display = 'block';
                console.log("💰 Bonus-Würfel angezeigt:", bonus);
            } else {
                bonusElGroup.style.display = 'none';
            }
            totalEl.textContent = total;
            display.style.display = 'flex';
            display.classList.add('show');
            
            // Auto-hide after specified duration
            if (autoHideDuration > 0) {
                setTimeout(() => {
                    console.log("⏰ Auto-hide Dice Result nach", autoHideDuration, "ms");
                    this.hideDiceResult();
                }, autoHideDuration);
            }
        } else {
            console.error("❌ Dice Result Display Elemente nicht gefunden:", {
                display: !!display,
                standardEl: !!standardEl,
                bonusElGroup: !!bonusElGroup,
                bonusEl: !!bonusEl,
                totalEl: !!totalEl
            });
        }
    }

    hideDiceResult() {
        const display = document.getElementById('dice-result-display');
        if (display) {
            display.classList.remove('show');
            setTimeout(() => {
                display.style.display = 'none';
            }, 300);
        }
    }

    animateInteractiveDiceRoll(callback) {
        const rollAnimationDuration = 1400;
        const settleDuration = 300;
        const totalDuration = rollAnimationDuration + settleDuration;
        const startTime = Date.now();
        
        console.log("🎲 [DICE] Starting dice roll animation...");
        
        const diceStartPos = this.interactiveDice.position.clone();
        const jumpHeight = 0.25;
        
        const initialAngularVelocity = {
            x: (Math.random() - 0.5) * 0.25,
            y: (Math.random() - 0.5) * 0.25,
            z: (Math.random() - 0.5) * 0.25
        };

        const targetRotations = {
            1: new THREE.Euler(0, 0, -Math.PI / 2),
            2: new THREE.Euler(0, 0, 0),
            3: new THREE.Euler(Math.PI / 2, 0, 0),
            4: new THREE.Euler(-Math.PI / 2, 0, 0),
            5: new THREE.Euler(Math.PI, 0, 0),
            6: new THREE.Euler(0, 0, Math.PI / 2)
        };
        
        const finalDiceResult = Math.floor(Math.random() * 6) + 1;
        const finalRotation = targetRotations[finalDiceResult];
        
        const toCameraVector = new THREE.Vector3().subVectors(this.camera.position, this.interactiveDice.position);
        toCameraVector.y = 0;
        toCameraVector.normalize();
        const angleToCamera = Math.atan2(toCameraVector.x, toCameraVector.z);
        
        const finalQuaternion = new THREE.Quaternion();
        const euler = new THREE.Euler(finalRotation.x, angleToCamera, finalRotation.z);
        finalQuaternion.setFromEuler(euler);

        let bounceCount = 0;
        let lastBounceTime = startTime;
        let animationCompleted = false;
        
        // ROBUSTHEIT: Backup-Timeout falls Animation hängt
        const emergencyTimeout = setTimeout(() => {
            if (!animationCompleted) {
                console.warn("⚠️ [DICE] Emergency timeout triggered - completing dice roll");
                animationCompleted = true;
                this.interactiveDice.quaternion.copy(finalQuaternion);
                this.interactiveDice.position.y = diceStartPos.y;
                if (callback) {
                    callback(finalDiceResult);
                }
            }
        }, totalDuration + 2000); // 2 Sekunden Puffer
        
        const finalizeDiceRoll = () => {
            if (animationCompleted) return; // Verhindere doppelte Aufrufe
            animationCompleted = true;
            clearTimeout(emergencyTimeout);
            
            this.interactiveDice.quaternion.copy(finalQuaternion);
            this.interactiveDice.position.y = diceStartPos.y;
            
            console.log("✅ [DICE] Dice roll completed with result:", finalDiceResult);
            
            if (callback) {
                callback(finalDiceResult);
            }
        };
        
        const animateDiceFrame = () => {
            if (animationCompleted) return; // Stop wenn bereits abgeschlossen
            
            const currentTime = Date.now();
            const elapsedTime = currentTime - startTime;
            
            // ROBUSTHEIT: Maximale Laufzeit prüfen
            if (elapsedTime > totalDuration + 1000) {
                console.warn("⚠️ [DICE] Animation exceeded maximum duration - forcing completion");
                finalizeDiceRoll();
                return;
            }
            
            if (elapsedTime < rollAnimationDuration) {
                const rollProgress = elapsedTime / rollAnimationDuration;
                const rollSpeed = Math.max(0.1, 1 - rollProgress * 0.7);
                
                const dampening = Math.pow(rollSpeed, 1.2);
                this.interactiveDice.rotation.x += initialAngularVelocity.x * dampening;
                this.interactiveDice.rotation.y += initialAngularVelocity.y * dampening;
                this.interactiveDice.rotation.z += initialAngularVelocity.z * dampening;

                const timeSinceLastBounce = currentTime - lastBounceTime;
                const bounceInterval = 250 - (bounceCount * 30);
                
                if (timeSinceLastBounce > bounceInterval && bounceCount < 3) {
                    bounceCount++;
                    lastBounceTime = currentTime;
                }
                
                const bounceProgress = (timeSinceLastBounce % bounceInterval) / bounceInterval;
                const currentBounceHeight = jumpHeight * Math.max(0.3, 1 - (bounceCount * 0.2));
                const bounceY = Math.sin(bounceProgress * Math.PI) * currentBounceHeight;
                
                this.interactiveDice.position.y = diceStartPos.y + bounceY;

                requestAnimationFrame(animateDiceFrame);
            } else {
                const settleStartTime = startTime + rollAnimationDuration;
                const settleElapsedTime = currentTime - settleStartTime;
                const settleProgress = Math.min(1, settleElapsedTime / settleDuration);
                
                const landingCurve = 1 - Math.pow(1 - settleProgress, 2.5);
                this.interactiveDice.position.y = diceStartPos.y + (jumpHeight * 0.08) * (1 - landingCurve);
                
                const rotationProgress = this.easeInOutCubic(settleProgress);
                THREE.Quaternion.slerp(
                    this.interactiveDice.quaternion, 
                    finalQuaternion, 
                    this.interactiveDice.quaternion, 
                    rotationProgress * 0.12
                );

                if (settleProgress < 1) {
                    requestAnimationFrame(animateDiceFrame);
                } else {
                    finalizeDiceRoll();
                }
            }
        };
        
        animateDiceFrame();
    }

    // ROBUSTHEIT: Notfall-Reset für Würfelzustände
    resetDiceState() {
        console.log("🔄 [DICE] Resetting dice state...");
        
        GAME_STATE.isDiceRolling = false;
        GAME_STATE.isAnimating = false;
        
        if (this.currentDiceTimeout) {
            clearTimeout(this.currentDiceTimeout);
            this.currentDiceTimeout = null;
        }
        
        if (this.interactiveDice) {
            this.interactiveDice.visible = false;
        }
        
        console.log("✅ [DICE] Dice state reset completed");
    }

    // Plant Spieler-Tausch-Animation für später (wenn Figur angekommen ist)
    schedulePlayerSwapAnimation(team1Name, team2Name, swapData) {
        console.log("🔴 [SWAP DEBUG] schedulePlayerSwapAnimation called!", {
            team1Name,
            team2Name,
            swapData,
            currentStates: {
                isCharacterMoving: GAME_STATE.isCharacterMoving,
                isAnimating: GAME_STATE.isAnimating,
                swapInProgress: this.swapInProgress
            }
        });
        
        // WICHTIG: Blockiere normale Bewegungslogik für Tausch (falls noch nicht gesetzt)
        if (!this.swapInProgress) {
            this.swapInProgress = true;
            this.swapTeams = [team1Name, team2Name];
        }
        
        console.log("🔴 [SWAP DEBUG] Swap state set:", {
            swapInProgress: this.swapInProgress,
            swapTeams: this.swapTeams
        });
        
        // Finde das aktuelle Team (das sich bewegt)
        const movingTeam = localTeams.find(t => t.name === team1Name);
        if (!movingTeam) {
            console.error("⚠️ [SWAP] Could not find moving team:", team1Name);
            this.swapInProgress = false;
            return;
        }
        
        // Prüfe ob das Team gerade in Bewegung ist
        if (GAME_STATE.isCharacterMoving) {
            console.log("🔴 [SWAP DEBUG] Character is still moving, waiting for movement completion...", {
                isCharacterMoving: GAME_STATE.isCharacterMoving,
                isAnimating: GAME_STATE.isAnimating,
                pendingSwapExists: !!this.pendingPlayerSwap
            });
            
            // Speichere die Animation für später
            this.pendingPlayerSwap = {
                team1Name,
                team2Name,
                swapData,
                timestamp: Date.now()
            };
            
            console.log("🔴 [SWAP DEBUG] Pending swap saved, starting polling...");
            // Starte Polling um zu prüfen wann die Bewegung fertig ist
            this.checkForMovementCompletion();
        } else {
            // Figur ist bereits angekommen, starte Animation sofort
            console.log("🔴 [SWAP DEBUG] Character already arrived, starting swap animation immediately");
            this.animatePlayerSwap(team1Name, team2Name, swapData);
        }
    }
    
    // Prüft zyklisch ob die Bewegung abgeschlossen ist
    checkForMovementCompletion() {
        if (!this.pendingPlayerSwap) return;
        
        const checkInterval = setInterval(() => {
            // Timeout nach 10 Sekunden als Sicherheit
            const elapsed = Date.now() - this.pendingPlayerSwap.timestamp;
            if (elapsed > 10000) {
                console.warn("⚠️ [SWAP] Timeout waiting for movement completion, starting swap anyway");
                this.executePendingPlayerSwap();
                clearInterval(checkInterval);
                return;
            }
            
            // Prüfe ob Bewegung abgeschlossen ist
            if (!GAME_STATE.isCharacterMoving && !GAME_STATE.isAnimating) {
                console.log("✅ [SWAP] Movement completed, executing pending player swap");
                this.executePendingPlayerSwap();
                clearInterval(checkInterval);
            }
        }, 200); // Alle 200ms prüfen
    }
    
    // Führt die wartende Tausch-Animation aus
    executePendingPlayerSwap() {
        if (!this.pendingPlayerSwap) return;
        
        const { team1Name, team2Name, swapData } = this.pendingPlayerSwap;
        this.pendingPlayerSwap = null; // Bereinige
        
        // Kleine Verzögerung damit die Figur definitiv angekommen ist
        setTimeout(() => {
            this.animatePlayerSwap(team1Name, team2Name, swapData);
        }, 500);
    }

    // Animiere Spieler-Tausch mit Flug-Effekt
    animatePlayerSwap(team1Name, team2Name, swapData) {
        console.log("🔴 [SWAP DEBUG] animatePlayerSwap called!", {
            team1Name,
            team2Name,
            swapData
        });
        
        console.log("🔄 [SWAP] Starting player swap animation between", team1Name, "and", team2Name);
        
        // Blockiere weitere Updates während der Animation
        GAME_STATE.isAnimating = true;
        GAME_STATE.isCharacterMoving = true;
        
        // Finde die beiden Teams
        const team1 = localTeams.find(t => t.name === team1Name);
        const team2 = localTeams.find(t => t.name === team2Name);
        
        if (!team1 || !team2) {
            console.error("⚠️ [SWAP] Could not find teams for swap:", { team1Name, team2Name });
            this.resetSwapState();
            return;
        }
        
        const character1 = this.miiCharacters[team1.id];
        const character2 = this.miiCharacters[team2.id];
        
        if (!character1 || !character2) {
            console.error("⚠️ [SWAP] Could not find characters for swap:", {
                team1: team1.id,
                team2: team2.id,
                char1: !!character1,
                char2: !!character2
            });
            this.resetSwapState();
            return;
        }
        
        // Speichere aktuelle Positionen (wo sie jetzt sind)
        const currentPos1 = character1.position.clone();
        const currentPos2 = character2.position.clone();
        
        // Berechne Zielpositionen basierend auf den Backend-Positionen (verwende finalSwapPosition wenn verfügbar)
        const targetPosition1 = team1.finalSwapPosition !== undefined ? team1.finalSwapPosition : team1.position;
        const targetPosition2 = team2.finalSwapPosition !== undefined ? team2.finalSwapPosition : team2.position;
        
        const targetField1 = this.boardFields[targetPosition1];
        const targetField2 = this.boardFields[targetPosition2];
        
        console.log("🔄 [SWAP DEBUG] Target positions:", {
            team1: team1.name,
            team1_current: team1.position,
            team1_final: team1.finalSwapPosition,
            team1_target: targetPosition1,
            team2: team2.name,
            team2_current: team2.position,
            team2_final: team2.finalSwapPosition,
            team2_target: targetPosition2
        });
        
        if (!targetField1 || !targetField2) {
            console.error("⚠️ [SWAP] Could not find target fields:", {
                team1Pos: targetPosition1,
                team2Pos: targetPosition2
            });
            this.resetSwapState();
            return;
        }
        
        const targetPos1 = targetField1.mesh.position.clone();
        const targetPos2 = targetField2.mesh.position.clone();
        targetPos1.y += BOARD_CONFIG.characterElevation;
        targetPos2.y += BOARD_CONFIG.characterElevation;
        
        console.log("🚀 [SWAP] Animating swap:", {
            team1: team1Name,
            team2: team2Name,
            currentPos1: currentPos1,
            currentPos2: currentPos2,
            targetPos1: targetPos1,
            targetPos2: targetPos2
        });
        
        // Animation-Parameter - Maximal 3 Sekunden wie gewünscht
        const flyHeight = 8.0; // Höhe des Fluges
        const animationDuration = 3000; // 3.0 Sekunden total (Maximum wie gewünscht)
        const startTime = Date.now();
        
        // Kamera auf Übersicht setzen für die gesamte Animation
        this.showPlayerSwapView(animationDuration + 1000);
        
        const animateSwap = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            
            // Verbesserte Easing-Funktion für sehr weiche Animation (ease-in-out-quart)
            const easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
            const easedProgress = easeInOutQuart(progress);
            
            // Berechne Flugbahn (Parabel)
            const heightFactor = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
            const currentHeight1 = currentPos1.y + (flyHeight * heightFactor);
            const currentHeight2 = currentPos2.y + (flyHeight * heightFactor);
            
            // Interpoliere zu den korrekten Zielpositionen
            const animPos1 = new THREE.Vector3(
                currentPos1.x + (targetPos1.x - currentPos1.x) * easedProgress,
                currentHeight1,
                currentPos1.z + (targetPos1.z - currentPos1.z) * easedProgress
            );
            
            const animPos2 = new THREE.Vector3(
                currentPos2.x + (targetPos2.x - currentPos2.x) * easedProgress,
                currentHeight2,
                currentPos2.z + (targetPos2.z - currentPos2.z) * easedProgress
            );
            
            // Setze neue Positionen
            character1.position.copy(animPos1);
            character2.position.copy(animPos2);
            
            if (progress < 1) {
                requestAnimationFrame(animateSwap);
            } else {
                // Animation abgeschlossen - setze finale Positionen
                character1.position.copy(targetPos1);
                character2.position.copy(targetPos2);
                
                console.log("✅ [SWAP] Player swap animation completed successfully");
                
                // Reset Animation States
                GAME_STATE.isAnimating = false;
                GAME_STATE.isCharacterMoving = false;
                this.resetSwapState();
                
                // Aktualisiere Team-Badges an finalen Positionen
                this.updateTeamBadgeForTeam(team1.id, targetPosition1);
                this.updateTeamBadgeForTeam(team2.id, targetPosition2);
                
                console.log("📊 [SWAP] Updated team positions to final backend positions:", {
                    [team1Name]: targetPosition1,
                    [team2Name]: targetPosition2
                });
                
                // Zeige Abschluss-Nachricht
                setTimeout(() => {
                    this.showStatusMessage(
                        `Positionstausch abgeschlossen! ${team1Name} und ${team2Name} haben ihre Plätze getauscht.`,
                        3000,
                        'success',
                        true,
                        'Tausch abgeschlossen'
                    );
                }, 500);
            }
        };
        
        // Animation starten
        animateSwap();
    }
    
    // NEUE EINFACHE Player Swap Animation
    startImmediatePlayerSwap(team1Name, team2Name, swapData) {
        console.log("SWAP - Starting IMMEDIATE player swap animation:", team1Name, "<->", team2Name);
        
        // Stoppe alle anderen Animationen sofort
        GAME_STATE.isAnimating = true;
        GAME_STATE.isCharacterMoving = true;
        this.activeMovementAnimation = null;
        
        // WICHTIG: Blockiere normale Bewegungslogik für diese Teams
        this.swapInProgress = true;
        this.swapTeams = [team1Name, team2Name];
        console.log("SWAP - Blocking normal movement for both teams during swap");
        
        // Finde die beiden Teams
        const team1 = localTeams.find(t => t.name === team1Name);
        const team2 = localTeams.find(t => t.name === team2Name);
        
        if (!team1 || !team2) {
            console.error("SWAP - Could not find teams:", { team1Name, team2Name });
            return;
        }
        
        const character1 = this.miiCharacters[team1.id];
        const character2 = this.miiCharacters[team2.id];
        
        if (!character1 || !character2) {
            console.error("⚠️ [SWAP] Could not find characters:", { team1, team2 });
            return;
        }
        
        // Aktualisiere Team-Positionen SOFORT auf finale Ziele (aus Server-Event-Daten)
        const team1FinalPos = swapData.swap_team_new_position || team2.position;
        const team2FinalPos = swapData.current_team_new_position || team1.position;
        
        team1.position = team1FinalPos;
        team2.position = team2FinalPos;
        
        console.log("🎯 [SWAP] Team positions updated:", {
            [team1Name]: team1FinalPos,
            [team2Name]: team2FinalPos
        });
        
        // Berechne Zielpositionen
        const targetField1 = this.boardFields[team1FinalPos];
        const targetField2 = this.boardFields[team2FinalPos];
        
        if (!targetField1 || !targetField2) {
            console.error("⚠️ [SWAP] Could not find target fields");
            this.resetSimpleSwapState();
            return;
        }
        
        const targetPos1 = targetField1.mesh.position.clone();
        const targetPos2 = targetField2.mesh.position.clone();
        targetPos1.y += BOARD_CONFIG.characterElevation;
        targetPos2.y += BOARD_CONFIG.characterElevation;
        
        // Kamera in Orbit setzen
        console.log("🎥 [SWAP] Setting camera to orbit for swap animation");
        this.requestCameraMode('orbit', {}, 'high');
        
        // Animation starten
        this.animateSimplePlayerSwap(character1, character2, targetPos1, targetPos2, team1Name, team2Name);
    }
    
    // Einfache simultane Animation
    animateSimplePlayerSwap(char1, char2, target1, target2, team1Name, team2Name) {
        const startPos1 = char1.position.clone();
        const startPos2 = char2.position.clone();
        const duration = 3000; // 3 Sekunden
        const startTime = Date.now();
        const flyHeight = 8.0;
        
        console.log("✈️ [SWAP] Starting flight animation for both players");
        
        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Smooth easing
            const easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
            const easedProgress = easeInOutQuart(progress);
            
            // Flugbahn (Parabel)
            const heightFactor = Math.sin(progress * Math.PI);
            
            // Player 1 Animation
            const pos1 = new THREE.Vector3(
                startPos1.x + (target1.x - startPos1.x) * easedProgress,
                startPos1.y + (target1.y - startPos1.y) * easedProgress + (flyHeight * heightFactor),
                startPos1.z + (target1.z - startPos1.z) * easedProgress
            );
            
            // Player 2 Animation
            const pos2 = new THREE.Vector3(
                startPos2.x + (target2.x - startPos2.x) * easedProgress,
                startPos2.y + (target2.y - startPos2.y) * easedProgress + (flyHeight * heightFactor),
                startPos2.z + (target2.z - startPos2.z) * easedProgress
            );
            
            char1.position.copy(pos1);
            char2.position.copy(pos2);
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation fertig
                char1.position.copy(target1);
                char2.position.copy(target2);
                
                console.log("✅ [SWAP] Player swap animation completed successfully");
                
                this.resetSimpleSwapState();
                
                // Status-Nachricht
                setTimeout(() => {
                    this.showStatusMessage(
                        `Positionstausch abgeschlossen! ${team1Name} und ${team2Name} haben ihre Plätze getauscht.`,
                        3000,
                        'success',
                        true,
                        'Tausch abgeschlossen'
                    );
                }, 500);
                
                // Kamera zum nächsten Spieler oder bleibt in Orbit
                setTimeout(() => {
                    // Prüfe ob es einen aktiven Spieler gibt, sonst bleibt in Orbit
                    if (GAME_STATE.currentServerTeamTurnId) {
                        const activeTeam = localTeams.find(t => t.id === GAME_STATE.currentServerTeamTurnId);
                        if (activeTeam) {
                            console.log("🎥 [SWAP] Switching camera to active player:", activeTeam.name);
                            this.requestCameraMode('team_focus', {team: activeTeam}, 'normal');
                        } else {
                            console.log("🎥 [SWAP] No active team found, staying in orbit");
                        }
                    } else {
                        console.log("🎥 [SWAP] No current team turn, staying in orbit");
                    }
                }, 1000);
            }
        };
        
        animate();
    }
    
    // Reset für einfaches System
    resetSimpleSwapState() {
        GAME_STATE.isAnimating = false;
        GAME_STATE.isCharacterMoving = false;
        
        // WICHTIG: Auch normale Blockierung aufheben
        this.swapInProgress = false;
        this.swapTeams = null;
        
        console.log("🔄 [SWAP] Simple swap state reset - normal movement re-enabled");
    }

    // Reset Swap-Zustand (alte Funktion für Kompatibilität)
    resetSwapState() {
        // Wende verzögerte Position-Updates an
        if (this.swapTeams && localTeams) {
            this.swapTeams.forEach(teamName => {
                const team = localTeams.find(t => t.name === teamName);
                if (team && team.finalSwapPosition !== undefined) {
                    console.log(`🔄 [SWAP] Applying delayed position update for ${team.name}: ${team.position} -> ${team.finalSwapPosition}`);
                    team.position = team.finalSwapPosition;
                    delete team.finalSwapPosition;
                }
            });
        }
        
        this.swapInProgress = false;
        this.swapTeams = null;
        console.log("🔄 [SWAP] Swap state reset - normal movement logic re-enabled");
    }

    // Sende Würfelergebnis an Backend
    async sendDiceResultToServer(teamId, standardRoll, bonusRoll, totalRoll) {
        try {
            console.log("📤 [DICE] Sending dice result to server:", {
                teamId, 
                standardRoll, 
                bonusRoll, 
                totalRoll
            });
            
            const response = await fetch('/teams/api/team_roll_dice', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    team_id: teamId,
                    standard_roll: standardRoll,
                    bonus_roll: bonusRoll,
                    total_roll: totalRoll,
                    timestamp: new Date().toLocaleTimeString()
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log("✅ [DICE] Dice result successfully sent to server:", result);
                
                // Handle victory conditions from server response
                if (result.victory_triggered) {
                    console.log("🏆 [DICE] Victory triggered from server response!");
                    // Victory will be handled by live updates, just log for now
                } else if (result.needs_final_roll) {
                    console.log("🎯 [DICE] Team needs final roll - notification will be shown");
                    // Final roll notification will be handled by live updates
                }
                
                return result; // Return server result for further processing
            } else {
                console.error("⚠️ [DICE] Server rejected dice result:", result);
                this.showStatusMessage(`Würfelfehler: ${result.error || 'Unbekannter Fehler'}`, 8000, 'error');
                throw new Error(result.error || 'Server rejected dice result');
            }
        } catch (error) {
            console.error("❌ [DICE] Failed to send dice result to server:", error);
            this.showStatusMessage(`Verbindungsfehler beim Würfeln: ${error.message}`, 8000, 'error');
        }
    }

    actuallyMoveCharacter(currentTeam, mii, diceRoll, startPositionIndex) {
        GAME_STATE.isCharacterMoving = true;
        GAME_STATE.isAnimating = true;

        // End Zone Mechanik implementieren
        let endPositionIndex;
        const targetPosition = startPositionIndex + diceRoll;
        const maxPosition = this.boardFields.length - 1; // Position 72 (goal)
        const safeZonePosition = maxPosition - 1; // Position 71 (safe zone)
        
        if (startPositionIndex < safeZonePosition) {
            // Normale Bewegung bis zur Safe Zone
            endPositionIndex = Math.min(targetPosition, safeZonePosition);
        } else if (startPositionIndex === safeZonePosition) {
            // Auf Safe Zone - braucht mindestens 8 zum Gewinnen
            if (diceRoll >= 8) {
                endPositionIndex = maxPosition; // Gewinn!
                console.log(`🏆 Team ${currentTeam.name} hat ${diceRoll} gewürfelt und gewinnt!`);
            } else {
                endPositionIndex = safeZonePosition; // Bleibt auf Safe Zone
                console.log(`🎯 Team ${currentTeam.name} braucht mindestens 8 zum Gewinnen (gewürfelt: ${diceRoll})`);
            }
        } else {
            // Schon im Ziel oder darüber hinaus (sollte nicht passieren)
            endPositionIndex = startPositionIndex;
        }
                
        const pathPositions = [];
        if (startPositionIndex < endPositionIndex) {
            for (let i = startPositionIndex; i <= endPositionIndex; i++) {
                if (this.boardFields[i] && this.boardFields[i].mesh) {
                    const fieldBaseY = this.boardFields[i].mesh.position.y;
                    const characterY = fieldBaseY + BOARD_CONFIG.characterElevation;
                    pathPositions.push(new THREE.Vector3(
                        this.boardFields[i].mesh.position.x, 
                        characterY, 
                        this.boardFields[i].mesh.position.z
                    ));
                }
            }
        } else {
            this.handleMovementCompletion(currentTeam, mii, endPositionIndex);
            return;
        }

        if (pathPositions.length <= 1 && startPositionIndex === endPositionIndex) {
            this.handleMovementCompletion(currentTeam, mii, endPositionIndex);
            return;
        }
        
        if (pathPositions.length >= 2) {
            this.activeCharacterPath = new THREE.CatmullRomCurve3(pathPositions, false, 'catmullrom', 0.5);
            this.animateCharacterAlongPath(mii, pathPositions, () => {
                this.handleMovementCompletion(currentTeam, mii, endPositionIndex);
            });
        } else if (pathPositions.length === 1 && startPositionIndex < endPositionIndex) {
            this.animateCharacterMove(mii, pathPositions[0], () => {
                this.handleMovementCompletion(currentTeam, mii, endPositionIndex);
            }, 300);
        } else {
            this.handleMovementCompletion(currentTeam, mii, endPositionIndex);
        }
    }

    handleVictory(winningTeam, characterMesh) {
        console.log(`🏆 [VICTORY] ${winningTeam.name} hat das Spiel gewonnen!`);
        
        // Zeige Victory Message
        this.showStatusMessage(`🏆 ${winningTeam.name} hat gewonnen! 🎉`, 5000, 'success', true, 'SIEG!');
        
        // Starte Victory Sequence
        setTimeout(() => {
            this.triggerVictoryFireworks();
            this.animateVictory(characterMesh, winningTeam);
            
            // Warte dann weiter zur Goodbye Seite
            setTimeout(() => {
                this.redirectToGoodbye(winningTeam);
            }, 8000); // 8 Sekunden für Feuerwerk und Animation
        }, 2000);
    }
    
    triggerVictoryFireworks() {
        this.showVictoryEffect();
    }
    
    redirectToGoodbye(winningTeam) {
        console.log(`🔄 Weiterleitung zur Goodbye-Seite...`);
        
        // HINWEIS: Victory-Daten werden jetzt bereits vom Backend gesetzt (bei Würfelwurf)
        // Direkte Weiterleitung zur Goodbye-Seite ohne zusätzlichen API-Aufruf
        console.log(`🏆 Victory bereits vom Backend verarbeitet für Team ${winningTeam.name}`);
        window.location.href = "{{ url_for('main.goodbye') }}";
    }

    animateVictory(character, team) {
        GAME_STATE.isAnimating = true;
        const startPosition = character.position.clone();
        let jumpCount = 0;
        
        const celebrateJump = () => {
            const jumpDuration = 300;
            const jumpStartTime = Date.now();
            const jumpHeight = 0.5;
            
            const animateSingleJump = () => {
                const jumpTime = Date.now() - jumpStartTime;
                const jumpProgress = Math.min(1, jumpTime / jumpDuration);
                character.position.y = startPosition.y + Math.sin(jumpProgress * Math.PI) * jumpHeight;
                // Idle Animation ohne Rotationänderung
                
                if (jumpProgress < 1) {
                    requestAnimationFrame(animateSingleJump);
                } else {
                    jumpCount++;
                    if (jumpCount < 4) {
                        setTimeout(celebrateJump, 60);
                    } else {
                        character.position.y = startPosition.y;
                    }
                }
            };
            animateSingleJump();
        };
        celebrateJump();
    }

    showVictoryEffect() {
        console.log('🎆 Starting enhanced victory fireworks!');
        const colors = [0xFF0066, 0x00FF66, 0x0066FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFD700, 0xFF4500];
        
        // Mehrere Feuerwerk-Wellen für spektakuläreren Effekt
        for (let wave = 0; wave < 3; wave++) {
            setTimeout(() => {
                // Pro Welle mehrere Feuerwerke gleichzeitig
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const baseEffectY = islandSurfaceY + BOARD_CONFIG.mountainHeight + 5;
                        
                        // Verteile Feuerwerke um die Insel herum
                        const angle = (i / 6) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                        const distance = 8 + Math.random() * 8;
                        
                        const pos = new THREE.Vector3(
                            Math.cos(angle) * distance,
                            baseEffectY + Math.random() * 8, 
                            Math.sin(angle) * distance
                        );
                        
                        const particleCount = 50 + Math.random() * 30; // Mehr Partikel
                        const fireworkPositions = new Float32Array(particleCount * 3);
                        const fireworkVelocities = new Float32Array(particleCount * 3);
                        
                        for (let j = 0; j < particleCount; j++) {
                            fireworkPositions[j * 3] = pos.x;
                            fireworkPositions[j * 3 + 1] = pos.y;
                            fireworkPositions[j * 3 + 2] = pos.z;
                            
                            // Realistische 3D-Explosion
                            const phi = Math.random() * Math.PI * 2;
                            const costheta = Math.random() * 2 - 1;
                            const theta = Math.acos(costheta);
                            const speed = 0.1 + Math.random() * 0.15;
                            
                            fireworkVelocities[j * 3] = Math.sin(theta) * Math.cos(phi) * speed;
                            fireworkVelocities[j * 3 + 1] = Math.abs(Math.sin(theta) * Math.sin(phi)) * speed + 0.05; // Nach oben
                            fireworkVelocities[j * 3 + 2] = Math.sin(theta) * Math.sin(phi) * speed;
                        }
                        
                        const fireworkGeometry = new THREE.BufferGeometry();
                        fireworkGeometry.setAttribute('position', new THREE.BufferAttribute(fireworkPositions, 3));
                        
                        const fireworkMaterial = new THREE.PointsMaterial({ 
                            color: color, 
                            size: 0.3 + Math.random() * 0.2, 
                            transparent: true, 
                            opacity: 1,
                            sizeAttenuation: true
                        });
                        
                        const fireworks = new THREE.Points(fireworkGeometry, fireworkMaterial);
                        this.scene.add(fireworks);
                        
                        // Zusätzlicher Lichteffekt
                        const light = new THREE.PointLight(color, 3, 25);
                        light.position.copy(pos);
                        this.scene.add(light);
                        
                        let time = 0;
                        const gravity = -0.008;
                        const drag = 0.98;
                        
                        const animateFirework = () => {
                            time += 0.016;
                            if (time > 4.0) {
                                if(fireworks.parent) this.scene.remove(fireworks);
                                if(light.parent) this.scene.remove(light);
                                fireworkGeometry.dispose();
                                fireworkMaterial.dispose();
                                return;
                            }
                            
                            const currentPositions = fireworks.geometry.attributes.position.array;
                            for (let j = 0; j < particleCount; j++) {
                                // Physik-basierte Bewegung
                                fireworkVelocities[j * 3] *= drag;
                                fireworkVelocities[j * 3 + 1] += gravity;
                                fireworkVelocities[j * 3 + 1] *= drag;
                                fireworkVelocities[j * 3 + 2] *= drag;
                                
                                currentPositions[j * 3] += fireworkVelocities[j * 3];
                                currentPositions[j * 3 + 1] += fireworkVelocities[j * 3 + 1];
                                currentPositions[j * 3 + 2] += fireworkVelocities[j * 3 + 2];
                            }
                            
                            fireworks.geometry.attributes.position.needsUpdate = true;
                            
                            // Funkeln-Effekt
                            const sparkle = Math.sin(time * 15) * 0.3 + 0.7;
                            fireworkMaterial.opacity = Math.max(0, (1 - (time / 4.0)) * sparkle);
                            
                            // Licht verblasst
                            light.intensity = Math.max(0, 3 * (1 - time / 2.0));
                            
                            requestAnimationFrame(animateFirework);
                        };
                        animateFirework();
                        
                    }, i * 150); // Schnellere Aufeinanderfolge
                }
            }, wave * 1500); // Wellen-Delay
        }
    }

    updateCanvasSize() {
        const container = document.getElementById('game-canvas-container');
        if (!container) return;
        
        let width, height;
        
        const isInFullscreen = document.fullscreenElement === container ||
                              document.webkitFullscreenElement === container ||
                              document.mozFullScreenElement === container;
        
        if (isInFullscreen) {
            width = window.innerWidth;
            height = window.innerHeight;
            GAME_STATE.isFullscreen = true;
        } else {
            // Respektiere die CSS-Zentrierung - verwende die festen Container-Dimensionen
            width = 800;
            height = 600;
            GAME_STATE.isFullscreen = false;
        }
        
        // Setze nur die Renderer-Größe, nicht die Container-Größe (CSS bleibt intakt)
        this.renderer.setSize(width, height, false);
        
        if (this.camera) {
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
        }
    }

    toggleFullscreen() {
        const container = document.getElementById('game-canvas-container');
        
        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
            if (container && container.requestFullscreen) {
                container.requestFullscreen().then(() => {
                    setTimeout(() => this.updateCanvasSize(), 200);
                }).catch(err => {
                    this.showStatusMessage(`Fehler Vollbild: ${err.message}`, 8000, 'error');
                });
            } else if (container && container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
                setTimeout(() => this.updateCanvasSize(), 200);
            } else if (container && container.mozRequestFullScreen) {
                container.mozRequestFullScreen();
                setTimeout(() => this.updateCanvasSize(), 200);
            } else {
                this.showStatusMessage('Vollbild wird nicht unterstützt', 8000, 'error');
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
        }
    }

    updateCharacterAnimations(time) {
        Object.values(this.miiCharacters).forEach(characterModel => {
            if (characterModel.userData && characterModel.userData.animation) {
                characterModel.userData.animation(time);
            }
            
            characterModel.children.forEach(child => {
                if (child.userData && child.userData.isBlockedEffect && child.userData.animation) {
                    child.userData.animation(time);
                }
            });
        });
        
        this.boardFields.forEach(field => {
            if (field.mesh.userData.animation) {
                field.mesh.userData.animation(time);
            }
        });
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        const time = Date.now() * 0.001;

        if (this.water && this.water.userData.animation) {
            this.water.userData.animation(time);
        }
        
        if (this.skyMesh && this.skyMesh.userData.animation) {
            this.skyMesh.userData.animation(time);
        }
        
        if (this.clouds) {
            this.clouds.forEach(cloudData => {
                const cloud = cloudData.mesh;
                cloud.position.x += cloudData.speed * cloudData.direction * (GAME_STATE.freeCameraMode ? 0.3 : 1);
                cloud.position.y = cloudData.baseY + Math.sin(time * 0.15 + cloudData.speed * 6) * 1.2;
                
                if (cloud.position.x > 80 && cloudData.direction === 1) cloud.position.x = -80;
                if (cloud.position.x < -80 && cloudData.direction === -1) cloud.position.x = 80;
            });
        }

        // Automatic camera management system - runs continuously
        this.updateAutomaticCamera();

        // GTA5-style camera following logic
        if (!GAME_STATE.freeCameraMode && this.isFollowingCharacter && !GAME_STATE.isAnimatingCamera && this.gtaFollowActive) {
            this.updateGTAFollow();
        }
        
        if (GAME_STATE.freeCameraMode && !GAME_STATE.isAnimatingCamera && !GAME_STATE.cameraTransitioning) {
            this.controls.update();
        }
        
        this.updateCharacterAnimations(time);
        this.animateAnimals(time);
        
        // Safety check: Ensure camera is always at a valid position
        if (!GAME_STATE.freeCameraMode && (isNaN(this.camera.position.x) || isNaN(this.camera.position.y) || isNaN(this.camera.position.z))) {
            console.warn('🚨 Camera position invalid, resetting to safe position');
            this.camera.position.set(25, 20, 25);
            this.camera.lookAt(0, 5, 0);
            this.controls.target.set(0, 5, 0);
        }
        
        this.renderer.render(this.scene, this.camera);
    }
    
    animateAnimals(time) {
        // Animate rabbits
        if (this.rabbits) {
            this.rabbits.forEach(rabbit => {
                const data = rabbit.userData;
                data.changeDirectionTimer += 0.016;
                
                // Change direction randomly
                if (data.changeDirectionTimer > 2 + Math.random() * 3) {
                    data.direction += (Math.random() - 0.5) * 1.5;
                    data.changeDirectionTimer = 0;
                }
                
                // Move rabbit
                const moveSpeed = data.speed * 0.016;
                const newX = rabbit.position.x + Math.cos(data.direction) * moveSpeed;
                const newZ = rabbit.position.z + Math.sin(data.direction) * moveSpeed;
                
                // Keep rabbits on island
                const distanceFromCenter = Math.sqrt(newX * newX + newZ * newZ);
                if (distanceFromCenter < 25 && this.isPositionSafe(newX, newZ, 0.5)) {
                    rabbit.position.x = newX;
                    rabbit.position.z = newZ;
                    rabbit.rotation.y = data.direction + Math.PI / 2;
                }
                
                // Hopping animation
                rabbit.position.y = islandSurfaceY + 0.3 + Math.abs(Math.sin(time * 8 + rabbit.position.x)) * 0.1;
            });
        }
        
        // Gelegentlich neuen Vogelschwarm erstellen
        const currentTime = Date.now();
        if (currentTime - this.lastBirdFlockTime > 15000 + Math.random() * 20000) { // 15-35 Sekunden
            this.createBirdFlock();
            this.lastBirdFlockTime = currentTime;
        }
        
        // Animate active birds
        if (this.activeBirds && this.activeBirds.length > 0) {
            for (let i = this.activeBirds.length - 1; i >= 0; i--) {
                const bird = this.activeBirds[i];
                const data = bird.userData;
                const elapsed = currentTime - data.startTime;
                
                // Check if bird should be removed
                if (elapsed > data.flightDuration) {
                    this.scene.remove(bird);
                    this.activeBirds.splice(i, 1);
                    continue;
                }
                
                // Calculate flight progress
                const progress = elapsed / data.flightDuration;
                
                // Move towards target
                const startX = bird.position.x - (data.targetX - bird.position.x) * progress / (1 - progress);
                const startZ = bird.position.z - (data.targetZ - bird.position.z) * progress / (1 - progress);
                
                bird.position.x += (data.targetX - bird.position.x) * data.speed * 0.016;
                bird.position.z += (data.targetZ - bird.position.z) * data.speed * 0.016;
                
                // Smooth flying motion
                bird.position.y = data.targetY + Math.sin(time * data.bobSpeed) * 0.8;
                
                // Wing flapping
                const leftWing = bird.getObjectByName('leftWing');
                const rightWing = bird.getObjectByName('rightWing');
                if (leftWing && rightWing) {
                    const flapAngle = Math.sin(time * data.wingSpeed) * 0.6;
                    leftWing.rotation.z = flapAngle;
                    rightWing.rotation.z = -flapAngle;
                }
            }
        }
    }

    setupTrackpadZoom() {
        // Smartphone Pinch-to-Zoom Support
        let initialTouchDistance = 0;
        let initialCameraDistance = 0;
        let isPinching = false;
        
        // Touch Start - Pinch-Geste beginnen
        this.renderer.domElement.addEventListener('touchstart', (event) => {
            if (!GAME_STATE.freeCameraMode) return;
            
            if (event.touches.length === 2) {
                event.preventDefault();
                
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                // Anfangsdistanz zwischen den Fingern
                initialTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Anfangsdistanz der Kamera zum Zielpunkt
                initialCameraDistance = this.camera.position.distanceTo(this.controls.target);
                
                isPinching = true;
                console.log('Pinch-Geste gestartet, Anfangsdistanz:', initialTouchDistance);
            }
        }, { passive: false });
        
        // Touch Move - Pinch-Zoom ausführen
        this.renderer.domElement.addEventListener('touchmove', (event) => {
            if (!GAME_STATE.freeCameraMode || !isPinching) return;
            
            if (event.touches.length === 2) {
                event.preventDefault();
                
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                // Aktuelle Distanz zwischen den Fingern
                const currentTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (initialTouchDistance > 0) {
                    // Zoom-Faktor basierend auf Finger-Distanz-Änderung
                    const zoomRatio = currentTouchDistance / initialTouchDistance;
                    
                    // Neue Kamera-Distanz berechnen
                    const newCameraDistance = initialCameraDistance / zoomRatio;
                    
                    // Kamera-Position entsprechend anpassen
                    const direction = new THREE.Vector3();
                    this.camera.getWorldDirection(direction);
                    
                    // Neue Position berechnen
                    const newPosition = this.controls.target.clone();
                    newPosition.addScaledVector(direction, -newCameraDistance);
                    
                    this.camera.position.copy(newPosition);
                    this.controls.update();
                    
                    console.log('Zoom-Ratio:', zoomRatio.toFixed(2), 'Neue Distanz:', newCameraDistance.toFixed(2));
                }
            }
        }, { passive: false });
        
        // Touch End - Pinch-Geste beenden
        this.renderer.domElement.addEventListener('touchend', (event) => {
            if (!GAME_STATE.freeCameraMode) return;
            
            if (event.touches.length < 2) {
                isPinching = false;
                initialTouchDistance = 0;
                initialCameraDistance = 0;
                console.log('Pinch-Geste beendet');
            }
        }, { passive: true });
        
        // Laptop-Trackpad Zoom Support (für Trackpad-Gesten)
        this.renderer.domElement.addEventListener('wheel', (event) => {
            if (!GAME_STATE.freeCameraMode) return;
            
            // Nur bei Trackpad-ähnlichen Events (kleine, kontinuierliche Werte)
            const isLikelyTrackpad = Math.abs(event.deltaY) < 50 && event.deltaY % 1 !== 0;
            
            if (isLikelyTrackpad) {
                event.preventDefault();
                
                // Sanfterer Zoom für Trackpad
                const zoomFactor = 1 + (event.deltaY * 0.005);
                
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const distance = this.camera.position.distanceTo(this.controls.target);
                const zoomStep = distance * (1 - zoomFactor) * 0.1;
                
                this.camera.position.addScaledVector(direction, zoomStep);
                this.controls.update();
            }
        }, { passive: false });
    }
}

// SONDERFELD-AKTIONEN HANDLER
let previousSpecialFieldResponse = null;

function handleSpecialFieldResponse(data) {
    if (!data || !data.special_field) return;
    
    const specialField = data.special_field;
    if (!specialField.success) return;
    
    console.log('Sonderfeld-Aktion erkannt:', specialField.action, specialField);
    
    switch(specialField.action) {
        case 'catapult_forward':
            showSpecialFieldEffect(
                'catapult_forward',
                'Katapult Vorwärts!',
                `${data.team_name} fliegt ${specialField.catapult_distance} Felder vorwärts!`,
                5000
            );
            
            // Zeige macOS-style Notification
            if (window.NotificationSystem) {
                const distance = specialField.catapult_distance || '3-5';
                window.NotificationSystem.showCatapultForward(data.team_name, distance);
            }
            break;
        case 'catapult_backward':
            showSpecialFieldEffect(
                'catapult_backward',
                'Katapult Rückwärts!',
                `${data.team_name} wird ${specialField.catapult_distance} Felder zurück geschleudert!`,
                5000
            );
            
            // Zeige macOS-style Notification
            if (window.NotificationSystem) {
                const distance = specialField.catapult_distance || '2-4';
                window.NotificationSystem.showCatapultBackward(data.team_name, distance);
            }
            break;
        case 'player_swap':
            console.log("🔴 [SWAP DEBUG] Player swap case triggered!", {
                team_name: data.team_name,
                swap_team_name: specialField.swap_team_name,
                specialField: specialField,
                swapInProgress: this.swapInProgress
            });
            
            // SOFORT den Tausch-Zustand setzen um normale Bewegungslogik zu blockieren
            this.swapInProgress = true;
            this.swapTeams = [data.team_name, specialField.swap_team_name];
            console.log("🔴 [SWAP DEBUG] Immediately set swap state to block normal movement logic");
            
            showSpecialFieldEffect(
                'player_swap',
                'Positionstausch!',
                `${data.team_name} tauscht mit ${specialField.swap_team_name}!`,
                5000
            );
            
            // Zeige macOS-style Notification
            if (window.NotificationSystem) {
                window.NotificationSystem.showPlayerSwap(data.team_name, specialField.swap_team_name);
            }
            
            // WICHTIG: Starte Tausch-Animation NACH Ankunft am Tauschfeld
            console.log("🔴 [SWAP DEBUG] Calling schedulePlayerSwapAnimation...");
            this.schedulePlayerSwapAnimation(data.team_name, specialField.swap_team_name, specialField);
            break;
        case 'barrier_set':
            // Verwende die korrekte display_text aus der Backend-Antwort
            const displayText = specialField.display_text || `Würfle mindestens eine ${specialField.target_number}!`;
            showSpecialFieldEffect(
                'barrier_set',
                'Blockiert!',
                `${data.team_name} - ${displayText}`,
                6000
            );
            
            // Zeige macOS-style Notification
            if (window.NotificationSystem) {
                window.NotificationSystem.showBarrierSet(data.team_name, specialField.target_number || 4);
            }
            break;
    }
    
    if (specialField.message) {
        setTimeout(() => {
            window.gameBoard.showStatusMessage(specialField.message, 3000, 'special', true, 'Besonderes Feld');
        }, 2000);
    }
}

function handleBarrierCheckResponse(data) {
    if (!data || !data.barrier_check) return;
    
    const barrierCheck = data.barrier_check;
    console.log('Sperren-Check erkannt:', barrierCheck);
    
    // Build detailed dice description
    let diceDescription = `${barrierCheck.dice_roll}`;
    if (barrierCheck.bonus_roll > 0) {
        diceDescription += ` + ${barrierCheck.bonus_roll} (Bonus) = ${barrierCheck.total_roll}`;
    }
    
    if (barrierCheck.released) {
        let releaseMessage = `${data.team_name} hat ${diceDescription} gewürfelt und ist frei!`;
        
        // Add specific information about which die freed the team
        if (barrierCheck.release_method === 'standard') {
            releaseMessage += ' (Standard-Würfel hat befreit!)';
        } else if (barrierCheck.release_method === 'bonus') {
            releaseMessage += ' (Bonus-Würfel hat befreit!)';
        } else if (barrierCheck.release_method === 'total') {
            releaseMessage += ' (Gesamtwurf hat befreit!)';
        }
        
        showSpecialFieldEffect(
            'barrier_released',
            'Befreit!',
            releaseMessage,
            8000
        );
        
        // Zeige macOS-style Notification
        if (window.NotificationSystem) {
            window.NotificationSystem.showBarrierReleased(
                data.team_name, 
                barrierCheck.dice_roll, 
                barrierCheck.bonus_roll || 0,
                barrierCheck.release_method
            );
        }
    } else {
        // Get display text from barrier config
        let requiredText = barrierCheck.barrier_config?.display_text || `${barrierCheck.barrier_config?.min_number || 4}+ benötigt`;
        
        setTimeout(() => {
            window.gameBoard.showStatusMessage(
                `${data.team_name} bleibt blockiert! (${diceDescription} gewürfelt, ${requiredText})`, 
                3000, 
                'warning', 
                true, 
                'Blockiert'
            );
        }, 1500);
        
        // Zeige macOS-style Notification
        if (window.NotificationSystem) {
            console.log('📱 Calling showBarrierFailed with:', {
                teamName: data.team_name,
                diceRoll: barrierCheck.dice_roll,
                bonusRoll: barrierCheck.bonus_roll || 0,
                requiredText: requiredText
            });
            window.NotificationSystem.showBarrierFailed(
                data.team_name,
                barrierCheck.dice_roll,
                barrierCheck.bonus_roll || 0,
                requiredText
            );
        } else {
            console.error('❌ NotificationSystem not available for barrier failed!');
        }
    }
}

// HAUPTINITIALISIERUNG
document.addEventListener('DOMContentLoaded', async function() {
    try {
        if (document.getElementById('game-canvas')) {
            console.log('🎮 Initialisiere dynamisches Spielbrett...');
            
            // Erstelle Spielbrett-Instanz
            window.gameBoard = new WiiPartyIsland('game-canvas');
            
            // Initialisiere NotificationSystem
            if (typeof NotificationSystem !== 'undefined') {
                window.NotificationSystem = new NotificationSystem();
                console.log('✅ macOS NotificationSystem initialisiert!');
            } else {
                console.error('❌ NotificationSystem Klasse nicht gefunden!');
            }
            
            console.log('✅ Spielbrett mit dynamischen Feld-Konfigurationen geladen!');
            
            // Live-Update-System initialisieren
            console.log('🚀 Initialisiere Live-Update System direkt nach Gameboard...');
            
            // Direkte Implementierung des Live-Update-Systems
            let lastFieldUpdateCheck = 0;
            let liveUpdatePolling = false;
            
            function startLiveFieldUpdates() {
                if (liveUpdatePolling) return;
                
                liveUpdatePolling = true;
                console.log('🔗 Live-Updates aktiviert');
                
                function checkForFieldUpdates() {
                    if (!liveUpdatePolling) return;
                    
                    fetch("{{ url_for('main.board_status') }}?check_field_updates=1&t=" + new Date().getTime())
                        .then(response => response.json())
                        .then(data => {
                            const currentUpdateTime = data.last_field_update || 0;
                            
                            if (lastFieldUpdateCheck > 0 && currentUpdateTime > lastFieldUpdateCheck) {
                                console.log('🔄 Feld-Update erkannt - Gameboard wird neu generiert');
                                
                                if (window.gameBoard) {
                                    console.log('🔄 Löse komplette Board-Regeneration aus...');
                                    
                                    // 1. Lade Feld-Konfigurationen neu (async)
                                    if (typeof reloadFieldConfigurations === 'function') {
                                        console.log('🔄 Lade Feld-Konfigurationen neu...');
                                        reloadFieldConfigurations().then(() => {
                                            console.log('🔄 Konfigurationen geladen, regeneriere Board...');
                                            
                                            // 2. Entferne alte Board-Felder
                                            if (window.gameBoard.boardFields) {
                                                window.gameBoard.boardFields.forEach(field => {
                                                    if (field.mesh) {
                                                        window.gameBoard.scene.remove(field.mesh);
                                                        if (field.mesh.geometry) field.mesh.geometry.dispose();
                                                        if (field.mesh.material) field.mesh.material.dispose();
                                                    }
                                                });
                                                window.gameBoard.boardFields = [];
                                            }
                                            
                                            // 3. Erstelle Board neu
                                            if (window.gameBoard.createGameFields) {
                                                window.gameBoard.createGameFields();
                                            }
                                            
                                            // 4. Aktualisiere Teamdaten
                                            if (window.gameBoard.fetchBoardStatusAndUpdate) {
                                                window.gameBoard.fetchBoardStatusAndUpdate();
                                            }
                                            
                                            console.log('✅ Board-Regeneration mit neuen Konfigurationen abgeschlossen');
                                        });
                                    } else {
                                        console.warn('⚠️ reloadFieldConfigurations nicht verfügbar, verwende Standard-Regeneration');
                                        
                                        // Fallback ohne Neuladen der Konfigurationen
                                        if (window.gameBoard.boardFields) {
                                            window.gameBoard.boardFields.forEach(field => {
                                                if (field.mesh) {
                                                    window.gameBoard.scene.remove(field.mesh);
                                                    if (field.mesh.geometry) field.mesh.geometry.dispose();
                                                    if (field.mesh.material) field.mesh.material.dispose();
                                                }
                                            });
                                            window.gameBoard.boardFields = [];
                                        }
                                        
                                        if (window.gameBoard.createGameFields) {
                                            window.gameBoard.createGameFields();
                                        }
                                        
                                        if (window.gameBoard.fetchBoardStatusAndUpdate) {
                                            window.gameBoard.fetchBoardStatusAndUpdate();
                                        }
                                        
                                        console.log('✅ Board-Regeneration (ohne Konfigurationsneuladung) abgeschlossen');
                                    }
                                }
                            }
                            
                            lastFieldUpdateCheck = Math.max(lastFieldUpdateCheck, currentUpdateTime);
                        })
                        .catch(error => {
                            console.log('Live-Update Check Fehler:', error);
                        })
                        .finally(() => {
                            if (liveUpdatePolling) {
                                setTimeout(checkForFieldUpdates, 2000);
                            }
                        });
                }
                
                setTimeout(checkForFieldUpdates, 3000);
            }
            
            startLiveFieldUpdates();
            
            // Keine automatischen Aktionen mehr - alles manuell
            console.log('🎮 Spielbrett geladen - verwende F für Vollbild, O für Orbit');
            
        } else {
            const canvasContainer = document.getElementById('game-canvas-container');
            if(canvasContainer) {
                canvasContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Fehler: Canvas-Element konnte nicht gefunden werden.</p>";
            }
        }
    } catch (error) {
        console.error("❌ Fehler beim Initialisieren der Insel:", error);
        const canvasContainer = document.getElementById('game-canvas-container');
        if(canvasContainer) {
            canvasContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Fehler beim Laden des Spielbretts. Details in der Konsole.</p>";
        }
    }
});



// Vollbild- und Kamera-Orbit-Animation beim Spielstart
window.addEventListener('message', function(event) {
    if (event.data.action === 'requestFullscreen') {
        // Versuche Vollbild zu aktivieren
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
            document.documentElement.msRequestFullscreen();
        }
        
        // Starte Kamera-Orbit-Animation nach kurzer Verzögerung
        setTimeout(() => {
            startCameraOrbitAnimation();
        }, 500);
    }
});

// Verbesserte orbital camera animation - anti-stutter version
function startCameraOrbitAnimationSmooth(isMinigame = false, duration = null) {
    if (!window.gameBoard || !window.gameBoard.camera || !window.gameBoard.controls) {
        console.warn('Spielbrett oder Kamera noch nicht initialisiert für Orbit-Animation');
        return;
    }
    
    // Verhindere mehrfache Animationen
    if (window.orbitAnimationRunning) {
        console.log('🎥 Kamera-Orbit bereits aktiv - überspringe...');
        return;
    }
    window.orbitAnimationRunning = true;
    
    console.log('🎥 Starte verbesserten eleganten Kamera-Orbit...');
    
    // Speichere ursprüngliche Kamera-Position für spätere Wiederherstellung
    if (!window.originalCameraState) {
        window.originalCameraState = {
            position: window.gameBoard.camera.position.clone(),
            target: window.gameBoard.controls.target.clone()
        };
    }
    
    // Verwende BOARD_CONFIG Einstellungen für konsistente Parameter
    const orbitRadius = BOARD_CONFIG.cameraOrbitRadius;
    const orbitHeight = BOARD_CONFIG.cameraOrbitHeight;
    const orbitSpeed = isMinigame ? BOARD_CONFIG.cameraOrbitSpeed * 0.7 : BOARD_CONFIG.cameraOrbitSpeed;
    
    // Intelligenter Start-Winkel basierend auf aktueller Kamera-Position
    const currentCamPos = window.gameBoard.camera.position.clone();
    const startAngle = Math.atan2(currentCamPos.z, currentCamPos.x); // Starte näher zur aktuellen Position
    
    const startX = Math.cos(startAngle) * orbitRadius;
    const startZ = Math.sin(startAngle) * orbitRadius;
    const startPosition = new THREE.Vector3(startX, orbitHeight, startZ);
    const lookAtTarget = new THREE.Vector3(0, 10, 0);
    
    // Deaktiviere manuelle Kontrolle sanft
    window.gameBoard.controls.enabled = false;
    
    // Verkürzte, smooth transition zum Orbit-Start
    const transitionDuration = Math.min(800, 1200); // Kürzere Transition
    window.gameBoard.animateCameraToPositionSmooth(startPosition, lookAtTarget, transitionDuration, () => {
        let orbitAngle = startAngle;
        let lastTime = performance.now();
        
        // Kontinuierlicher Orbit mit verbesserter Smoothness
        function animateOrbitSmooth(currentTime) {
            // Prüfe ob Animation gestoppt werden soll
            if (!window.orbitAnimationRunning) {
                console.log('🛑 Orbit-Animation gestoppt');
                return;
            }
            
            if (duration && currentTime > duration) {
                console.log('🎥 Orbit-Animation Zeitlimit erreicht');
                stopCameraOrbitAnimationSmooth();
                return;
            }
            
            // Delta-time basierte Animation für consistent movement
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Elegante Orbit-Berechnung mit frame-rate independent movement
            orbitAngle += orbitSpeed * (deltaTime / 16.67); // Normalize to 60fps
            const x = Math.cos(orbitAngle) * orbitRadius;
            const z = Math.sin(orbitAngle) * orbitRadius;
            
            // Sanftere Höhen-Variation mit geringerer Amplitude
            const heightVariation = Math.sin(orbitAngle * 0.6) * 2; // Reduzierte Variation
            const currentHeight = orbitHeight + heightVariation;
            
            // Multi-level smoothing für ultra-flüssige Bewegung
            const targetCameraPos = new THREE.Vector3(x, currentHeight, z);
            window.gameBoard.camera.position.lerp(targetCameraPos, 0.08); // Etwas höhere Lerp-Rate
            
            // Stabilerer Look-At mit weniger Variation
            const lookAtVariation = new THREE.Vector3(
                Math.sin(orbitAngle * 0.2) * 1, // Reduzierte Variation
                0,
                Math.cos(orbitAngle * 0.2) * 1
            );
            const dynamicLookAt = lookAtTarget.clone().add(lookAtVariation);
            window.gameBoard.controls.target.lerp(dynamicLookAt, 0.06);
            window.gameBoard.camera.lookAt(window.gameBoard.controls.target);
            
            requestAnimationFrame(animateOrbitSmooth);
        }
        
        console.log(isMinigame ? '🎮 Starte verbesserten Minispiel-Kamera-Orbit...' : '🎥 Starte verbesserten eleganten Kamera-Orbit um die Insel...');
        requestAnimationFrame(animateOrbitSmooth);
    });
}

// Legacy function für Rücwärtskompatibilität
function startCameraOrbitAnimation(isMinigame = false, duration = null) {
    startCameraOrbitAnimationSmooth(isMinigame, duration);
}

// Verbesserte Stop-Funktion - smooth transition without judder
function stopCameraOrbitAnimationSmooth(restoreOriginal = true) {
    if (!window.orbitAnimationRunning) {
        return;
    }
    
    window.orbitAnimationRunning = false;
    console.log('🛑 Stoppe Kamera-Orbit sanft...');
    
    if (restoreOriginal && window.originalCameraState && window.gameBoard) {
        // Kürzere, smooth transition zurück zur ursprünglichen Position
        const restoreTransitionDuration = 600; // Kürzer für weniger judder
        window.gameBoard.animateCameraToPositionSmooth(
            window.originalCameraState.position, 
            window.originalCameraState.target, 
            restoreTransitionDuration, 
            () => {
                window.gameBoard.controls.enabled = !GAME_STATE.freeCameraMode;
                window.originalCameraState = null;
                console.log('🎥 Kamera sanft zur ursprünglichen Position zurückgekehrt');
            }
        );
    } else if (window.gameBoard) {
        // Sanfte Re-Aktivierung der Controls
        setTimeout(() => {
            window.gameBoard.controls.enabled = !GAME_STATE.freeCameraMode;
        }, 100); // Kleine Verzögerung für smoother Übergang
    }
}

// Legacy function für Rücwärtskompatibilität
function stopCameraOrbitAnimation(restoreOriginal = true) {
    stopCameraOrbitAnimationSmooth(restoreOriginal);
}

// Enhanced minigame camera - starts orbital movement during minigames
function startMinigameCameraOrbit(duration = 30000) { // 30 Sekunden default
    console.log('🎮 Starte verbesserten Minispiel-Kamera-Modus...');
    startCameraOrbitAnimationSmooth(true, duration);
}

// Legacy function für Kompatibilität
function startCameraOrbitAnimationLegacy() {
    startCameraOrbitAnimation(false);
}

// Keine automatischen Aktionen mehr - alles ist manuell steuerbar

// PROFILBILD FACE-OVERLAY SYSTEM

let faceOverlayTimer = null;
let faceOverlayCountdown = 10;

// Integration in die bestehende Update-Funktion
function checkForFaceOverlay() {
    // Hole aktuelle Phase von der globalen Variable
    const currentPhase = currentGamePhase;
    
    // Debug: Prüfe ob Funktion aufgerufen wird
    // console.log('🔍 checkForFaceOverlay() ausgeführt - Phase:', currentPhase, 'lastKnownPhase:', lastKnownPhase);
    
    // Debug: Zeige immer die aktuelle Phase
    if (currentPhase !== lastKnownPhase) {
        console.log('🔄 Phase-Wechsel:', lastKnownPhase, '->', currentPhase);
    }
    
    // VERBESSERT: Erweiterte Phasen-Erkennung für Minispiele  
    const minigameStartPhases = [
        'MINIGAME_ANNOUNCED', 
        'SETUP_MINIGAME',      // Admin wählt Minigame aus
        'MINIGAME_STARTED',    // Minigame läuft
        'QUESTION_ACTIVE'      // Frage ist aktiv
    ];
    const shouldShowFaces = minigameStartPhases.includes(currentPhase) && 
                           lastKnownPhase !== currentPhase && 
                           faceOverlayShownForPhase !== currentPhase;
    
    // Zusätzlich: Prüfe auch auf Minispiel-Namen in der Log-Ausgabe
    const hasMinigameRunning = document.body.innerText.includes('Minigame:') || 
                              (typeof window.currentMinigame !== 'undefined' && window.currentMinigame);
    
    if (shouldShowFaces) {
        console.log('🎭 Phase-Wechsel erkannt:', lastKnownPhase, '->', currentPhase, '- Prüfe Gesichter-Anzeige');
        
        fetch('/api/get-player-faces')
            .then(response => response.json())
            .then(data => {
                console.log('📡 API Response get-player-faces:', data);
                
                if (data.success && data.show_faces && data.player_faces && data.player_faces.length > 0) {
                    console.log('🎭 Zeige ausgewählte Spieler:', data.player_faces);
                    showFaceOverlay(data.player_faces);
                    faceOverlayShownForPhase = currentPhase;
                } else {
                    // VERBESSERT: Bessere Fallback-Logik
                    console.log('🎭 Keine spezifischen Spieler ausgewählt. API Response:', data.message || 'Keine Message');
                    
                    // Wenn die API trotzdem player_faces zurückgibt (auch wenn show_faces false ist)
                    if (data.success && data.player_faces && data.player_faces.length > 0) {
                        console.log('🎯 Verwende player_faces aus API trotz show_faces=false:', data.player_faces);
                        showFloatingBubbles(data.player_faces);
                        faceOverlayShownForPhase = currentPhase;
                    } else {
                        // Letzter Fallback: alle verfügbaren Spieler
                        console.log('🔄 Lade alle verfügbaren Spieler als Fallback');
                        fetch('/api/get-all-player-images')
                            .then(response => response.json())
                            .then(allData => {
                                console.log('📡 API Response get-all-player-images:', allData);
                                if (allData.success && allData.players && allData.players.length > 0) {
                                    console.log('🎭 Zeige alle verfügbaren Spieler:', allData.players);
                                    showFloatingBubbles(allData.players);
                                    faceOverlayShownForPhase = currentPhase;
                                } else {
                                    console.log('⚠️ Keine Spielerdaten verfügbar');
                                }
                            })
                            .catch(error => {
                                console.error('❌ Fehler beim Laden aller Spieler:', error);
                            });
                    }
                }
            })
            .catch(error => {
                console.error('❌ Face-Overlay-Check failed:', error);
            });
    }
    
    // Reset faceOverlayShownForPhase wenn andere Phase erreicht wird
    const allMinigamePhases = ['MINIGAME_ANNOUNCED', 'MINIGAME_STARTED', 'SETUP_MINIGAME', 'MINIGAME_RESULTS', 'DICE_ROLLING', 'PLAYING', 'WAITING_FOR_PLAYERS'];
    if (!allMinigamePhases.includes(currentPhase)) {
        faceOverlayShownForPhase = null;
    }
    
    // Update lastKnownPhase
    lastKnownPhase = currentPhase;
}

function showFaceOverlay(playerFaces) {
    console.log('🎭 Zeige Face-Overlay für Minispiel-Spieler:', playerFaces);
    
    // Zeige die schwebenden Bubbles für alle Spieler mit echten Bildern
    showFloatingBubbles(playerFaces);
    
    // Verwende das bestehende Face-Overlay Container
    const container = document.getElementById('face-overlay-container');
    const faceGrid = document.getElementById('face-grid');
    
    if (!container || !faceGrid) {
        console.error('Face-Overlay Elemente nicht gefunden');
        return;
    }
    
    // Erstelle Gesichter-Grid
    faceGrid.innerHTML = '';
    playerFaces.forEach((player, index) => {
        const faceCard = document.createElement('div');
        faceCard.className = 'face-card';
        
        const faceImage = document.createElement('div');
        faceImage.className = 'face-image';
        
        // Prüfe ob Bild existiert, verwende Fallback wenn nicht
        const img = new Image();
        const imagePath = player.image_path.startsWith('/static/') ? player.image_path : `/static/${player.image_path}`;
        
        img.onload = () => {
            faceImage.style.backgroundImage = `url('${imagePath}')`;
        };
        img.onerror = () => {
            faceImage.style.backgroundImage = 'none';
            faceImage.style.backgroundColor = '#4CAF50';
            faceImage.innerHTML = '<span style="color: white; font-size: 3rem; line-height: 112px; display: block; text-align: center;">👤</span>';
        };
        img.src = imagePath;
        
        const playerName = document.createElement('div');
        playerName.className = 'face-player-name';
        playerName.textContent = player.name;
        
        faceCard.appendChild(faceImage);
        faceCard.appendChild(playerName);
        faceGrid.appendChild(faceCard);
    });
    
    // Zeige Container
    container.classList.add('show');
    
    // Für Vollbild-Modus: überschreibe position zu fixed
    const isInFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement;
    if (isInFullscreen) {
        container.style.position = 'fixed';
        container.style.zIndex = '2147483647';
    }
}

function showDirectFaceOverlay(playerFaces) {
    console.log('🚀 Zeige direktes Face-Overlay für:', playerFaces);
    
    // Entferne bestehende Face-Overlays
    const existingOverlays = document.querySelectorAll('.face-overlay-direct');
    existingOverlays.forEach(el => el.remove());
    
    // Bestimme Titel basierend auf Spieleranzahl
    const playerCount = playerFaces.length;
    let titleText = 'Diese Spieler sind bereit!';
    if (playerCount === 1) {
        titleText = 'Dieser Spieler ist bereit!';
    } else {
        titleText = `Diese ${playerCount} Spieler sind bereit!`;
    }
    
    // CSS für fliegende Gesichter-Animation
    const animationCSS = `
        <style>
            @keyframes floatFace {
                0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 0; }
                20% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); opacity: 1; }
                40% { transform: translate(-40%, -60%) scale(1) rotate(-3deg); }
                60% { transform: translate(-60%, -40%) scale(1.1) rotate(2deg); }
                80% { transform: translate(-45%, -55%) scale(0.9) rotate(-1deg); }
                100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            }
            
            @keyframes floatFace2 {
                0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 0; }
                25% { transform: translate(-50%, -50%) scale(1.1) rotate(-4deg); opacity: 1; }
                50% { transform: translate(-35%, -45%) scale(1) rotate(3deg); }
                75% { transform: translate(-65%, -55%) scale(1.05) rotate(-2deg); }
                100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            }
            
            .floating-face {
                animation-duration: 3s;
                animation-iteration-count: infinite;
                animation-timing-function: ease-in-out;
            }
            
            .floating-face:nth-child(odd) {
                animation-name: floatFace;
            }
            
            .floating-face:nth-child(even) {
                animation-name: floatFace2;
                animation-delay: 0.5s;
            }
        </style>
    `;
    
    // Erstelle fliegende Gesichter HTML
    let flyingFacesHTML = '';
    playerFaces.forEach((player, index) => {
        const randomX = 20 + Math.random() * 60; // 20% bis 80% vom Bildschirm
        const randomY = 20 + Math.random() * 60; // 20% bis 80% vom Bildschirm
        const delay = index * 0.5; // Versetzter Start
        
        flyingFacesHTML += `
            <div class="floating-face" style="
                position: fixed;
                left: ${randomX}%;
                top: ${randomY}%;
                transform: translate(-50%, -50%);
                z-index: 2147483647;
                pointer-events: none;
                animation-delay: ${delay}s;
            ">
                <div style="
                    width: 150px;
                    height: 150px;
                    border-radius: 50%;
                    border: 6px solid white;
                    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
                    background: linear-gradient(135deg, ${player.team_color}, ${player.team_color}dd);
                    background-image: url('/static/${player.image_path}');
                    background-size: cover;
                    background-position: center;
                    background-repeat: no-repeat;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 5rem;
                    color: white;
                    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
                    position: relative;
                ">${player.image_path.includes('nonexistent') ? '👤' : ''}
                    <div style="
                        position: absolute;
                        bottom: -50px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 0.5rem 1rem;
                        border-radius: 20px;
                        font-size: 1rem;
                        font-weight: bold;
                        white-space: nowrap;
                        text-align: center;
                    ">${player.player_name}</div>
                </div>
            </div>
        `;
    });
    
    // Erstelle komplettes Overlay direkt - für VOLLBILD optimiert
    const overlay = document.createElement('div');
    overlay.className = 'face-overlay-direct';
    overlay.innerHTML = animationCSS + `
        <div style="
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 2147483647 !important;
            pointer-events: none !important;
            background: rgba(0, 0, 0, 0.6) !important;
            backdrop-filter: blur(3px) !important;
        "></div>
        <div style="
            position: fixed !important;
            top: 5% !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            color: white !important;
            font-size: 3rem !important;
            font-weight: 900 !important;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.8) !important;
            text-align: center !important;
            z-index: 2147483647 !important;
            pointer-events: none !important;
        ">${titleText}</div>
        ${flyingFacesHTML}
        <div id="face-overlay-direct-timer" style="
            position: fixed !important;
            bottom: 5% !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            background: rgba(255, 255, 255, 0.9) !important;
            color: #333 !important;
            padding: 1.5rem 3rem !important;
            border-radius: 50px !important;
            font-size: 2rem !important;
            font-weight: 700 !important;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4) !important;
            z-index: 2147483647 !important;
            pointer-events: none !important;
        ">10</div>
    `;
    
    // Füge zum body hinzu
    document.body.appendChild(overlay);
    console.log('✅ Direktes Face-Overlay erstellt und angezeigt');
    
    // Prüfe Bilder und zeige Fallback bei Fehlern
    playerFaces.forEach((player, index) => {
        if (!player.image_path.includes('nonexistent')) {
            const faceElement = document.getElementById(`face-${index}`);
            if (faceElement) {
                // Teste ob Bild lädt
                const testImg = new Image();
                testImg.onload = function() {
                    // Bild erfolgreich geladen - verstecke 👤
                    faceElement.textContent = '';
                };
                testImg.onerror = function() {
                    // Bild konnte nicht geladen werden - zeige 👤
                    faceElement.textContent = '👤';
                    faceElement.style.backgroundImage = 'none';
                    console.log(`⚠️ Profilbild für ${player.player_name} nicht gefunden - zeige Fallback`);
                };
                testImg.src = `/static/${player.image_path}`;
            }
        }
    });
    
    // Timer starten
    let countdown = 10;
    const timerElement = document.getElementById('face-overlay-direct-timer');
    
    const timer = setInterval(() => {
        countdown--;
        if (timerElement) {
            timerElement.textContent = countdown;
        }
        
        if (countdown <= 0) {
            clearInterval(timer);
            overlay.remove();
            console.log('🎭 Face-Overlay automatisch versteckt nach 10 Sekunden');
        }
    }, 1000);
}

function hideFaceOverlay() {
    // Verstecke das ursprüngliche Face-Overlay
    const container = document.getElementById('face-overlay-container');
    if (container) {
        container.classList.remove('show');
        container.style.display = 'none';
    }
    
    // Entferne alle direkten Face-Overlays
    const directOverlays = document.querySelectorAll('.face-overlay-direct');
    directOverlays.forEach(el => el.remove());
    
    if (faceOverlayTimer) {
        clearInterval(faceOverlayTimer);
        faceOverlayTimer = null;
    }
    
    console.log('🎭 Face-Overlay versteckt');
}

// Phase-Tracking für Gesichter-Anzeige
let lastKnownPhase = null;
let faceOverlayShownForPhase = null;

// Integration in bestehende Update-Funktion erweitern
// Suche nach der bestehenden updateGameStatus Funktion und erweitere sie
const originalUpdateGameStatus = window.updateGameStatus || function() {};
window.updateGameStatus = function() {
    originalUpdateGameStatus();
    
    // Check for face overlay bei SETUP_MINIGAME und MINIGAME_STARTED Phase
    checkForFaceOverlay();
};

// Fallback: Wenn updateGameStatus nicht existiert, prüfe regelmäßig
if (!window.updateGameStatus || typeof window.updateGameStatus !== 'function') {
    // Prüfe alle 3 Sekunden auf Face-Overlay
    setInterval(checkForFaceOverlay, 3000);
}

// Test-Funktion für manuellen Trigger
window.triggerFaceCheck = function() {
    console.log('🧪 Manueller Face-Check ausgelöst');
    checkForFaceOverlay();
};

// Funktion zum direkten Anzeigen aller Spieler bei Minispiel-Start
window.showAllPlayersForMinigame = function() {
    console.log('🎮 Minispiel gestartet - zeige alle Spieler');
    fetch('/api/get-all-player-images')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.players.length > 0) {
                console.log('🎭 Zeige alle Spieler für Minispiel:', data.players);
                showFloatingBubbles(data.players);
            } else {
                console.log('⚠️ Keine Spieler für Minispiel gefunden');
            }
        })
        .catch(error => {
            console.error('❌ Fehler beim Laden der Minispiel-Spieler:', error);
        });
};

// Cleanup bei Seitenverlassen
window.addEventListener('beforeunload', function() {
    if (faceOverlayTimer) {
        clearInterval(faceOverlayTimer);
    }
});

// Test-Funktion für Face-Overlay
function testFaceOverlay() {
    console.log('🧪 Teste Face-Overlay manuell');
    
    // Zeige erstmal nur das Container-Element
    const container = document.getElementById('face-overlay-container');
    const faceGrid = document.getElementById('face-grid');
    const title = document.getElementById('face-overlay-title');
    const timer = document.getElementById('face-overlay-timer');
    
    console.log('🔍 Face-Overlay Elemente:', {
        container: !!container,
        faceGrid: !!faceGrid,
        title: !!title,
        timer: !!timer,
        containerVisible: container ? getComputedStyle(container).display : 'not found',
        containerOpacity: container ? getComputedStyle(container).opacity : 'not found',
        containerZIndex: container ? getComputedStyle(container).zIndex : 'not found'
    });
    
    if (!container) {
        console.error('❌ Face-Overlay-Container nicht gefunden!');
        alert('Face-Overlay-Container nicht gefunden!');
        return;
    }
    
    // Setze Titel
    title.textContent = 'TEST: Face-Overlay funktioniert!';
    
    // Erstelle Test-Gesichter mit echten Bildern aus dem System
    const testFaces = [
        {
            player_name: "Jonas",
            team_name: "Team Rot",
            team_id: 1,
            team_color: "#ff5722",
            image_path: "profile_images/1_Jonas_20250613_164541.jpg" // Echtes Bild
        },
        {
            player_name: "Leonie", 
            team_name: "Team Blau",
            team_id: 2,
            team_color: "#2196f3",
            image_path: "profile_images/1_Leonie_20250613_164555.jpg" // Echtes Bild
        }
    ];
    
    console.log('🎭 Zeige Test-Gesichter:', testFaces);
    showFaceOverlay(testFaces);
}

// Einfacherer Test ohne Bilder
function testSimpleOverlay() {
    console.log('🧪 Teste einfaches Overlay ohne Bilder');
    
    const container = document.getElementById('face-overlay-container');
    const title = document.getElementById('face-overlay-title');
    const timer = document.getElementById('face-overlay-timer');
    const faceGrid = document.getElementById('face-grid');
    
    if (!container) {
        alert('Container nicht gefunden!');
        return;
    }
    
    // FORCE das Styling direkt via JavaScript
    container.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 999999999 !important;
        background: rgba(0, 0, 0, 0.8) !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: center !important;
        align-items: center !important;
        opacity: 1 !important;
        pointer-events: auto !important;
    `;
    
    // Force Titel-Styling
    title.style.cssText = `
        color: white !important;
        font-size: 3rem !important;
        font-weight: bold !important;
        text-align: center !important;
        margin-bottom: 2rem !important;
        z-index: 999999999 !important;
    `;
    
    // Force Timer-Styling
    timer.style.cssText = `
        color: yellow !important;
        font-size: 2rem !important;
        font-weight: bold !important;
        text-align: center !important;
        margin-top: 2rem !important;
        z-index: 999999999 !important;
    `;
    
    // Verstecke Grid, zeige nur Titel und Timer
    faceGrid.innerHTML = '<div style="color: white !important; font-size: 2rem !important; text-align: center !important; z-index: 999999999 !important;">TEST: Das Overlay funktioniert!</div>';
    title.textContent = 'OVERLAY-TEST ERFOLGREICH!';
    timer.textContent = '5';
    
    console.log('📺 Zeige einfaches Test-Overlay mit Force-Styling...');
    
    // Auto-Hide nach 5 Sekunden
    setTimeout(() => {
        console.log('🎯 Verstecke Test-Overlay nach 5 Sekunden');
        container.style.display = 'none';
    }, 5000);
}

// Komplett neue direkte Overlay-Funktion
function createDirectOverlay() {
    console.log('🚀 Erstelle direktes Overlay...');
    
    // Entferne alle bestehenden Test-Overlays
    const existingOverlays = document.querySelectorAll('.direct-test-overlay');
    existingOverlays.forEach(el => el.remove());
    
    // Erstelle neues Overlay-Element direkt
    const overlay = document.createElement('div');
    overlay.className = 'direct-test-overlay';
    overlay.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2147483647;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
        ">
            <h1 style="font-size: 4rem; margin-bottom: 2rem; text-align: center;">
                🎭 FACE OVERLAY TEST
            </h1>
            <p style="font-size: 2rem; margin-bottom: 3rem; text-align: center;">
                Das ist ein direktes Overlay - es sollte über ALLEM stehen!
            </p>
            <div style="
                display: grid;
                grid-template-columns: repeat(2, 200px);
                gap: 2rem;
                margin-bottom: 3rem;
            ">
                <div style="
                    background: rgba(255, 87, 34, 0.9);
                    padding: 2rem;
                    border-radius: 20px;
                    text-align: center;
                    border: 3px solid white;
                ">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">👤</div>
                    <div style="font-size: 1.2rem; font-weight: bold;">Test Spieler 1</div>
                    <div style="font-size: 1rem; margin-top: 0.5rem;">Team Rot</div>
                </div>
                <div style="
                    background: rgba(33, 150, 243, 0.9);
                    padding: 2rem;
                    border-radius: 20px;
                    text-align: center;
                    border: 3px solid white;
                ">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">👤</div>
                    <div style="font-size: 1.2rem; font-weight: bold;">Test Spieler 2</div>
                    <div style="font-size: 1rem; margin-top: 0.5rem;">Team Blau</div>
                </div>
            </div>
            <div id="direct-timer" style="
                background: rgba(255, 255, 255, 0.9);
                color: black;
                padding: 1rem 2rem;
                border-radius: 30px;
                font-size: 2rem;
                font-weight: bold;
            ">5</div>
        </div>
    `;
    
    // Füge direkt zum body hinzu
    document.body.appendChild(overlay);
    
    console.log('✅ Direktes Overlay erstellt und zum body hinzugefügt');
    
    // Countdown Timer
    let countdown = 5;
    const timerElement = document.getElementById('direct-timer');
    
    const timer = setInterval(() => {
        countdown--;
        if (timerElement) {
            timerElement.textContent = countdown;
        }
        
        if (countdown <= 0) {
            clearInterval(timer);
            overlay.remove();
            console.log('🎯 Direktes Overlay nach 5 Sekunden entfernt');
        }
    }, 1000);
}

// Funktion zum Verstecken aller Overlays
function hideAllOverlays() {
    console.log('❌ Verstecke alle Overlays...');
    
    // Verstecke das Face-Overlay
    const container = document.getElementById('face-overlay-container');
    if (container) {
        container.style.display = 'none';
        container.classList.remove('show');
    }
    
    // Entferne alle direkten Test-Overlays
    const directOverlays = document.querySelectorAll('.direct-test-overlay');
    directOverlays.forEach(el => el.remove());
    
    // Entferne auch Face-Overlays
    const faceOverlays = document.querySelectorAll('.face-overlay-direct');
    faceOverlays.forEach(el => el.remove());
    
    // Stoppe alle Timer
    if (faceOverlayTimer) {
        clearInterval(faceOverlayTimer);
        faceOverlayTimer = null;
    }
    
    console.log('✅ Alle Overlays versteckt');
}


// Zeige Gesichter als schwebende Bubbles (für Test)
function showFaceBanner(playerFaces) {
    console.log('🎭 Zeige schwebende Gesichter-Bubbles:', playerFaces);
    showFloatingBubbles(playerFaces);
}

// Zeige schwebende Bubbles automatisch für Minispiel-Spieler
function showFloatingBubbles(playerFaces) {
    console.log('🎭 Zeige automatische schwebende Bubbles für:', playerFaces);
    
    // Entferne vorherige Bubbles falls vorhanden
    const container = document.getElementById('face-overlay-container');
    if (container) {
        const existingBubbles = container.querySelectorAll('.face-bubble');
        existingBubbles.forEach(bubble => bubble.remove());
    }
    
    // Sicherheitscheck: Stelle sicher, dass playerFaces ein Array ist
    if (!Array.isArray(playerFaces)) {
        console.log('⚠️ playerFaces ist kein Array:', playerFaces);
        return;
    }
    
    // VERBESSERT: Filter alle gültigen Spieler (mit Bildern ODER Emojis)
    const validPlayers = playerFaces.filter(player => {
        if (!player || typeof player !== 'object') {
            console.log('⚠️ Ungültiger Spieler:', player);
            return false;
        }
        
        // Verbesserte Bild-Erkennung - weniger restriktiv
        const hasValidImage = player.image_path && 
               player.image_path.trim() !== '' && 
               player.image_path !== 'null' &&
               player.image_path !== 'undefined';
               
        // Emoji-Erkennung - akzeptiere alle Unicode-Emoji
        const hasEmoji = player.emoji && player.emoji.trim() !== '';
        
        // ZUSÄTZLICH: Fallback wenn has_photo explizit true ist
        const hasPhotoFlag = player.has_photo === true;
        
        if (hasValidImage || hasPhotoFlag) {
            console.log('✅ Gültiger Spieler mit Bild gefunden:', player.player_name || player.name, player.image_path);
        } else if (hasEmoji) {
            console.log('😀 Gültiger Spieler mit Emoji gefunden:', player.player_name || player.name, player.emoji);
        } else {
            console.log('⚠️ Spieler ohne gültiges Bild/Emoji:', player.player_name || player.name);
        }
        
        // WICHTIG: Zeige auch Spieler ohne Bild/Emoji (wird später automatisches Emoji generieren)
        return hasValidImage || hasPhotoFlag || hasEmoji || (player.player_name || player.name);
    });
    
    console.log('🖼️ Gültige Spieler gefunden:', validPlayers.length, 'von', playerFaces.length);
    
    // Debug-Info für ALLE Spieler anzeigen
    console.log('🔍 Debug - Alle empfangenen Spielerdaten:');
    playerFaces.forEach((player, i) => {
        console.log(`Spieler ${i}:`, {
            player_name: player?.player_name,
            name: player?.name,
            image_path: player?.image_path,
            emoji: player?.emoji,
            has_photo: player?.has_photo,
            team_id: player?.team_id,
            team_name: player?.team_name
        });
    });
    
    if (validPlayers.length === 0) {
        console.log('⚠️ Keine gültigen Spieler gefunden');
        return;
    }
    
    // Erstelle Bubbles auch wenn Spielbrett noch nicht vollständig geladen ist
    try {
        validPlayers.forEach((player, index) => {
            createFloatingBubble(player, index);
        });
    } catch (error) {
        console.error('❌ Fehler beim Erstellen der Bubbles:', error);
    }
}

function createFloatingBubble(player, index) {
    // Verwende den gleichen Container wie Simple Test für Vollbild-Kompatibilität
    const container = document.getElementById('face-overlay-container');
    if (!container) {
        console.error('❌ face-overlay-container nicht gefunden');
        return;
    }
    
    // Force Container-Styling wie Simple Test
    container.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 999999999 !important;
        background: transparent !important;
        display: block !important;
        opacity: 1 !important;
        pointer-events: none !important;
    `;
    
    const bubble = document.createElement('div');
    bubble.className = 'face-bubble';
    bubble.style.cssText = `
        position: absolute !important;
        width: 240px !important;
        height: 280px !important;
        z-index: 999999999 !important;
        pointer-events: none !important;
        text-align: center !important;
    `;
    
    // Erstelle Bild oder Emoji basierend auf verfügbaren Daten
    let imageElement;
    // VERBESSERT: Weniger restriktive Bild-Erkennung
    const hasValidImage = (player.image_path && 
           player.image_path.trim() !== '' && 
           player.image_path !== 'null' &&
           player.image_path !== 'undefined') || 
           player.has_photo === true;
    
    if (hasValidImage) {
        // Verwende Profilbild
        imageElement = document.createElement('img');
        imageElement.src = `/static/${player.image_path}`;
        imageElement.style.cssText = `
            width: 200px !important;
            height: 200px !important;
            border-radius: 50% !important;
            border: 6px solid ${player.team_color} !important;
            object-fit: cover !important;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3) !important;
        `;
        
        // Fallback für Bildfehler
        imageElement.onerror = function() {
            // Erstelle Emoji-Element als Fallback
            const emojiElement = document.createElement('div');
            emojiElement.textContent = player.emoji || '👤';
            emojiElement.style.cssText = `
                width: 200px !important;
                height: 200px !important;
                border-radius: 50% !important;
                border: 6px solid ${player.team_color} !important;
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                font-size: 80px !important;
                box-shadow: 0 8px 30px rgba(0,0,0,0.3) !important;
            `;
            this.parentNode.replaceChild(emojiElement, this);
        };
    } else if (player.emoji) {
        // Verwende Emoji
        imageElement = document.createElement('div');
        imageElement.textContent = player.emoji;
        imageElement.style.cssText = `
            width: 200px !important;
            height: 200px !important;
            border-radius: 50% !important;
            border: 6px solid ${player.team_color} !important;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 80px !important;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3) !important;
        `;
    } else {
        // VERBESSERT: Fallback mit automatischer Emoji-Generierung
        let fallbackEmoji = '👤';
        
        // Verwende die gleiche deterministische Emoji-Logik wie das Backend
        if (player.player_name || player.name) {
            fallbackEmoji = getPlayerEmojiForBoard(player.player_name || player.name);
        }
        
        imageElement = document.createElement('div');
        imageElement.textContent = fallbackEmoji;
        imageElement.style.cssText = `
            width: 200px !important;
            height: 200px !important;
            border-radius: 50% !important;
            border: 6px solid ${player.team_color || '#CCCCCC'} !important;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 80px !important;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3) !important;
        `;
        console.log('🎭 Verwende Fallback-Emoji:', fallbackEmoji, 'für Spieler:', player.player_name || player.name);
    }
    
    const name = document.createElement('div');
    name.textContent = player.player_name || player.name;
    name.style.cssText = `
        margin-top: 10px !important;
        font-size: 28px !important;
        font-weight: bold !important;
        color: ${player.team_color} !important;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.7) !important;
        background: rgba(0,0,0,0.5) !important;
        padding: 4px 16px !important;
        border-radius: 20px !important;
    `;
    
    bubble.appendChild(imageElement);
    bubble.appendChild(name);
    container.appendChild(bubble);
    
    // Startposition (zufällig am Rand)
    const startX = Math.random() * (window.innerWidth - 240);
    const startY = Math.random() * (window.innerHeight - 280);
    bubble.style.left = startX + 'px';
    bubble.style.top = startY + 'px';
    
    // Animation Parameter
    let x = startX;
    let y = startY;
    let vx = (Math.random() - 0.5) * 4; // Geschwindigkeit X
    let vy = (Math.random() - 0.5) * 4; // Geschwindigkeit Y
    let time = 0;
    
    // Animationsschleife
    const animate = () => {
        time += 0.02;
        
        // Schwebe-Bewegung mit Sin/Cos für natürlichere Bewegung
        x += vx + Math.sin(time * 2 + index) * 0.5;
        y += vy + Math.cos(time * 1.5 + index) * 0.5;
        
        // Grenzen prüfen und abprallen lassen
        if (x <= 0 || x >= window.innerWidth - 240) {
            vx = -vx;
            x = Math.max(0, Math.min(window.innerWidth - 240, x));
        }
        if (y <= 0 || y >= window.innerHeight - 280) {
            vy = -vy;
            y = Math.max(0, Math.min(window.innerHeight - 280, y));
        }
        
        // Position aktualisieren
        bubble.style.left = x + 'px';
        bubble.style.top = y + 'px';
        
        // Rotation für lebendige Bewegung
        bubble.style.transform = `rotate(${Math.sin(time * 3) * 5}deg)`;
    };
    
    // Animation starten
    const animationInterval = setInterval(animate, 16); // ~60fps
    
    // Bubble nach 10 Sekunden entfernen
    setTimeout(() => {
        clearInterval(animationInterval);
        if (bubble.parentNode) {
            bubble.style.transition = 'opacity 1s';
            bubble.style.opacity = '0';
            setTimeout(() => bubble.remove(), 1000);
        }
    }, 10000);
}

// Test mit echten verfügbaren Bildern
function testRealImages() {
    console.log('📸 Teste mit echten verfügbaren Bildern...');
    
    // Liste der verfügbaren Bilder (aus /app/static/profile_images/)
    const availableImages = [
        'profile_images/1_Jonas_20250613_164541.jpg',
        'profile_images/1_Leonie_20250613_164555.jpg'
    ];
    
    // Teste jeden Bildpfad
    availableImages.forEach((imagePath, index) => {
        const testImg = new Image();
        testImg.onload = function() {
            console.log(`✅ Bild verfügbar: ${imagePath}`);
        };
        testImg.onerror = function() {
            console.log(`❌ Bild nicht verfügbar: ${imagePath}`);
        };
        testImg.src = `/static/${imagePath}`;
    });
    
    // Lade verfügbare Spieler und ihre Bilder vom Server
    console.log('🔍 Lade alle verfügbaren Spieler und ihre Bilder...');
    
    fetch('/api/get-all-player-images')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.players.length > 0) {
                console.log('✅ Verfügbare Spieler mit Bildern:', data.players);
                showFloatingBubbles(data.players);
            } else {
                console.log('⚠️ Keine Spieler mit Bildern gefunden');
                // Fallback zu Test-Daten
                const fallbackFaces = [
                    {
                        player_name: "JonasHandball",
                        team_name: "Team 1", 
                        team_id: 1,
                        team_color: "#ff5722",
                        image_path: "profile_images/1_JonasHandball_20250613_174137.jpg"
                    },
                    {
                        player_name: "Leonie",
                        team_name: "Team 1",
                        team_id: 1, 
                        team_color: "#ff5722",
                        image_path: "profile_images/1_Leonie_20250613_174147.jpg"
                    },
                    {
                        player_name: "Kristof",
                        team_name: "Team 2",
                        team_id: 2, 
                        team_color: "#2196f3",
                        image_path: "profile_images/1_Kristof_20250613_174210.jpg"
                    },
                    {
                        player_name: "Tim",
                        team_name: "Team 2",
                        team_id: 2, 
                        team_color: "#2196f3",
                        image_path: "profile_images/1_Tim_20250613_174157.jpg"
                    }
                ];
                showFloatingBubbles(fallbackFaces);
            }
        })
        .catch(error => {
            console.error('❌ Fehler beim Laden der Spieler-Daten:', error);
        });
}

console.log('✅ Face-Overlay-System für Profilbilder geladen');

// NEU: Field Minigame Banner Functions
let fieldMinigameBannerShown = false; // Flag to prevent repeated showing
let lastShownMinigameData = null; // Track the specific minigame data

function showFieldMinigameBanner(teamData) {
    console.log('🎮 Zeige Field Minigame Banner:', teamData);
    
    // Create a unique identifier for this minigame instance
    const minigameKey = `${teamData.landing_team}_${teamData.minigame_name}_${teamData.mode}_${teamData.opponent_team}`;
    const lastMinigameKey = lastShownMinigameData ? 
        `${lastShownMinigameData.landing_team}_${lastShownMinigameData.minigame_name}_${lastShownMinigameData.mode}_${lastShownMinigameData.opponent_team}` : null;
    
    console.log('🔍 Minigame Keys:', { current: minigameKey, last: lastMinigameKey, shown: fieldMinigameBannerShown });
    
    // Prevent repeated showing of the same minigame
    if (fieldMinigameBannerShown && minigameKey === lastMinigameKey) {
        console.log('🎯 Field Minigame Banner bereits angezeigt für dieses Minispiel - überspringe');
        return;
    }
    
    const banner = document.getElementById('field-minigame-banner');
    const teamsElement = document.getElementById('field-minigame-banner-teams');
    const descriptionElement = document.getElementById('field-minigame-banner-description');
    
    if (!banner || !teamsElement || !descriptionElement) {
        console.error('❌ Field Minigame Banner Elemente nicht gefunden');
        return;
    }
    
    // Team-Info setzen
    let teamsText = '';
    if (teamData.mode === 'team_vs_team') {
        teamsText = `${teamData.landing_team} vs ${teamData.opponent_team}`;
    } else {
        teamsText = `${teamData.landing_team} vs alle anderen Teams`;
    }
    
    teamsElement.textContent = teamsText;
    
    // Beschreibung setzen mit prominenter Hervorhebung
    let description = `🎮 MINISPIEL: "${teamData.minigame_name.toUpperCase()}" wurde gestartet!`;
    
    if (teamData.mode === 'team_vs_team') {
        description += `\n🆚 Zwei Teams kämpfen gegeneinander.`;
    } else {
        description += `\n🆚 Ein Team gegen alle anderen.`;
    }
    description += `\n🏆 Der Gewinner bekommt 5 Felder Vorsprung!`;
    
    // Regeln/Anweisungen prominent anzeigen
    if (teamData.minigame_instructions && teamData.minigame_instructions.trim()) {
        description += `\n\n📋 REGELN:\n${teamData.minigame_instructions}`;
    }
    
    // Material anzeigen
    if (teamData.minigame_materials && teamData.minigame_materials.trim() && teamData.minigame_materials !== 'Keine') {
        description += `\n\n🎯 MATERIAL: ${teamData.minigame_materials}`;
    }
    
    // Ausgeloste Spieler anzeigen
    if (teamData.selected_players && Object.keys(teamData.selected_players).length > 0) {
        description += `\n\n👥 TEILNEHMER:`;
        for (const [teamName, players] of Object.entries(teamData.selected_players)) {
            if (players && players.length > 0) {
                // Unterstütze sowohl neues Format mit Profilbildern als auch altes Format
                const playerNames = players.map(p => {
                    if (typeof p === 'object' && p.name) {
                        return p.name; // Neues Format: {name: "...", profile_image: "..."}
                    } else if (typeof p === 'string') {
                        return p; // Altes Format: nur String
                    } else if (typeof p === 'object' && p.name) {
                        return p.name; // Fallback
                    }
                    return String(p); // Sicherheits-Fallback
                }).join(', ');
                description += `\n• ${teamName}: ${playerNames}`;
            }
        }
    }
    
    descriptionElement.textContent = description;
    
    // Banner anzeigen
    banner.style.display = 'flex';
    fieldMinigameBannerShown = true; // Mark as shown
    lastShownMinigameData = teamData; // Store current minigame data
    
    // Zeige Spielergesichter nach kurzer Verzögerung wie bei normalen Minigames
    setTimeout(() => {
        showFieldMinigamePlayerFaces(teamData.selected_players);
    }, 2000);
    
    // Banner bleibt bis Field-Minispiel beendet ist (kein 8s Timeout mehr)
}

// Emoji-Generierung für Spieler (identisch zur edit_team.html Logik)
function getPlayerEmojiForBoard(playerName) {
    const emojis = [
        "😀", "😃", "😄", "😁", "😆", "😅", "🤣", "😂", "🙂", "🙃", 
        "😉", "😊", "😇", "🥰", "😍", "🤩", "😘", "😗", "😚", "😙",
        "😋", "😛", "😜", "🤪", "😝", "🤑", "🤗", "🤭", "🤫", "🤔",
        "🤓", "😎", "🤡", "🥳", "😏", "😒", "😞", "😔", "😟", "😕",
        "🙁", "☹️", "😣", "😖", "😫", "😩", "🥺", "😢", "😭", "😤",
        "😠", "😡", "🤬", "🤯", "😳", "🥵", "🥶", "😱", "😨", "😰"
    ];
    
    // Einfacher Hash für deterministische Emoji-Zuweisung
    let hash = 0;
    for (let i = 0; i < playerName.length; i++) {
        const char = playerName.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return emojis[Math.abs(hash) % emojis.length];
}

// Konvertiere Feld-Minigame Spielerdaten in das korrekte Format für showFloatingBubbles
function showFieldMinigamePlayerFaces(selectedPlayers) {
    if (!selectedPlayers || Object.keys(selectedPlayers).length === 0) {
        console.log('❌ Keine Spielerdaten für Face-Overlay:', selectedPlayers);
        return;
    }
    
    console.log('🎭 Konvertiere Feld-Minigame Spieler für Face-Overlay:', selectedPlayers);
    
    // Konvertiere in das erwartete Format für showFloatingBubbles
    const playerFaces = [];
    
    for (const [teamName, players] of Object.entries(selectedPlayers)) {
        // Hole Team-Informationen für Farbe und ID
        const teamElement = document.querySelector(`[data-team-name="${teamName}"]`);
        const teamColor = teamElement ? getComputedStyle(teamElement).color : '#666';
        
        // Finde Team-ID (vereinfacht - verwende Team-Index)
        const allTeamNames = Object.keys(selectedPlayers);
        const teamId = allTeamNames.indexOf(teamName) + 1;
        
        for (const player of players) {
            const playerName = typeof player === 'object' ? player.name : player;
            const profileImage = typeof player === 'object' ? player.profile_image : null;
            const hasPhoto = typeof player === 'object' ? player.has_photo : false;
            const emoji = typeof player === 'object' ? player.emoji : null;
            
            // Fallback: generiere Emoji deterministisch vom Namen falls keins vorhanden
            const finalEmoji = emoji || getPlayerEmojiForBoard(playerName);
            
            console.log(`🎭 Spieler "${playerName}": Emoji von Backend: ${emoji}, Finales Emoji: ${finalEmoji}`);
            
            playerFaces.push({
                player_name: playerName,
                name: playerName, // Alias für Kompatibilität mit showFloatingBubbles
                team_name: teamName,
                team_id: teamId,
                team_color: teamColor,
                image_path: profileImage || null,
                has_photo: hasPhoto,
                emoji: finalEmoji
            });
        }
    }
    
    console.log('✅ Konvertierte Spielerdaten für showFloatingBubbles:', playerFaces);
    
    // Verwende die bestehende showFloatingBubbles Funktion
    showFloatingBubbles(playerFaces);
}

function hideFieldMinigameBanner() {
    const banner = document.getElementById('field-minigame-banner');
    if (banner) {
        banner.style.display = 'none';
        // DON'T reset fieldMinigameBannerShown here - keep it true to prevent reshowing the same minigame
        // Only reset when phase changes or different minigame starts
        console.log('🎯 Field Minigame Banner versteckt - aber Flag bleibt gesetzt für dieses Minispiel');
    }
}

// NEU: Field Minigame Ergebnis Banner anzeigen
function showFieldMinigameResultBanner(resultData) {
    console.log('🏆 Zeige Field Minigame Ergebnis Banner:', resultData);
    
    // Verwende das bestehende field-minigame-banner Element aber mit neuen Inhalten
    const banner = document.getElementById('field-minigame-banner');
    const teamsElement = document.getElementById('field-minigame-banner-teams');
    const descriptionElement = document.getElementById('field-minigame-banner-description');
    const titleElement = document.querySelector('#field-minigame-banner .banner-title');
    const iconElement = document.querySelector('#field-minigame-banner .banner-icon i');
    
    if (!banner || !teamsElement || !descriptionElement || !titleElement || !iconElement) {
        console.error('❌ Field Minigame Result Banner Elemente nicht gefunden');
        return;
    }
    
    // Banner-Inhalt für Ergebnis anpassen
    if (resultData.won) {
        titleElement.textContent = '🎉 Gewonnen!';
        iconElement.className = 'fas fa-trophy';
        teamsElement.textContent = `${resultData.team_name} hat gewonnen!`;
        descriptionElement.textContent = `Belohnung: ${resultData.reward_forward} Felder vorwärts!`;
        
        // Banner-Stil für Gewinn (grün)
        const bannerContent = banner.querySelector('.banner-content');
        if (bannerContent) {
            bannerContent.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
        }
    } else {
        titleElement.textContent = '😞 Verloren';
        iconElement.className = 'fas fa-times-circle';
        teamsElement.textContent = `${resultData.team_name} hat verloren`;
        descriptionElement.textContent = 'Keine Belohnung - das nächste Mal klappt es!';
        
        // Banner-Stil für Verlust (rot)
        const bannerContent = banner.querySelector('.banner-content');
        if (bannerContent) {
            bannerContent.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
        }
    }
    
    // Banner anzeigen
    banner.style.display = 'flex';
    
    // Banner nach 5 Sekunden automatisch verstecken und Phase weiterschalten
    setTimeout(() => {
        banner.style.display = 'none';
        console.log('🎯 Field Minigame Result Banner versteckt - schalte Phase weiter');
        // Phase automatisch weiterschalten zur nächsten Phase
        advanceFieldMinigamePhase();
    }, 5000);
}

// NEU: Field Minigame Phase weiterschalten
function advanceFieldMinigamePhase() {
    console.log('⏭️ Schalte Field Minigame Phase weiter');
    
    fetch('/api/advance_field_minigame_phase', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('meta[name=csrf-token]')?.getAttribute('content') || ''
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('✅ Field Minigame Phase erfolgreich weitergeschaltet:', data.new_phase);
            // Flag zurücksetzen für neue Field Minigames
            fieldMinigameBannerShown = false;
            lastShownMinigameData = null;
        } else {
            console.error('❌ Fehler beim Weiterschalten der Field Minigame Phase:', data.message);
        }
    })
    .catch(error => {
        console.error('❌ Netzwerkfehler beim Weiterschalten der Phase:', error);
    });
}

// NEU: Check for Field Minigame Events
function checkForFieldMinigameEvents() {
    fetch('/api/field_minigame_status')
        .then(response => response.json())
        .then(data => {
            console.log('🎯 Field Minigame Status Response:', data);
            if (data.show_banner) {
                if (data.banner_type === 'start' && data.minigame_data) {
                    // Start-Banner anzeigen
                    console.log('🎮 Triggering start banner:', data.minigame_data);
                    showFieldMinigameBanner(data.minigame_data);
                } else if (data.banner_type === 'result' && data.result_data) {
                    // Ergebnis-Banner anzeigen
                    console.log('🏆 Triggering result banner:', data.result_data);
                    showFieldMinigameResultBanner(data.result_data);
                } else {
                    console.log('🤔 Unknown banner type or missing data:', data);
                }
            } else {
                console.log('🚫 No banner to show - verstecke vorhandenes Banner:', data);
                // Verstecke Banner wenn keines angezeigt werden soll
                hideFieldMinigameBanner();
            }
        })
        .catch(error => {
            // Stille Fehler - nicht jeden Fehler loggen
            if (Math.random() < 0.01) { // Nur 1% der Fehler loggen
                console.log('Field Minigame Status Check Error:', error);
            }
        });
}

console.log('✅ Face-Overlay-System für Profilbilder geladen');
console.log('✅ Field Minigame Banner System geladen');

// Starte Face-Overlay-Check sofort und dann alle 3 Sekunden
console.log('🚀 Starte Face-Overlay-Check System...');
checkForFaceOverlay(); // Einmal sofort ausführen
setInterval(checkForFaceOverlay, 3000); // Dann alle 3 Sekunden

// NEU: Starte Field Minigame Event Check
setInterval(checkForFieldMinigameEvents, 2000); // Alle 2 Sekunden

</script>

<!-- Live-Update-System wurde direkt nach Gameboard-Initialisierung eingefügt -->
{% endblock %}